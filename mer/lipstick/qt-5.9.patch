From d148e3970b38a81a34a9e921f245bbb74d1f947e Mon Sep 17 00:00:00 2001
From: Florent Revest <revestflo@gmail.com>
Date: Tue, 28 Feb 2017 12:21:02 +0100
Subject: [PATCH 1/3] Upgrade QtWaylandCompositor API to Qt5.8 and removes some
 unused/untested code

---
 README                                        |   1 +
 plugin/lipstickplugin.cpp                     |   4 -
 plugin/plugin.pro                             |   2 +-
 protocol/alien-manager.xml                    | 218 ------
 protocol/lipstick-recorder.xml                | 135 ----
 src/compositor/alienmanager/alienmanager.cpp  | 114 ---
 src/compositor/alienmanager/alienmanager.h    |  72 --
 src/compositor/alienmanager/alienmanager.pri  |  13 -
 src/compositor/alienmanager/aliensurface.cpp  | 156 ----
 src/compositor/alienmanager/aliensurface.h    |  54 --
 src/compositor/compositor.pri                 |  15 +-
 src/compositor/hwcimage.cpp                   |  11 +-
 src/compositor/hwcrenderstage.cpp             |   4 +-
 src/compositor/hwcrenderstage.h               |   3 +-
 src/compositor/lipstickcompositor.cpp         | 354 ++++-----
 src/compositor/lipstickcompositor.h           |  65 +-
 .../lipstickcompositorprocwindow.cpp          |   2 +-
 src/compositor/lipstickcompositorwindow.cpp   | 225 +++---
 src/compositor/lipstickcompositorwindow.h     |  36 +-
 src/compositor/lipstickkeymap.cpp             |  82 --
 src/compositor/lipstickkeymap.h               |  74 --
 src/compositor/lipstickrecorder.cpp           | 195 -----
 src/compositor/lipstickrecorder.h             |  78 --
 src/compositor/lipsticksurfaceinterface.cpp   |  22 -
 src/compositor/lipsticksurfaceinterface.h     |  35 -
 src/compositor/windowmodel.cpp                |   7 +-
 src/compositor/windowpixmapitem.cpp           | 728 +-----------------
 src/compositor/windowpixmapitem.h             |  79 +-
 src/compositor/windowproperty.cpp             | 120 ---
 src/compositor/windowproperty.h               |  60 --
 src/homeapplication.cpp                       |  15 +-
 src/homewindow.cpp                            |   2 +-
 src/notifications/lipsticknotification.cpp    |   1 +
 .../notificationfeedbackplayer.cpp            |   7 +-
 src/notifications/notificationmanager.cpp     |   2 +-
 .../notificationpreviewpresenter.cpp          |   7 +-
 src/screenshotservice.cpp                     |   4 +-
 src/src.pro                                   |   1 -
 .../ut_notificationfeedbackplayer.pro         |   2 +-
 .../ut_notificationpreviewpresenter.pro       |  16 +-
 tools/simple-compositor/main.cpp              |  10 -
 tools/simple-compositor/simple-compositor.pro |  28 -
 tools/simple-compositor/simplecompositor.qml  |  58 --
 tools/tools.pro                               |   4 +-
 44 files changed, 385 insertions(+), 2736 deletions(-)
 delete mode 100644 protocol/alien-manager.xml
 delete mode 100644 protocol/lipstick-recorder.xml
 delete mode 100644 src/compositor/alienmanager/alienmanager.cpp
 delete mode 100644 src/compositor/alienmanager/alienmanager.h
 delete mode 100644 src/compositor/alienmanager/alienmanager.pri
 delete mode 100644 src/compositor/alienmanager/aliensurface.cpp
 delete mode 100644 src/compositor/alienmanager/aliensurface.h
 delete mode 100644 src/compositor/lipstickkeymap.cpp
 delete mode 100644 src/compositor/lipstickkeymap.h
 delete mode 100644 src/compositor/lipstickrecorder.cpp
 delete mode 100644 src/compositor/lipstickrecorder.h
 delete mode 100644 src/compositor/lipsticksurfaceinterface.cpp
 delete mode 100644 src/compositor/lipsticksurfaceinterface.h
 delete mode 100644 src/compositor/windowproperty.cpp
 delete mode 100644 src/compositor/windowproperty.h
 delete mode 100644 tools/simple-compositor/main.cpp
 delete mode 100644 tools/simple-compositor/simple-compositor.pro
 delete mode 100644 tools/simple-compositor/simplecompositor.qml

diff --git a/README b/README
index 2775b7ab..8952e973 100644
--- a/README
+++ b/README
@@ -26,6 +26,7 @@ Tom Swindell - initial work on a pretty UX
 Vesa Halttunen - various functionality additions, guidance, working it towards a product
 Aaron Kennedy - work on Wayland port
 Mikko Harju - work on Wayland issues/port
+Florent Revest - upgraded to QtWaylandCompositor 5.8 APIs
 
 ... and many others. If you feel like you belong here, you probably do. Submit a
 pull request.
diff --git a/plugin/lipstickplugin.cpp b/plugin/lipstickplugin.cpp
index 9f93deba..b14e0b1f 100644
--- a/plugin/lipstickplugin.cpp
+++ b/plugin/lipstickplugin.cpp
@@ -26,12 +26,10 @@
 #include <volume/volumecontrol.h>
 #include <usbmodeselector.h>
 #include <shutdownscreen.h>
-#include <compositor/lipstickkeymap.h>
 #include <compositor/lipstickcompositor.h>
 #include <compositor/lipstickcompositorwindow.h>
 #include <compositor/windowmodel.h>
 #include <compositor/windowpixmapitem.h>
-#include <compositor/windowproperty.h>
 #include <lipstickapi.h>
 #include <hwcimage.h>
 
@@ -64,12 +62,10 @@ void LipstickPlugin::registerTypes(const char *uri)
     qmlRegisterUncreatableType<USBModeSelector>("org.nemomobile.lipstick", 0, 1, "USBModeSelector", "This type is initialized by HomeApplication");
     qmlRegisterUncreatableType<ShutdownScreen>("org.nemomobile.lipstick", 0, 1, "ShutdownScreen", "This type is initialized by HomeApplication");
 
-    qmlRegisterType<LipstickKeymap>("org.nemomobile.lipstick", 0, 1, "Keymap");
     qmlRegisterType<LipstickCompositor>("org.nemomobile.lipstick", 0, 1, "Compositor");
     qmlRegisterUncreatableType<QWaylandSurface>("org.nemomobile.lipstick", 0, 1, "WaylandSurface", "This type is created by the compositor");
     qmlRegisterType<WindowModel>("org.nemomobile.lipstick", 0, 1, "WindowModel");
     qmlRegisterType<WindowPixmapItem>("org.nemomobile.lipstick", 0, 1, "WindowPixmapItem");
-    qmlRegisterType<WindowProperty>("org.nemomobile.lipstick", 0, 1, "WindowProperty");
     qmlRegisterSingletonType<LipstickApi>("org.nemomobile.lipstick", 0, 1, "Lipstick", lipstickApi_callback);
 
     qmlRegisterType<LipstickCompositorWindow>();
diff --git a/plugin/plugin.pro b/plugin/plugin.pro
index 16c1821e..8ebae72e 100644
--- a/plugin/plugin.pro
+++ b/plugin/plugin.pro
@@ -3,7 +3,7 @@ TARGET = lipstickplugin
 VERSION = 0.1
 
 CONFIG += qt plugin link_pkgconfig
-QT += core gui qml quick compositor dbus
+QT += core gui qml quick waylandcompositor dbus
 PKGCONFIG += mlite5 dsme_dbus_if thermalmanager_dbus_if usb-moded-qt5
 
 INSTALLS = target qmldirfile
diff --git a/protocol/alien-manager.xml b/protocol/alien-manager.xml
deleted file mode 100644
index 93f99c5e..00000000
--- a/protocol/alien-manager.xml
+++ /dev/null
@@ -1,218 +0,0 @@
-<protocol name="alien_manager">
-    <copyright>
-        Copyright (C) 2014 Jolla Ltd.
-
-        Permission to use, copy, modify, distribute, and sell this
-        software and its documentation for any purpose is hereby granted
-        without fee, provided that the above copyright notice appear in
-        all copies and that both that copyright notice and this permission
-        notice appear in supporting documentation, and that the name of
-        the copyright holders not be used in advertising or publicity
-        pertaining to distribution of the software without specific,
-        written prior permission.  The copyright holders make no
-        representations about the suitability of this software for any
-        purpose.  It is provided "as is" without express or implied
-        warranty.
-
-        THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
-        SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-        FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
-        SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-        WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
-        AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
-        ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
-        THIS SOFTWARE.
-    </copyright>
-
-    <interface name="alien_manager" version="1">
-        <description summary="manager interface for alien clients">
-            This global interface is used by alien clients to integrate
-            with the shell.
-        </description>
-
-        <request name="destroy" type="destructor">
-            <description summary="destroy the manager">
-                Destroy this alien_manager. All its alien_client children
-                are inactive and should be destroyed by the client.
-            </description>
-        </request>
-
-        <request name="create_alien_client">
-            <description summary="create a new alien_client handle">
-                This request creates a new alien_client. For each
-                alien_client there should be a real alien application
-                associated with it.
-                The package parameter should be the android package of
-                the external application.
-            </description>
-            <arg name="id" type="new_id" interface="alien_client"/>
-            <arg name="package" type="string"/>
-        </request>
-
-        <request name="pong">
-            <description summary="respond to a ping event">
-                A client must respond to a ping event with a pong request or
-                the client may be deemed unresponsive.
-            </description>
-            <arg name="serial" type="uint"/>
-        </request>
-
-        <event name="ping">
-            <description summary="ping client">
-                A client must respond to a ping event with a pong request or
-                the client may be deemed unresponsive.
-            </description>
-            <arg name="serial" type="uint"/>
-        </event>
-    </interface>
-
-    <interface name="alien_client" version="1">
-        <description summary="alien client metadata interface">
-            Interface used to associate one or more wl_surfaces with an
-            external alien application.
-        </description>
-
-        <request name="destroy" type="destructor">
-            <description summary="destroy this alien_client">
-                Destroy this alien_client. All its alien_surface children
-                are unmapped and become inactive and should be destroyed
-                by the client.
-            </description>
-        </request>
-
-        <request name="get_alien_surface">
-            <description summary="create a new alien_surface">
-                Extend 'surface' with the alien_surface role.
-
-                If the surface has a role already a protocol error will
-                be raised.
-            </description>
-            <arg name="id" type="new_id" interface="alien_surface"/>
-            <arg name="surface" type="object" interface="wl_surface"/>
-        </request>
-
-        <event name="oom_score">
-            <description summary="the oom score for the client">
-                After receiving this event the client should set the
-                oom score for the real application to the given value.
-            </description>
-            <arg name="score" type="int"/>
-        </event>
-    </interface>
-
-    <interface name="alien_surface" version="1">
-        <description summary="main window interface for alien clients">
-            This interface extends a basic wl_surface with additional metadata
-            needed to map it on screen.
-
-            If its wl_surface is destroyed, an alien_surface becomes inactive
-            but will not be automatically destroyed.
-        </description>
-
-        <request name="destroy" type="destructor">
-            <description summary="delete surface">
-                Deletes the surface and invalidates its object ID.
-
-                The wl_surface loses its role, and all the associated properties.
-                The surface is unmapped.
-            </description>
-        </request>
-
-        <request name="set_title">
-            <description summary="set surface title">
-                Set a short title for the surface.
-
-                This string may be used to identify the surface in a task bar,
-                window list, or other user interface elements provided by the
-                compositor.
-
-                The string must be encoded in UTF-8.
-            </description>
-            <arg name="title" type="string"/>
-        </request>
-
-        <enum name="state">
-            <description summary="types of state on the surface">
-                The different state values used on the surface. They are paired with
-                the configure event to ensure that both the client and the compositor
-                setting the state can be synchronized.
-
-                States set in this way are double-buffered. They will get applied on
-                the next commit.
-            </description>
-            <entry name="hidden" value="1" summary="the surface is not visible">
-                The surface is hidden, it should stop drawing and free memory
-                if possible.
-            </entry>
-            <entry name="cover" value="2" summary="the surface is used as a cover">
-                The surface is being used as a non-fullscreen cover, and cannot
-                receive input.
-            </entry>
-        </enum>
-
-        <event name="configure">
-            <description summary="suggest a surface change">
-                The configure event asks the client to resize its surface.
-
-                The width and height arguments specify a hint to the window
-                about how its surface should be resized in surface local
-                coordinates. The states listed in the event specify additional
-                information about the surface.
-
-                A client should send an ack_configure request with the serial
-                sent in this configure event before attaching a new buffer.
-
-                If the client receives multiple configure events before it
-                can respond to one, it is free to discard all but the last
-                event it received.
-            </description>
-            <arg name="width" type="uint"/>
-            <arg name="height" type="uint"/>
-            <arg name="states" type="array"/>
-            <arg name="serial" type="uint"/>
-        </event>
-
-        <request name="ack_configure">
-            <description summary="ack a configure event">
-                When a configure event is received, a client should then ack it
-                using the ack_configure request to ensure that the compositor
-                knows the client has seen the event.
-
-                By this point, the state is confirmed, and the next attach should
-                contain the buffer drawn for the configure event you are acking.
-            </description>
-            <arg name="serial" type="uint"/>
-        </request>
-
-        <request name="request_state">
-            <description summary="request a surface change">
-                Ask the compositor to send a configure event with the
-                requested states. The compositor is free to ignore the
-                request, or to send a different states value than the
-                one requested.
-                The value of the 'serial' argument should be the last serial
-                the client received in an event.
-            </description>
-            <arg name="states" type="array"/>
-            <arg name="serial" type="uint" summary="serial for focus stealing prevenction"/>
-        </request>
-
-        <request name="set_minimized">
-            <description summary="ask the server to minimize the surface">
-                By calling this request the client asks the compositor to minimize
-                this surface. The actual behavior is compositor specific, the client
-                should not assume this surface is going to be unmapped.
-            </description>
-        </request>
-
-        <event name="close">
-            <description summary="request to close this surface">
-                This event requests the client to destroy this surface. The client is
-                free to choose if it wants to quit or to just destroy this surface and
-                keep running, however if the client ignores the request or takes too
-                much time to destroy the surface the server may decide to forcefully
-                kill it.
-            </description>
-        </event>
-    </interface>
-</protocol>
diff --git a/protocol/lipstick-recorder.xml b/protocol/lipstick-recorder.xml
deleted file mode 100644
index 978be51d..00000000
--- a/protocol/lipstick-recorder.xml
+++ /dev/null
@@ -1,135 +0,0 @@
-<protocol name="lipstick_recorder">
-    <copyright>
-        Copyright (C) 2014 Jolla Ltd.
-
-        Permission to use, copy, modify, distribute, and sell this
-        software and its documentation for any purpose is hereby granted
-        without fee, provided that the above copyright notice appear in
-        all copies and that both that copyright notice and this permission
-        notice appear in supporting documentation, and that the name of
-        the copyright holders not be used in advertising or publicity
-        pertaining to distribution of the software without specific,
-        written prior permission.  The copyright holders make no
-        representations about the suitability of this software for any
-        purpose.  It is provided "as is" without express or implied
-        warranty.
-
-        THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
-        SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-        FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
-        SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-        WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
-        AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
-        ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
-        THIS SOFTWARE.
-    </copyright>
-
-    <interface name="lipstick_recorder_manager" version="1">
-        <request name="create_recorder">
-            <description summary="create a recorder object">
-                Create a recorder object for the specified output.
-            </description>
-            <arg name="recorder" type="new_id" interface="lipstick_recorder"/>
-            <arg name="output" type="object" interface="wl_output"/>
-        </request>
-    </interface>
-
-    <interface name="lipstick_recorder" version="1">
-        <request name="destroy" type="destructor">
-            <description summary="destroy the recorder object">
-                Destroy the recorder object, discarding any frame request
-                that may be pending.
-            </description>
-        </request>
-        <request name="record_frame">
-            <description summary="request a frame to be recorded">
-                Ask the compositor to record its next frame, putting
-                the content into the specified buffer data. The frame
-                event will be sent when the frame is recorded.
-                Only one frame will be recorded, the client will have
-                to call this again after the frame event if it wants to
-                record more frames.
-
-                The buffer must be a shm buffer, trying to use another
-                type of buffer will result in failure to capture the
-                frame and the failed event will be sent.
-            </description>
-            <arg name="buffer" type="object" interface="wl_buffer"/>
-        </request>
-
-        <request name="repaint">
-            <description summary="request the compositor to repaint asap">
-                Calling record_frame will not cause the compositor to
-                repaint, but it will wait instead for the first frame
-                the compositor draws due to some other external event
-                or internal change.
-                Calling this request after calling record_frame will
-                ask the compositor to redraw as soon at possible even
-                if it wouldn't otherwise.
-                If no frame was requested this request has no effect.
-            </description>
-        </request>
-
-        <enum name="result">
-            <entry name="bad_buffer" value="2"/>
-        </enum>
-
-        <enum name="transform">
-            <entry name="normal" value="1"/>
-            <entry name="y_inverted" value="2"/>
-        </enum>
-
-        <event name="setup">
-            <description summary="notify the requirements for the frame buffers">
-                This event will be sent immediately after creation of the
-                lipstick_recorder object. The wl_buffers the client passes
-                to the frame request must be big enough to store an image
-                with the given width, height and format.
-                If they are not the compositor will send the failed event.
-                If this event is sent again later in the lifetime of the object
-                the pending frames will be cancelled.
-
-                The format will be one of the values as defined in the
-                wl_shm::format enum.
-            </description>
-            <arg name="width" type="int" description="width of the frame, in pixels"/>
-            <arg name="height" type="int" description="height of the frame, in pixels"/>
-            <arg name="stride" type="int" description="stride of the frame"/>
-            <arg name="format" type="int" desciption="format of the frame"/>
-        </event>
-
-        <event name="frame">
-            <description summary="notify a frame was recorded, or an error">
-                The compositor will send this event after a frame was
-                recorded, or in case an error happened. The client can
-                call record_frame again to record the next frame.
-
-                'time' is the time the compositor recorded that frame,
-                in milliseconds, with an unspecified base.
-            </description>
-            <arg name="buffer" type="object" interface="wl_buffer"/>
-            <arg name="time" type="uint"/>
-            <arg name="transform" type="int"/>
-        </event>
-
-        <event name="failed">
-            <description summary="the frame capture failed">
-                The value of the 'result' argument will be one of the
-                values of the 'result' enum.
-            </description>
-            <arg name="result" type="int"/>
-            <arg name="buffer" type="object" interface="wl_buffer"/>
-        </event>
-
-        <event name="cancelled">
-            <description summary="notify a request was cancelled">
-                The compositor will send this event if the client calls
-                request_frame more than one time for the same compositor
-                frame. The cancel event will be sent carrying the old
-                buffer, and the frame will be recorded using the newest
-                buffer.
-            </description>
-            <arg name="buffer" type="object" interface="wl_buffer"/>
-        </event>
-    </interface>
-</protocol>
diff --git a/src/compositor/alienmanager/alienmanager.cpp b/src/compositor/alienmanager/alienmanager.cpp
deleted file mode 100644
index 1a178beb..00000000
--- a/src/compositor/alienmanager/alienmanager.cpp
+++ /dev/null
@@ -1,114 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2014 Jolla Ltd.
-** Contact: Giulio Camuffo <giulio.camuffo@jollamobile.com>
-**
-** This file is part of lipstick.
-**
-** This library is free software; you can redistribute it and/or
-** modify it under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation
-** and appearing in the file LICENSE.LGPL included in the packaging
-** of this file.
-**
-****************************************************************************/
-
-#include <QtCompositor/QWaylandSurface>
-
-#include "alienmanager.h"
-#include "aliensurface.h"
-
-AlienManagerGlobal::AlienManagerGlobal(QObject *parent)
-                  : QObject(parent)
-{
-
-}
-
-const wl_interface *AlienManagerGlobal::interface() const
-{
-    return &alien_manager_interface;
-}
-
-void AlienManagerGlobal::bind(wl_client *client, uint32_t version, uint32_t id)
-{
-    new AlienManager(client, version, id, this);
-}
-
-
-
-AlienManager::AlienManager(wl_client *client, uint32_t version, uint32_t id, QObject *parent)
-            : QObject(parent)
-            , QtWaylandServer::alien_manager(client, id, version)
-{
-}
-
-AlienManager::~AlienManager()
-{
-    wl_resource_set_implementation(resource()->handle, nullptr, nullptr, nullptr);
-}
-
-void AlienManager::ping(uint32_t serial, QWaylandSurface *surface)
-{
-    m_pings.insert(serial, surface);
-    send_ping(serial);
-}
-
-void AlienManager::alien_manager_destroy_resource(Resource *resource)
-{
-    Q_UNUSED(resource)
-    delete this;
-}
-
-void AlienManager::alien_manager_destroy(Resource *resource)
-{
-    wl_resource_destroy(resource->handle);
-}
-
-void AlienManager::alien_manager_create_alien_client(Resource *resource, uint32_t id, const QString &package)
-{
-    new AlienClient(this, resource->client(), wl_resource_get_version(resource->handle), id, package);
-}
-
-void AlienManager::alien_manager_pong(Resource *resource, uint32_t serial)
-{
-    Q_UNUSED(resource)
-    QWaylandSurface *surf = m_pings.value(serial);
-    if (surf)
-        surf->pong();
-}
-
-
-AlienClient::AlienClient(AlienManager *mgr, wl_client *client, uint32_t version, uint32_t id, const QString &package)
-           : QObject(mgr)
-           , QtWaylandServer::alien_client(client, id, version)
-           , m_package(package)
-           , m_manager(mgr)
-{
-}
-
-AlienClient::~AlienClient()
-{
-    wl_resource_set_implementation(resource()->handle, nullptr, nullptr, nullptr);
-}
-
-AlienManager *AlienClient::manager() const
-{
-    return m_manager;
-}
-
-void AlienClient::alien_client_destroy_resource(Resource *resource)
-{
-    Q_UNUSED(resource)
-    delete this;
-}
-
-void AlienClient::alien_client_destroy(Resource *resource)
-{
-    wl_resource_destroy(resource->handle);
-}
-
-void AlienClient::alien_client_get_alien_surface(Resource *resource, uint32_t id, ::wl_resource *surface)
-{
-    QWaylandSurface *surf = QWaylandSurface::fromResource(surface);
-    new AlienSurface(this, surf, wl_resource_get_version(resource->handle), id, m_package);
-}
diff --git a/src/compositor/alienmanager/alienmanager.h b/src/compositor/alienmanager/alienmanager.h
deleted file mode 100644
index b2b22ef5..00000000
--- a/src/compositor/alienmanager/alienmanager.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2014 Jolla Ltd.
-** Contact: Giulio Camuffo <giulio.camuffo@jollamobile.com>
-**
-** This file is part of lipstick.
-**
-** This library is free software; you can redistribute it and/or
-** modify it under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation
-** and appearing in the file LICENSE.LGPL included in the packaging
-** of this file.
-**
-****************************************************************************/
-
-#ifndef ALIENMANAGER_H
-#define ALIENMANAGER_H
-
-#include <QObject>
-#include <QtCompositor/qwaylandglobalinterface.h>
-
-#include "qwayland-server-alien-manager.h"
-
-class AlienClient;
-class AlienSurface;
-
-class AlienManagerGlobal : public QObject, public QWaylandGlobalInterface
-{
-public:
-    explicit AlienManagerGlobal(QObject *parent = nullptr);
-
-    const wl_interface *interface() const Q_DECL_OVERRIDE;
-    void bind(wl_client *client, uint32_t version, uint32_t id) Q_DECL_OVERRIDE;
-};
-
-class AlienManager : public QObject, public QtWaylandServer::alien_manager
-{
-public:
-    AlienManager(wl_client *client, uint32_t version, uint32_t id, QObject *parent);
-    ~AlienManager();
-
-    void ping(uint32_t serial, QWaylandSurface *surface);
-
-protected:
-    void alien_manager_destroy_resource(Resource *resource) Q_DECL_OVERRIDE;
-    void alien_manager_destroy(Resource *resource) Q_DECL_OVERRIDE;
-    void alien_manager_create_alien_client(Resource *resource, uint32_t id, const QString &package) Q_DECL_OVERRIDE;
-    void alien_manager_pong(Resource *resource, uint32_t serial) Q_DECL_OVERRIDE;
-
-private:
-    QMap<uint32_t, QWaylandSurface *> m_pings;
-};
-
-class AlienClient : public QObject, public QtWaylandServer::alien_client
-{
-public:
-    AlienClient(AlienManager *mgr, wl_client *client, uint32_t version, uint32_t id, const QString &package);
-    ~AlienClient();
-
-    AlienManager *manager() const;
-
-protected:
-    void alien_client_destroy_resource(Resource *resource) Q_DECL_OVERRIDE;
-    void alien_client_destroy(Resource *resource) Q_DECL_OVERRIDE;
-    void alien_client_get_alien_surface(Resource *resource, uint32_t id, ::wl_resource *surface) Q_DECL_OVERRIDE;
-
-private:
-    QString m_package;
-    AlienManager *m_manager;
-};
-
-#endif
diff --git a/src/compositor/alienmanager/alienmanager.pri b/src/compositor/alienmanager/alienmanager.pri
deleted file mode 100644
index 6c05d409..00000000
--- a/src/compositor/alienmanager/alienmanager.pri
+++ /dev/null
@@ -1,13 +0,0 @@
-INCLUDEPATH += $$PWD
-
-HEADERS += \
-    $$PWD/alienmanager.h \
-    $$PWD/aliensurface.h \
-
-SOURCES += \
-    $$PWD/alienmanager.cpp \
-    $$PWD/aliensurface.cpp \
-
-WAYLANDSERVERSOURCES += ../protocol/alien-manager.xml \
-
-QT += compositor
diff --git a/src/compositor/alienmanager/aliensurface.cpp b/src/compositor/alienmanager/aliensurface.cpp
deleted file mode 100644
index 7f9a38fc..00000000
--- a/src/compositor/alienmanager/aliensurface.cpp
+++ /dev/null
@@ -1,156 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2014 Jolla Ltd.
-** Contact: Giulio Camuffo <giulio.camuffo@jollamobile.com>
-**
-** This file is part of lipstick.
-**
-** This library is free software; you can redistribute it and/or
-** modify it under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation
-** and appearing in the file LICENSE.LGPL included in the packaging
-** of this file.
-**
-****************************************************************************/
-
-#include <QtCompositor/QWaylandSurface>
-
-#include "lipstickcompositor.h"
-#include "aliensurface.h"
-#include "alienmanager.h"
-#include "lipsticksurfaceinterface.h"
-
-AlienSurface::AlienSurface(AlienClient *client, QWaylandSurface *surface, uint32_t version, uint32_t id, const QString &package)
-            : QObject(client)
-            , QWaylandSurfaceInterface(surface)
-            , QtWaylandServer::alien_surface(reinterpret_cast<wl_client *>(surface->client()), id, version)
-            , m_client(client)
-            , m_hidden(false)
-            , m_coverized(false)
-            , m_lastSize(0, 0)
-            , m_serial(0)
-            , m_lastSerial(0)
-{
-    LipstickCompositor *compositor = LipstickCompositor::instance();
-    sendConfigure(compositor->width(), compositor->height());
-    connect(surface, &QWaylandSurface::configure, this, &AlienSurface::configure);
-    setSurfaceType(QWaylandSurface::Toplevel);
-    setSurfaceClassName(package);
-    surface->setProperty("alienSurface", true);
-}
-
-AlienSurface::~AlienSurface()
-{
-    wl_resource_set_implementation(resource()->handle, nullptr, nullptr, nullptr);
-    surface()->setMapped(false);
-}
-
-bool AlienSurface::runOperation(QWaylandSurfaceOp *op)
-{
-    switch (op->type()) {
-        case QWaylandSurfaceOp::Close:
-            send_close();
-            return true;
-        case QWaylandSurfaceOp::SetVisibility: {
-            QWindow::Visibility v = static_cast<QWaylandSurfaceSetVisibilityOp *>(op)->visibility();
-            m_hidden = v == QWindow::Hidden;
-            m_coverized = v == QWindow::Minimized;
-            updateStates();
-            return true;
-        }
-        case QWaylandSurfaceOp::Ping:
-            m_client->manager()->ping(static_cast<QWaylandSurfacePingOp *>(op)->serial(), surface());
-            return true;
-        case QWaylandSurfaceOp::Resize: {
-            QSize s = static_cast<QWaylandSurfaceResizeOp *>(op)->size();
-            sendConfigure(s.width(), s.height());
-            return true;
-        }
-        case LipstickOomScoreOp::Type:
-            m_client->send_oom_score(static_cast<LipstickOomScoreOp *>(op)->score());
-            return true;
-        default:
-            break;
-    }
-    return false;
-}
-
-void AlienSurface::alien_surface_destroy_resource(Resource *resource)
-{
-    Q_UNUSED(resource)
-    delete this;
-}
-
-void AlienSurface::alien_surface_destroy(Resource *resource)
-{
-    wl_resource_destroy(resource->handle);
-}
-
-void AlienSurface::alien_surface_set_title(Resource *resource, const QString &title)
-{
-    Q_UNUSED(resource)
-    setSurfaceTitle(title);
-}
-
-void AlienSurface::alien_surface_ack_configure(Resource *resource, uint32_t serial)
-{
-    Q_UNUSED(resource);
-    if (serial == m_serial) {
-        m_serial = 0;
-    }
-}
-
-void AlienSurface::alien_surface_request_state(Resource *resource, wl_array *array, uint32_t serial)
-{
-    Q_UNUSED(resource);
-    bool wasHiddenOrCover = m_hidden | m_coverized;
-    m_hidden = false;
-
-    for (uint32_t *ptr = (uint32_t *)array->data; (char *)ptr < (char *)array->data + array->size; ++ptr) {
-        if (*ptr == ALIEN_SURFACE_STATE_HIDDEN) {
-            m_hidden = true;
-        }
-    }
-    // do some focus stealing prevenction
-    if (wasHiddenOrCover && !m_hidden && serial == m_lastSerial) {
-        emit surface()->raiseRequested();
-    } else {
-        updateStates();
-    }
-}
-
-void AlienSurface::alien_surface_set_minimized(Resource *resource)
-{
-    Q_UNUSED(resource)
-    emit surface()->lowerRequested();
-}
-
-void AlienSurface::configure(bool hasBuffer)
-{
-    if (hasBuffer && m_serial == 0) {
-        m_lastSize = surface()->size();
-    }
-    surface()->setMapped(hasBuffer);
-}
-
-void AlienSurface::sendConfigure(int w, int h)
-{
-    QVector<uint32_t> states;
-    if (m_hidden) {
-        states << ALIEN_SURFACE_STATE_HIDDEN;
-    }
-    if (m_coverized) {
-        states << ALIEN_SURFACE_STATE_COVER;
-    }
-    QByteArray data = QByteArray::fromRawData((char *)states.data(), states.size() * sizeof(uint32_t));
-    m_serial = wl_display_next_serial(surface()->compositor()->waylandDisplay());
-    m_lastSerial = m_serial;
-
-    send_configure(w, h, data, m_serial);
-    m_lastSize = QSize(w, h);
-}
-
-void AlienSurface::updateStates()
-{
-    sendConfigure(m_lastSize.width(), m_lastSize.height());
-}
diff --git a/src/compositor/alienmanager/aliensurface.h b/src/compositor/alienmanager/aliensurface.h
deleted file mode 100644
index d8476602..00000000
--- a/src/compositor/alienmanager/aliensurface.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2014 Jolla Ltd.
-** Contact: Giulio Camuffo <giulio.camuffo@jollamobile.com>
-**
-** This file is part of lipstick.
-**
-** This library is free software; you can redistribute it and/or
-** modify it under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation
-** and appearing in the file LICENSE.LGPL included in the packaging
-** of this file.
-**
-****************************************************************************/
-
-#ifndef ALIENSURFACE_H
-#define ALIENSURFACE_H
-
-#include <QWaylandSurfaceInterface>
-
-#include "qwayland-server-alien-manager.h"
-
-class AlienClient;
-
-class AlienSurface : public QObject,  public QWaylandSurfaceInterface, public QtWaylandServer::alien_surface
-{
-public:
-    AlienSurface(AlienClient *client, QWaylandSurface *surface, uint32_t version, uint32_t id, const QString &package);
-    ~AlienSurface();
-
-protected:
-    bool runOperation(QWaylandSurfaceOp *op) Q_DECL_OVERRIDE;
-
-    void alien_surface_destroy_resource(Resource *resource) Q_DECL_OVERRIDE;
-    void alien_surface_destroy(Resource *resource) Q_DECL_OVERRIDE;
-    void alien_surface_set_title(Resource *resource, const QString &title) Q_DECL_OVERRIDE;
-    void alien_surface_ack_configure(Resource *resource, uint32_t serial) Q_DECL_OVERRIDE;
-    void alien_surface_request_state(Resource *resource, wl_array *states, uint32_t serial) Q_DECL_OVERRIDE;
-    void alien_surface_set_minimized(Resource *resource) Q_DECL_OVERRIDE;
-
-private:
-    void configure(bool hasBuffer);
-    void sendConfigure(int width, int height);
-    void updateStates();
-
-    AlienClient *m_client;
-    bool m_hidden;
-    bool m_coverized;
-    QSize m_lastSize;
-    uint32_t m_serial;
-    uint32_t m_lastSerial;
-};
-
-#endif
diff --git a/src/compositor/compositor.pri b/src/compositor/compositor.pri
index 26c7e28e..44d6a224 100644
--- a/src/compositor/compositor.pri
+++ b/src/compositor/compositor.pri
@@ -7,13 +7,10 @@ PUBLICHEADERS += \
     $$PWD/lipstickcompositorwindow.h \
     $$PWD/lipstickcompositorprocwindow.h \
     $$PWD/lipstickcompositoradaptor.h \
-    $$PWD/lipstickkeymap.h \
     $$PWD/windowmodel.h \
-    $$PWD/lipsticksurfaceinterface.h \
 
 HEADERS += \
     $$PWD/windowpixmapitem.h \
-    $$PWD/windowproperty.h \
     $$PWD/lipstickrecorder.h \
     $$PWD/hwcrenderstage.h \
     $$PWD/hwcimage.h \
@@ -23,22 +20,14 @@ SOURCES += \
     $$PWD/lipstickcompositorwindow.cpp \
     $$PWD/lipstickcompositorprocwindow.cpp \
     $$PWD/lipstickcompositoradaptor.cpp \
-    $$PWD/lipstickkeymap.cpp \
     $$PWD/windowmodel.cpp \
     $$PWD/windowpixmapitem.cpp \
-    $$PWD/windowproperty.cpp \
-    $$PWD/lipsticksurfaceinterface.cpp \
-    $$PWD/lipstickrecorder.cpp \
     $$PWD/hwcrenderstage.cpp \
     $$PWD/hwcimage.cpp \
 
 DEFINES += QT_COMPOSITOR_QUICK
 
-QT += compositor
+QT += waylandcompositor
 
 # needed for hardware compositor
-QT += quick-private gui-private core-private compositor-private qml-private
-
-WAYLANDSERVERSOURCES += ../protocol/lipstick-recorder.xml \
-
-OTHER_FILES += $$PWD/compositor.xml
+QT += quick-private gui-private core-private waylandcompositor-private qml-private
diff --git a/src/compositor/hwcimage.cpp b/src/compositor/hwcimage.cpp
index 25ee330f..6b1bf296 100644
--- a/src/compositor/hwcimage.cpp
+++ b/src/compositor/hwcimage.cpp
@@ -18,6 +18,7 @@
 
 #include <QRunnable>
 #include <QThreadPool>
+#include <QCoreApplication>
 
 #include <QQuickWindow>
 #include <QSGSimpleTextureNode>
@@ -28,6 +29,8 @@
 #include <EGL/egl.h>
 #include <EGL/eglext.h>
 
+#include <math.h>
+
 static bool hwcimage_is_enabled();
 
 #define HWCIMAGE_LOAD_EVENT ((QEvent::Type) (QEvent::User + 1))
@@ -536,12 +539,12 @@ extern "C" {
     typedef EGLBoolean (EGLAPIENTRYP _eglHybrisReleaseNativeBuffer)(EGLClientBuffer buffer);
     typedef EGLBoolean (EGLAPIENTRYP _eglHybrisNativeBufferHandle)(EGLDisplay dpy, EGLClientBuffer buffer, void **handle);
 
-    typedef void (EGLAPIENTRYP _glEGLImageTargetTexture2DOES)(GLenum target, EGLImageKHR image);
+    typedef void (EGLAPIENTRYP _glEGLImageTargetTexture2DOESlipstick)(GLenum target, EGLImageKHR image);
     typedef EGLImageKHR (EGLAPIENTRYP _eglCreateImageKHR)(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint *attribs);
     typedef EGLBoolean (EGLAPIENTRYP _eglDestroyImageKHR)(EGLDisplay dpy, EGLImageKHR image);
 }
 
-static _glEGLImageTargetTexture2DOES glEGLImageTargetTexture2DOES = 0;
+static _glEGLImageTargetTexture2DOESlipstick glEGLImageTargetTexture2DOESlipstick = 0;
 static _eglCreateImageKHR eglCreateImageKHR = 0;
 static _eglDestroyImageKHR eglDestroyImageKHR = 0;
 
@@ -558,7 +561,7 @@ static void hwcimage_initialize()
         return;
     initialized = true;
 
-    glEGLImageTargetTexture2DOES = (_glEGLImageTargetTexture2DOES) eglGetProcAddress("glEGLImageTargetTexture2DOES");
+    glEGLImageTargetTexture2DOESlipstick = (_glEGLImageTargetTexture2DOESlipstick) eglGetProcAddress("glEGLImageTargetTexture2DOES");
     eglCreateImageKHR = (_eglCreateImageKHR) eglGetProcAddress("eglCreateImageKHR");
     eglDestroyImageKHR = (_eglDestroyImageKHR) eglGetProcAddress("eglDestroyImageKHR");
     eglHybrisCreateNativeBuffer = (_eglHybrisCreateNativeBuffer) eglGetProcAddress("eglHybrisCreateNativeBuffer");
@@ -661,7 +664,7 @@ void HwcImageTexture::bind()
     updateBindOptions(!m_bound);
     if (!m_bound) {
         m_bound = true;
-        glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, m_image);
+        glEGLImageTargetTexture2DOESlipstick(GL_TEXTURE_2D, m_image);
     }
 }
 
diff --git a/src/compositor/hwcrenderstage.cpp b/src/compositor/hwcrenderstage.cpp
index 5234600b..376df2f7 100644
--- a/src/compositor/hwcrenderstage.cpp
+++ b/src/compositor/hwcrenderstage.cpp
@@ -136,7 +136,7 @@ void HwcRenderStage::initialize(LipstickCompositor *lipstick)
         return;
     }
     Q_ASSERT(compositor);
-    QQuickWindowPrivate::get(lipstick)->customRenderStage = new HwcRenderStage(lipstick, compositor);
+    QQuickWindowPrivate::get(lipstick->quickWindow())->customRenderStage = new HwcRenderStage(lipstick, compositor);
     qDebug() << "Hardware Compositor support is enabled";
     m_hwcEnabled = true;
 }
@@ -194,7 +194,7 @@ static void hwc_renderstage_dump_layerlist(HwcInterface::LayerList *list)
 
 HwcRenderStage::HwcRenderStage(LipstickCompositor *lipstick, void *compositorHandle)
     : m_lipstick(lipstick)
-    , m_window(lipstick)
+    , m_window(lipstick->quickWindow())
     , m_hwc(reinterpret_cast<HwcInterface::Compositor *>(compositorHandle))
     , m_hwcBypass(0)
     , m_invalidated(0)
diff --git a/src/compositor/hwcrenderstage.h b/src/compositor/hwcrenderstage.h
index e535f81b..cbd1f090 100644
--- a/src/compositor/hwcrenderstage.h
+++ b/src/compositor/hwcrenderstage.h
@@ -17,6 +17,7 @@
 #define HWCRENDERSTAGE
 
 #include <private/qquickwindow_p.h>
+#include <private/qsgrenderer_p.h>
 
 Q_DECLARE_LOGGING_CATEGORY(LIPSTICK_LOG_HWC)
 
@@ -130,4 +131,4 @@ private:
     static bool m_hwcEnabled;
 };
 
-#endif // HWCRENDERSTAGE
\ No newline at end of file
+#endif // HWCRENDERSTAGE
diff --git a/src/compositor/lipstickcompositor.cpp b/src/compositor/lipstickcompositor.cpp
index fb4712be..086e7d6a 100644
--- a/src/compositor/lipstickcompositor.cpp
+++ b/src/compositor/lipstickcompositor.cpp
@@ -17,7 +17,7 @@
 #include <contentaction.h>
 #endif
 
-#include <QWaylandInputDevice>
+#include <QWaylandSeat>
 #include <QDesktopServices>
 #include <QtSensors/QOrientationSensor>
 #include <QClipboard>
@@ -29,20 +29,18 @@
 #include "lipstickcompositorprocwindow.h"
 #include "lipstickcompositor.h"
 #include "lipstickcompositoradaptor.h"
-#include "lipstickkeymap.h"
 #include "lipsticksettings.h"
-#include "lipstickrecorder.h"
 #include <qpa/qwindowsysteminterface.h>
-#include "alienmanager/alienmanager.h"
 #include "hwcrenderstage.h"
 #include <private/qguiapplication_p.h>
 #include <QtGui/qpa/qplatformintegration.h>
+#include <QWaylandQuickShellSurfaceItem>
+#include <QtWaylandCompositor/private/qwlextendedsurface_p.h>
 
 LipstickCompositor *LipstickCompositor::m_instance = 0;
 
 LipstickCompositor::LipstickCompositor()
-    : QWaylandQuickCompositor(this, 0, (QWaylandCompositor::ExtensionFlags)QWaylandCompositor::DefaultExtensions & ~QWaylandCompositor::QtKeyExtension)
-    , m_totalWindowCount(0)
+    : m_totalWindowCount(0)
     , m_nextWindowId(1)
     , m_homeActive(true)
     , m_shaderEffect(0)
@@ -57,12 +55,23 @@ LipstickCompositor::LipstickCompositor()
     , m_updatesEnabled(true)
     , m_completed(false)
     , m_onUpdatesDisabledUnfocusedWindowId(0)
-    , m_keymap(0)
-    , m_fakeRepaintTimerId(0)
+    , m_fakeRepaintTriggered(false)
 {
-    setColor(Qt::black);
+    m_window = new QQuickWindow();
+    m_window->setColor(Qt::black);
+    m_window->setVisible(true);
+
+    m_output = new QWaylandQuickOutput(this, m_window);
+    m_output->setSizeFollowsWindow(true);
+    connect(this, &QWaylandCompositor::surfaceCreated, this, &LipstickCompositor::onSurfaceCreated);
+
+    m_wlShell = new QWaylandWlShell(this);
+    connect(m_wlShell, &QWaylandWlShell::wlShellSurfaceCreated, this, &LipstickCompositor::onShellSurfaceCreated);
+
+    m_surfExtGlob = new QtWayland::SurfaceExtensionGlobal(this);
+    connect(m_surfExtGlob, &QtWayland::SurfaceExtensionGlobal::extendedSurfaceReady, this, &LipstickCompositor::onExtendedSurfaceReady);
+
     setRetainedSelectionEnabled(true);
-    addDefaultShell();
 
     if (m_instance) qFatal("LipstickCompositor: Only one compositor instance per process is supported");
     m_instance = this;
@@ -70,10 +79,21 @@ LipstickCompositor::LipstickCompositor()
     m_orientationLock = new MGConfItem("/lipstick/orientationLock", this);
     connect(m_orientationLock, SIGNAL(valueChanged()), SIGNAL(orientationLockChanged()));
 
+<<<<<<< HEAD
     connect(this, SIGNAL(visibleChanged(bool)), this, SLOT(onVisibleChanged(bool)));
     QObject::connect(this, SIGNAL(afterRendering()), this, SLOT(windowSwapped()));
+=======
+    // Load legacy settings from the config file and delete it from there
+    QSettings legacySettings("nemomobile", "lipstick");
+    QString legacyOrientationKey("Compositor/orientationLock");
+    if (legacySettings.contains(legacyOrientationKey)) {
+        m_orientationLock->set(legacySettings.value(legacyOrientationKey));
+        legacySettings.remove(legacyOrientationKey);
+    }
+
+    connect(m_window, SIGNAL(visibleChanged(bool)), this, SLOT(onVisibleChanged(bool)));
+>>>>>>> 0274da62... Upgrade QtWaylandCompositor API to Qt5.8 and removes some unused/untested code
     QObject::connect(HomeApplication::instance(), SIGNAL(aboutToDestroy()), this, SLOT(homeApplicationAboutToDestroy()));
-    connect(this, &QQuickWindow::afterRendering, this, &LipstickCompositor::readContent, Qt::DirectConnection);
 
     m_orientationSensor = new QOrientationSensor(this);
     QObject::connect(m_orientationSensor, SIGNAL(readingChanged()), this, SLOT(setScreenOrientationFromSensor()));
@@ -91,13 +111,8 @@ LipstickCompositor::LipstickCompositor()
 
     connect(QGuiApplication::clipboard(), SIGNAL(dataChanged()), SLOT(clipboardDataChanged()));
 
-    m_recorder = new LipstickRecorderManager;
-    addGlobalInterface(m_recorder);
-    addGlobalInterface(new AlienManagerGlobal);
-
     HwcRenderStage::initialize(this);
 
-    setUpdatesEnabled(false);
     QTimer::singleShot(0, this, SLOT(initialize()));
 
     setClientFullScreenHint(true);
@@ -117,7 +132,7 @@ LipstickCompositor::~LipstickCompositor()
 {
     // ~QWindow can a call into onVisibleChanged and QWaylandCompositor after we
     // are destroyed, so disconnect it.
-    disconnect(this, SIGNAL(visibleChanged(bool)), this, SLOT(onVisibleChanged(bool)));
+    disconnect(m_window, SIGNAL(visibleChanged(bool)), this, SLOT(onVisibleChanged(bool)));
 
     delete m_shaderEffect;
 
@@ -131,8 +146,8 @@ LipstickCompositor *LipstickCompositor::instance()
 
 void LipstickCompositor::homeApplicationAboutToDestroy()
 {
-    hide();
-    releaseResources();
+    m_window->hide();
+    m_window->releaseResources();
 
     // When destroying LipstickCompositor ~QQuickWindow() is called after
     // ~QWaylandQuickCompositor(), so changes to the items in the window may end
@@ -143,43 +158,54 @@ void LipstickCompositor::homeApplicationAboutToDestroy()
         delete w;
     }
 
-    cleanupGraphicsResources();
-
     m_instance = 0;
     delete this;
 }
 
-void LipstickCompositor::classBegin()
-{
-}
-
 void LipstickCompositor::onVisibleChanged(bool visible)
 {
     if (!visible) {
-        sendFrameCallbacks(surfaces());
+        m_output->sendFrameCallbacks();
     }
 }
 
-void LipstickCompositor::componentComplete()
+static LipstickCompositorWindow *surfaceWindow(QWaylandSurface *surface)
+{
+    return surface->views().isEmpty() ? 0 : static_cast<LipstickCompositorWindow *>(surface->views().first()->renderObject());
+}
+
+void LipstickCompositor::onShellSurfaceCreated(QWaylandWlShellSurface *shellSurface)
 {
-    QWaylandCompositor::setOutputGeometry(QRect(0, 0, width(), height()));
+    QWaylandSurface *surface = shellSurface->surface();
+    LipstickCompositorWindow *window = surfaceWindow(surface);
+    if(window) {
+//        window->setWlShellSurface(shellSurface);
+        connect(shellSurface, &QWaylandWlShellSurface::titleChanged, this, &LipstickCompositor::surfaceTitleChanged);
+        connect(shellSurface, &QWaylandWlShellSurface::setTransient, this, &LipstickCompositor::surfaceSetTransient);
+        connect(shellSurface, &QWaylandWlShellSurface::setFullScreen, this, &LipstickCompositor::surfaceSetFullScreen);
+    }
 }
 
-void LipstickCompositor::surfaceCreated(QWaylandSurface *surface)
+void LipstickCompositor::onSurfaceCreated(QWaylandSurface *surface)
 {
-    Q_UNUSED(surface)
-    connect(surface, SIGNAL(mapped()), this, SLOT(surfaceMapped()));
-    connect(surface, SIGNAL(unmapped()), this, SLOT(surfaceUnmapped()));
+    LipstickCompositorWindow *item = surfaceWindow(surface);
+    if (!item)
+        item = createView(surface);
+    connect(surface, SIGNAL(hasContentChanged()), this, SLOT(onHasContentChanged()));
     connect(surface, SIGNAL(sizeChanged()), this, SLOT(surfaceSizeChanged()));
-    connect(surface, SIGNAL(titleChanged()), this, SLOT(surfaceTitleChanged()));
-    connect(surface, SIGNAL(windowPropertyChanged(QString,QVariant)), this, SLOT(windowPropertyChanged(QString)));
-    connect(surface, SIGNAL(raiseRequested()), this, SLOT(surfaceRaised()));
-    connect(surface, SIGNAL(lowerRequested()), this, SLOT(surfaceLowered()));
     connect(surface, SIGNAL(damaged(QRegion)), this, SLOT(surfaceDamaged(QRegion)));
-    connect(surface, &QWaylandSurface::redraw, this, &LipstickCompositor::surfaceCommitted);
+    connect(surface, SIGNAL(redraw()), this, SLOT(windowSwapped()));
+    connect(surface, SIGNAL(surfaceDestroyed()), this, SLOT(windowSwapped()));
 }
 
-bool LipstickCompositor::openUrl(WaylandClient *client, const QUrl &url)
+void LipstickCompositor::onExtendedSurfaceReady(QtWayland::ExtendedSurface *extSurface, QWaylandSurface *surface)
+{
+    LipstickCompositorWindow *window = surfaceWindow(surface);
+    if(window)
+        window->setExtendedSurface(extSurface);
+}
+
+bool LipstickCompositor::openUrl(QWaylandClient *client, const QUrl &url)
 {
     Q_UNUSED(client)
     return openUrl(url);
@@ -252,7 +278,7 @@ bool LipstickCompositor::debug() const
 
 QObject *LipstickCompositor::windowForId(int id) const
 {
-    LipstickCompositorWindow *window = m_windows.value(id, 0);
+    QObject *window = m_windows.value(id, NULL);
     return window;
 }
 
@@ -277,13 +303,14 @@ bool LipstickCompositor::completed()
 int LipstickCompositor::windowIdForLink(QWaylandSurface *s, uint link) const
 {
     for (QHash<int, LipstickCompositorWindow *>::ConstIterator iter = m_windows.begin();
-         iter != m_windows.end(); ++iter) {
+        iter != m_windows.end(); ++iter) {
 
         QWaylandSurface *windowSurface = iter.value()->surface();
+        LipstickCompositorWindow *window = surfaceWindow(windowSurface);
 
-        if (windowSurface && windowSurface->client() && s->client() &&
-            windowSurface->processId() == s->processId() &&
-            windowSurface->windowProperties().value("WINID", uint(0)).toUInt() == link)
+        if (windowSurface && windowSurface->client() && s->client() && window &&
+            windowSurface->client()->processId() == s->client()->processId() &&
+            window->windowProperties().value("WINID", uint(0)).toUInt() == link)
             return iter.value()->windowId();
     }
 
@@ -292,7 +319,7 @@ int LipstickCompositor::windowIdForLink(QWaylandSurface *s, uint link) const
 
 void LipstickCompositor::clearKeyboardFocus()
 {
-    defaultInputDevice()->setKeyboardFocus(0);
+//    defaultInputDevice()->setKeyboardFocus(NULL);
 }
 
 void LipstickCompositor::setDisplayOff()
@@ -302,10 +329,10 @@ void LipstickCompositor::setDisplayOff()
 
 void LipstickCompositor::surfaceDamaged(const QRegion &)
 {
-    if (!isVisible()) {
+    if (!m_window->isVisible()) {
         // If the compositor is not visible, do not throttle.
         // make it conditional to QT_WAYLAND_COMPOSITOR_NO_THROTTLE?
-        sendFrameCallbacks(surfaces());
+        m_output->sendFrameCallbacks();
     }
 }
 
@@ -316,8 +343,8 @@ void LipstickCompositor::setFullscreenSurface(QWaylandSurface *surface)
 
     // Prevent flicker when returning to composited mode
     if (!surface && m_fullscreenSurface) {
-        foreach (QWaylandSurfaceView *view, m_fullscreenSurface->views())
-            static_cast<QWaylandSurfaceItem *>(view)->update();
+        foreach (QWaylandView *view, m_fullscreenSurface->views())
+            static_cast<LipstickCompositorWindow *>(view->renderObject())->update();
     }
 
     m_fullscreenSurface = surface;
@@ -340,7 +367,7 @@ void LipstickCompositor::setTopmostWindowId(int id)
         QWaylandSurface *surface = surfaceForId(m_topmostWindowId);
 
         if (surface)
-            pid = surface->processId();
+            pid = surface->client()->processId();
 
         if (m_topmostWindowProcessId != pid) {
             m_topmostWindowProcessId = pid;
@@ -349,24 +376,15 @@ void LipstickCompositor::setTopmostWindowId(int id)
     }
 }
 
-QWaylandSurfaceView *LipstickCompositor::createView(QWaylandSurface *surface)
+LipstickCompositorWindow *LipstickCompositor::createView(QWaylandSurface *surface)
 {
-    QVariantMap properties = surface->windowProperties();
-    QString category = properties.value("CATEGORY").toString();
-
     int id = m_nextWindowId++;
-    LipstickCompositorWindow *item = new LipstickCompositorWindow(id, category, static_cast<QWaylandQuickSurface *>(surface));
-    item->setParent(this);
+    LipstickCompositorWindow *item = new LipstickCompositorWindow(id, "", surface, m_window->contentItem());
     QObject::connect(item, SIGNAL(destroyed(QObject*)), this, SLOT(windowDestroyed()));
     m_windows.insert(item->windowId(), item);
     return item;
 }
 
-static LipstickCompositorWindow *surfaceWindow(QWaylandSurface *surface)
-{
-    return surface->views().isEmpty() ? 0 : static_cast<LipstickCompositorWindow *>(surface->views().first());
-}
-
 void LipstickCompositor::onSurfaceDying()
 {
     QWaylandSurface *surface = static_cast<QWaylandSurface *>(sender());
@@ -406,42 +424,42 @@ void LipstickCompositor::windowDestroyed(LipstickCompositorWindow *item)
     surfaceUnmapped(item);
 }
 
-void LipstickCompositor::surfaceMapped()
+void LipstickCompositor::onHasContentChanged()
 {
     QWaylandSurface *surface = qobject_cast<QWaylandSurface *>(sender());
 
+    if(surface->isCursorSurface())
+        return;
+
+    if(surface->hasContent())
+        surfaceMapped(surface);
+    else
+        surfaceUnmapped(surface);
+}
+
+void LipstickCompositor::surfaceMapped(QWaylandSurface *surface)
+{
     LipstickCompositorWindow *item = surfaceWindow(surface);
     if (!item)
-        item = static_cast<LipstickCompositorWindow *>(createView(surface));
+        item = createView(surface);
 
     // The surface was mapped for the first time
     if (item->m_mapped)
         return;
 
-    QWaylandSurface *transientParent = surface->transientParent();
-    if (transientParent) {
-        LipstickCompositorWindow *transientParentItem = surfaceWindow(transientParent);
-        if (transientParentItem) {
-            item->setParentItem(transientParentItem);
-            item->setX(surface->transientOffset().x());
-            item->setY(surface->transientOffset().y());
-        } else {
-            qWarning("Surface %s was mapped without visible transient parent", qPrintable(transientParent->className()));
-        }
-    }
-
-    QVariantMap properties = surface->windowProperties();
+    QVariantMap properties = item->windowProperties();
 
     item->m_mapped = true;
     item->m_category = properties.value("CATEGORY").toString();
 
     if (!item->parentItem()) {
         // TODO why contentItem?
-        item->setParentItem(contentItem());
+        item->setParentItem(m_window->contentItem());
     }
 
     item->setSize(surface->size());
     QObject::connect(surface, &QWaylandSurface::surfaceDestroyed, this, &LipstickCompositor::onSurfaceDying);
+
     m_totalWindowCount++;
     m_mappedSurfaces.insert(item->windowId(), item);
 
@@ -455,11 +473,6 @@ void LipstickCompositor::surfaceMapped()
     emit availableWinIdsChanged();
 }
 
-void LipstickCompositor::surfaceUnmapped()
-{
-    surfaceUnmapped(qobject_cast<QWaylandSurface *>(sender()));
-}
-
 void LipstickCompositor::surfaceSizeChanged()
 {
     QWaylandSurface *surface = qobject_cast<QWaylandSurface *>(sender());
@@ -471,10 +484,10 @@ void LipstickCompositor::surfaceSizeChanged()
 
 void LipstickCompositor::surfaceTitleChanged()
 {
-    QWaylandSurface *surface = qobject_cast<QWaylandSurface *>(sender());
-    LipstickCompositorWindow *window = surfaceWindow(surface);
-
+    QWaylandWlShellSurface *wlShellSurface = qobject_cast<QWaylandWlShellSurface*>(sender());
+    LipstickCompositorWindow *window = surfaceWindow(wlShellSurface->surface());
     if (window) {
+        window->setTitle(wlShellSurface->title());
         emit window->titleChanged();
 
         int windowId = window->windowId();
@@ -484,29 +497,39 @@ void LipstickCompositor::surfaceTitleChanged()
     }
 }
 
-void LipstickCompositor::surfaceRaised()
+void LipstickCompositor::surfaceSetTransient(QWaylandSurface *transientParent, const QPoint &relativeToParent, bool inactive)
 {
-    QWaylandSurface *surface = qobject_cast<QWaylandSurface *>(sender());
-    LipstickCompositorWindow *window = surfaceWindow(surface);
-
-    if (window && window->m_mapped) {
-        emit windowRaised(window);
+    Q_UNUSED(inactive)
+    QWaylandWlShellSurface *wlShellSurface = qobject_cast<QWaylandWlShellSurface*>(sender());
+    LipstickCompositorWindow *window = surfaceWindow(wlShellSurface->surface());
+    if (window && transientParent) {
+        LipstickCompositorWindow *transientParentItem = surfaceWindow(transientParent);
+        if (transientParentItem) {
+            window->setParentItem(transientParentItem);
+            window->setX(relativeToParent.x());
+            window->setY(relativeToParent.y());
+        } else {
+            qWarning("Surface was mapped without visible transient parent");
+        }
     }
 }
 
-void LipstickCompositor::surfaceLowered()
+void LipstickCompositor::surfaceSetFullScreen(QWaylandWlShellSurface::FullScreenMethod method, uint framerate, QWaylandOutput *output)
 {
-    QWaylandSurface *surface = qobject_cast<QWaylandSurface *>(sender());
-    LipstickCompositorWindow *window = surfaceWindow(surface);
+    Q_UNUSED(method)
+    Q_UNUSED(framerate)
+    QWaylandWlShellSurface *wlShellSurface = qobject_cast<QWaylandWlShellSurface*>(sender());
 
-    if (window && window->m_mapped) {
-        emit windowLowered(window);
-    }
+    QWaylandOutput *designatedOutput = output ? output : m_output;
+    if (!designatedOutput)
+        return;
+
+    wlShellSurface->sendConfigure(designatedOutput->geometry().size(), QWaylandWlShellSurface::NoneEdge);
 }
 
 void LipstickCompositor::windowSwapped()
 {
-    sendFrameCallbacks(surfaces());
+    m_output->sendFrameCallbacks();
 }
 
 void LipstickCompositor::windowDestroyed()
@@ -516,24 +539,6 @@ void LipstickCompositor::windowDestroyed()
     emit ghostWindowCountChanged();
 }
 
-void LipstickCompositor::windowPropertyChanged(const QString &property)
-{
-    QWaylandSurface *surface = qobject_cast<QWaylandSurface *>(sender());
-
-    if (debug())
-        qDebug() << "Window properties changed:" << surface << surface->windowProperties();
-
-    if (property == QLatin1String("MOUSE_REGION")) {
-        LipstickCompositorWindow *window = surfaceWindow(surface);
-        if (window)
-            window->refreshMouseRegion();
-    } else if (property == QLatin1String("GRABBED_KEYS")) {
-        LipstickCompositorWindow *window = surfaceWindow(surface);
-        if (window)
-            window->refreshGrabbedKeys();
-    }
-}
-
 void LipstickCompositor::surfaceUnmapped(QWaylandSurface *surface)
 {
     if (surface == m_fullscreenSurface)
@@ -548,10 +553,10 @@ void LipstickCompositor::surfaceUnmapped(LipstickCompositorWindow *item)
 {
     int id = item->windowId();
 
-    int gc = ghostWindowCount();
-    if (m_mappedSurfaces.remove(item->windowId()) == 0)
+    if (m_mappedSurfaces.remove(id) == 0) {
         // It was unmapped already so nothing to do
         return;
+    }
 
     emit windowCountChanged();
     emit windowRemoved(item);
@@ -559,8 +564,7 @@ void LipstickCompositor::surfaceUnmapped(LipstickCompositorWindow *item)
     item->m_windowClosed = true;
     item->tryRemove();
 
-    if (gc != ghostWindowCount())
-        emit ghostWindowCountChanged();
+    emit ghostWindowCountChanged();
 
     windowRemoved(id);
 
@@ -609,7 +613,36 @@ void LipstickCompositor::setScreenOrientation(Qt::ScreenOrientation screenOrient
         if (debug())
             qDebug() << "Setting screen orientation on QWaylandCompositor";
 
-        QWaylandCompositor::setScreenOrientation(screenOrientation);
+        QSize physSize = m_output->physicalSize();
+        switch(screenOrientation) {
+        case Qt::PrimaryOrientation:
+            m_output->setTransform(QWaylandOutput::TransformNormal);
+            break;
+        case Qt::LandscapeOrientation:
+            if(physSize.width() > physSize.height())
+                m_output->setTransform(QWaylandOutput::TransformNormal);
+            else
+                m_output->setTransform(QWaylandOutput::Transform90);
+            break;
+        case Qt::PortraitOrientation:
+            if(physSize.width() > physSize.height())
+                m_output->setTransform(QWaylandOutput::Transform90);
+            else
+                m_output->setTransform(QWaylandOutput::TransformNormal);
+            break;
+        case Qt::InvertedLandscapeOrientation:
+            if(physSize.width() > physSize.height())
+                m_output->setTransform(QWaylandOutput::Transform180);
+            else
+                m_output->setTransform(QWaylandOutput::Transform270);
+            break;
+        case Qt::InvertedPortraitOrientation:
+            if(physSize.width() > physSize.height())
+                m_output->setTransform(QWaylandOutput::Transform270);
+            else
+                m_output->setTransform(QWaylandOutput::Transform180);
+            break;
+        }
         QWindowSystemInterface::handleScreenOrientationChange(qApp->primaryScreen(),screenOrientation);
 
         m_screenOrientation = screenOrientation;
@@ -617,54 +650,6 @@ void LipstickCompositor::setScreenOrientation(Qt::ScreenOrientation screenOrient
     }
 }
 
-bool LipstickCompositor::displayDimmed() const
-{
-    TouchScreen *touchScreen = HomeApplication::instance()->touchScreen();
-    return displayStateIsDimmed(touchScreen->currentDisplayState());
-}
-
-LipstickKeymap *LipstickCompositor::keymap() const
-{
-    return m_keymap;
-}
-
-void LipstickCompositor::setKeymap(LipstickKeymap *keymap)
-{
-    if (m_keymap == keymap)
-        return;
-
-    bool update = true;
-
-    if (m_keymap && keymap)
-        update = (*m_keymap != *keymap);
-
-    if (m_keymap)
-        disconnect(m_keymap, 0, this, 0);
-
-    m_keymap = keymap;
-
-    if (m_keymap) {
-        connect(m_keymap, &LipstickKeymap::rulesChanged, this, &LipstickCompositor::updateKeymap);
-        connect(m_keymap, &LipstickKeymap::modelChanged, this, &LipstickCompositor::updateKeymap);
-        connect(m_keymap, &LipstickKeymap::layoutChanged, this, &LipstickCompositor::updateKeymap);
-        connect(m_keymap, &LipstickKeymap::variantChanged, this, &LipstickCompositor::updateKeymap);
-        connect(m_keymap, &LipstickKeymap::optionsChanged, this, &LipstickCompositor::updateKeymap);
-    }
-
-    if (update)
-        updateKeymap();
-
-    emit keymapChanged();
-}
-
-void LipstickCompositor::updateKeymap()
-{
-    if (m_keymap)
-        defaultInputDevice()->setKeymap(m_keymap->waylandKeymap());
-    else
-        defaultInputDevice()->setKeymap(QWaylandKeymap());
-}
-
 void LipstickCompositor::reactOnDisplayStateChanges(TouchScreen::DisplayState oldState, TouchScreen::DisplayState newState)
 {
     bool oldOn = displayStateIsOn(oldState);
@@ -735,7 +720,6 @@ void LipstickCompositor::setUpdatesEnabled(bool enabled)
 {
     if (m_updatesEnabled != enabled) {
         m_updatesEnabled = enabled;
-
         if (!m_updatesEnabled) {
             emit displayAboutToBeOff();
             LipstickCompositorWindow *topmostWindow = qobject_cast<LipstickCompositorWindow *>(windowForId(topmostWindowId()));
@@ -743,18 +727,18 @@ void LipstickCompositor::setUpdatesEnabled(bool enabled)
                 m_onUpdatesDisabledUnfocusedWindowId = topmostWindow->windowId();
                 clearKeyboardFocus();
             }
-            hide();
-            if (QWindow::handle()) {
+            m_window->hide();
+            if (m_window->handle()) {
                 QGuiApplication::platformNativeInterface()->nativeResourceForIntegration("DisplayOff");
             }
             // trigger frame callbacks which are pending already at this time
             surfaceCommitted();
         } else {
-            if (QWindow::handle()) {
+            if (m_window->handle()) {
                 QGuiApplication::platformNativeInterface()->nativeResourceForIntegration("DisplayOn");
             }
             emit displayAboutToBeOn();
-            showFullScreen();
+            m_window->showFullScreen();
             if (m_onUpdatesDisabledUnfocusedWindowId > 0) {
                 if (!LipstickSettings::instance()->lockscreenVisible()) {
                     LipstickCompositorWindow *topmostWindow = qobject_cast<LipstickCompositorWindow *>(windowForId(topmostWindowId()));
@@ -773,27 +757,19 @@ void LipstickCompositor::setUpdatesEnabled(bool enabled)
     }
 }
 
-void LipstickCompositor::readContent()
-{
-    m_recorder->recordFrame(this);
-}
-
 void LipstickCompositor::surfaceCommitted()
 {
-    if (!isVisible() && m_fakeRepaintTimerId == 0) {
-        m_fakeRepaintTimerId = startTimer(1000);
-    } else if (isVisible() && m_fakeRepaintTimerId > 0) {
-        killTimer(m_fakeRepaintTimerId);
-        m_fakeRepaintTimerId = 0;
+    if (!m_window->isVisible() && !m_fakeRepaintTriggered) {
+        startTimer(1000);
+        m_fakeRepaintTriggered = true;
     }
 }
 
 void LipstickCompositor::timerEvent(QTimerEvent *e)
 {
-    if (e->timerId() == m_fakeRepaintTimerId) {
-        frameStarted();
-        sendFrameCallbacks(surfaces());
-        killTimer(e->timerId());
-        m_fakeRepaintTimerId = 0;
-    }
+    Q_UNUSED(e)
+
+    m_output->frameStarted();
+    m_output->sendFrameCallbacks();
+    killTimer(e->timerId());
 }
diff --git a/src/compositor/lipstickcompositor.h b/src/compositor/lipstickcompositor.h
index bc5b1343..4d1dff68 100644
--- a/src/compositor/lipstickcompositor.h
+++ b/src/compositor/lipstickcompositor.h
@@ -19,25 +19,30 @@
 #include <QQuickWindow>
 #include "lipstickglobal.h"
 #include "homeapplication.h"
-#include <QQmlParserStatus>
+#include <QQmlParserStatus>]
 #include <QWaylandQuickCompositor>
-#include <QWaylandSurfaceItem>
+#include <QWaylandQuickOutput>
+#include <QWaylandWlShellSurface>
+#include <QQmlComponent>
+#include <QWaylandClient>
 #include <QPointer>
 #include <QTimer>
 #include <MGConfItem>
 
+namespace QtWayland {
+    class SurfaceExtensionGlobal;
+    class ExtendedSurface;
+}
+
 class WindowModel;
 class LipstickCompositorWindow;
 class LipstickCompositorProcWindow;
 class QOrientationSensor;
 class LipstickRecorderManager;
-class LipstickKeymap;
 
-class LIPSTICK_EXPORT LipstickCompositor : public QQuickWindow, public QWaylandQuickCompositor,
-                                           public QQmlParserStatus
+class LIPSTICK_EXPORT LipstickCompositor : public QWaylandQuickCompositor
 {
     Q_OBJECT
-    Q_INTERFACES(QQmlParserStatus)
 
     Q_PROPERTY(int windowCount READ windowCount NOTIFY windowCountChanged)
     Q_PROPERTY(int ghostWindowCount READ ghostWindowCount NOTIFY ghostWindowCountChanged)
@@ -49,11 +54,11 @@ class LIPSTICK_EXPORT LipstickCompositor : public QQuickWindow, public QWaylandQ
     Q_PROPERTY(Qt::ScreenOrientation topmostWindowOrientation READ topmostWindowOrientation WRITE setTopmostWindowOrientation NOTIFY topmostWindowOrientationChanged)
     Q_PROPERTY(Qt::ScreenOrientation screenOrientation READ screenOrientation WRITE setScreenOrientation NOTIFY screenOrientationChanged)
     Q_PROPERTY(Qt::ScreenOrientation sensorOrientation READ sensorOrientation NOTIFY sensorOrientationChanged)
-    Q_PROPERTY(LipstickKeymap *keymap READ keymap WRITE setKeymap NOTIFY keymapChanged)
     Q_PROPERTY(QObject* clipboard READ clipboard CONSTANT)
     Q_PROPERTY(QVariant orientationLock READ orientationLock NOTIFY orientationLockChanged)
     Q_PROPERTY(bool displayDimmed READ displayDimmed NOTIFY displayDimmedChanged)
     Q_PROPERTY(bool completed READ completed NOTIFY completedChanged)
+    Q_PROPERTY(QQuickWindow *quickWindow READ quickWindow CONSTANT)
 
 public:
     LipstickCompositor();
@@ -61,10 +66,7 @@ public:
 
     static LipstickCompositor *instance();
 
-    void classBegin() Q_DECL_OVERRIDE;
-    void componentComplete() Q_DECL_OVERRIDE;
-    void surfaceCreated(QWaylandSurface *surface) Q_DECL_OVERRIDE;
-    bool openUrl(WaylandClient *client, const QUrl &url) Q_DECL_OVERRIDE;
+    bool openUrl(QWaylandClient *client, const QUrl &url);
     void retainedSelectionReceived(QMimeData *mimeData) Q_DECL_OVERRIDE;
 
     int windowCount() const;
@@ -93,9 +95,6 @@ public:
 
     bool displayDimmed() const;
 
-    LipstickKeymap *keymap() const;
-    void setKeymap(LipstickKeymap *keymap);
-
     QObject *clipboard() const;
 
     bool debug() const;
@@ -115,7 +114,9 @@ public:
     bool completed();
 
     void setUpdatesEnabled(bool enabled);
-    QWaylandSurfaceView *createView(QWaylandSurface *surf) Q_DECL_OVERRIDE;
+    LipstickCompositorWindow *createView(QWaylandSurface *surf);
+
+    QQuickWindow *quickWindow() { return m_window; }
 
 protected:
     void timerEvent(QTimerEvent *e) Q_DECL_OVERRIDE;
@@ -143,8 +144,6 @@ signals:
     void orientationLockChanged();
     void displayDimmedChanged();
 
-    void keymapChanged();
-
     void displayOn();
     void displayOff();
     void displayAboutToBeOn();
@@ -155,16 +154,14 @@ signals:
     void showUnlockScreen();
 
 private slots:
-    void surfaceMapped();
-    void surfaceUnmapped();
+    void onHasContentChanged();
     void surfaceSizeChanged();
     void surfaceTitleChanged();
-    void surfaceRaised();
-    void surfaceLowered();
+    void surfaceSetTransient(QWaylandSurface *transientParent, const QPoint &relativeToParent, bool inactive);
+    void surfaceSetFullScreen(QWaylandWlShellSurface::FullScreenMethod method, uint framerate, QWaylandOutput *output);
     void surfaceDamaged(const QRegion &);
     void windowSwapped();
     void windowDestroyed();
-    void windowPropertyChanged(const QString &);
     bool openUrl(const QUrl &);
     void reactOnDisplayStateChanges(TouchScreen::DisplayState oldState, TouchScreen::DisplayState newState);
     void homeApplicationAboutToDestroy();
@@ -172,27 +169,28 @@ private slots:
     void clipboardDataChanged();
     void onVisibleChanged(bool visible);
     void onSurfaceDying();
-    void updateKeymap();
     void initialize();
 
+    void onShellSurfaceCreated(QWaylandWlShellSurface *wlShellSurface);
+    void onExtendedSurfaceReady(QtWayland::ExtendedSurface *extSurface, QWaylandSurface *surface);
+
 private:
     friend class LipstickCompositorWindow;
     friend class LipstickCompositorProcWindow;
     friend class WindowModel;
-    friend class WindowPixmapItem;
-    friend class WindowProperty;
+    friend class NotificationPreviewPresenter;
+    friend class NotificationFeedbackPlayer;
 
+    void surfaceMapped(QWaylandSurface *surface);
+    void surfaceUnmapped(QWaylandSurface *surface);
     void surfaceUnmapped(LipstickCompositorWindow *item);
 
     int windowIdForLink(QWaylandSurface *, uint) const;
-
-    void surfaceUnmapped(QWaylandSurface *);
-
     void windowAdded(int);
     void windowRemoved(int);
     void windowDestroyed(LipstickCompositorWindow *item);
-    void readContent();
     void surfaceCommitted();
+    void onSurfaceCreated(QWaylandSurface *surface);
 
     QQmlComponent *shaderEffectComponent();
 
@@ -221,10 +219,11 @@ private:
     bool m_updatesEnabled;
     bool m_completed;
     int m_onUpdatesDisabledUnfocusedWindowId;
-    LipstickRecorderManager *m_recorder;
-    LipstickKeymap *m_keymap;
-    int m_fakeRepaintTimerId;
-
+    bool m_fakeRepaintTriggered;
+    QQuickWindow *m_window;
+    QWaylandOutput *m_output;
+    QWaylandWlShell *m_wlShell;
+    QtWayland::SurfaceExtensionGlobal *m_surfExtGlob;
 };
 
 #endif // LIPSTICKCOMPOSITOR_H
diff --git a/src/compositor/lipstickcompositorprocwindow.cpp b/src/compositor/lipstickcompositorprocwindow.cpp
index 678ffafa..04508c7a 100644
--- a/src/compositor/lipstickcompositorprocwindow.cpp
+++ b/src/compositor/lipstickcompositorprocwindow.cpp
@@ -28,7 +28,7 @@ LipstickCompositorProcWindow *LipstickCompositor::mapProcWindow(const QString &t
 {
     int id = m_nextWindowId++;
 
-    LipstickCompositorProcWindow *item = new LipstickCompositorProcWindow(id, category, contentItem());
+    LipstickCompositorProcWindow *item = new LipstickCompositorProcWindow(id, category, m_window->contentItem());
     item->setSize(g.size());
     item->setTitle(title);
     item->setRootItem(rootItem);
diff --git a/src/compositor/lipstickcompositorwindow.cpp b/src/compositor/lipstickcompositorwindow.cpp
index 2992c9a8..82b46514 100644
--- a/src/compositor/lipstickcompositorwindow.cpp
+++ b/src/compositor/lipstickcompositorwindow.cpp
@@ -15,7 +15,7 @@
 
 #include <QCoreApplication>
 #include <QWaylandCompositor>
-#include <QWaylandInputDevice>
+#include <QWaylandSeat>
 #include <QTimer>
 #include <sys/types.h>
 #include <signal.h>
@@ -25,29 +25,29 @@
 #include "hwcimage.h"
 #include "hwcrenderstage.h"
 #include <EGL/egl.h>
-#include <private/qwlsurface_p.h>
+#include <private/qwaylandsurface_p.h>
 #include <private/qquickwindow_p.h>
+#include <QtWaylandCompositor/private/qwlextendedsurface_p.h>
 
 LipstickCompositorWindow::LipstickCompositorWindow(int windowId, const QString &category,
-                                                   QWaylandQuickSurface *surface, QQuickItem *parent)
-: QWaylandSurfaceItem(surface, parent), m_windowId(windowId), m_isAlien(false), m_category(category),
-  m_delayRemove(false), m_windowClosed(false), m_removePosted(false), m_mouseRegionValid(false),
+                                                   QWaylandSurface *surface, QQuickItem *parent)
+: QWaylandQuickItem(), m_windowId(windowId), m_category(category),
+  m_delayRemove(false), m_windowClosed(false), m_removePosted(false),
   m_interceptingTouch(false), m_mapped(false), m_noHardwareComposition(false),
   m_focusOnTouch(false), m_hasVisibleReferences(false)
 {
     setFlags(QQuickItem::ItemIsFocusScope | flags());
-    refreshMouseRegion();
 
     // Handle ungrab situations
     connect(this, SIGNAL(visibleChanged()), SLOT(handleTouchCancel()));
     connect(this, SIGNAL(enabledChanged()), SLOT(handleTouchCancel()));
     connect(this, SIGNAL(touchEventsEnabledChanged()), SLOT(handleTouchCancel()));
-    connect(this, &QWaylandSurfaceItem::surfaceDestroyed, this, &QObject::deleteLater);
 
-    if (surface) {
-        m_isAlien = surface->property("alienSurface").toBool();
+    if(surface) {
+        connect(surface, SIGNAL(surfaceDestroyed()), this, SLOT(deleteLater()));
+        setSurface(surface);
     }
-
+    Q_UNUSED(parent)
     connectSurfaceSignals();
 }
 
@@ -85,7 +85,7 @@ bool LipstickCompositorWindow::isAlien() const
 qint64 LipstickCompositorWindow::processId() const
 {
     if (surface())
-        return surface()->processId();
+        return surface()->client()->processId();
     else return 0;
 }
 
@@ -101,9 +101,9 @@ void LipstickCompositorWindow::setDelayRemove(bool delay)
 
     m_delayRemove = delay;
     if (m_delayRemove)
-        disconnect(this, &QWaylandSurfaceItem::surfaceDestroyed, this, &QObject::deleteLater);
+        disconnect(surface(), SIGNAL(surfaceDestroyed()), this, SLOT(deleteLater()));
     else
-        connect(this, &QWaylandSurfaceItem::surfaceDestroyed, this, &QObject::deleteLater);
+        connect(surface(), SIGNAL(surfaceDestroyed()), this, SLOT(deleteLater()));
 
     emit delayRemoveChanged();
 
@@ -115,11 +115,40 @@ QString LipstickCompositorWindow::category() const
     return m_category;
 }
 
+QtWayland::ExtendedSurface *LipstickCompositorWindow::extendedSurface()
+{
+    return m_extSurface;
+}
+
+void LipstickCompositorWindow::setExtendedSurface(QtWayland::ExtendedSurface *extSurface)
+{
+    m_extSurface = extSurface;
+    connect(m_extSurface, SIGNAL(windowFlagsChanged()), this, SIGNAL(windowFlagsChanged()));
+}
+
+qint16 LipstickCompositorWindow::windowFlags()
+{
+    if (m_extSurface) {
+        return m_extSurface->windowFlags();
+    }
+    return 0;
+}
+
+QVariantMap LipstickCompositorWindow::windowProperties()
+{
+    if (m_extSurface)
+        return m_extSurface->windowProperties();
+    return QVariantMap();
+}
+
+void LipstickCompositorWindow::setTitle(QString title)
+{
+    m_title = title;
+}
+
 QString LipstickCompositorWindow::title() const
 {
-    if (surface())
-        return surface()->title();
-    return QString();
+    return m_title;
 }
 
 void LipstickCompositorWindow::imageAddref(QQuickItem *item)
@@ -150,58 +179,6 @@ void LipstickCompositorWindow::tryRemove()
     }
 }
 
-QRect LipstickCompositorWindow::mouseRegionBounds() const
-{
-    if (m_mouseRegionValid)
-        return m_mouseRegion.boundingRect();
-    else
-        return QRect(0, 0, width(), height());
-}
-
-void LipstickCompositorWindow::refreshMouseRegion()
-{
-    QWaylandSurface *s = surface();
-    if (s) {
-        QVariantMap properties = s->windowProperties();
-        if (properties.contains(QLatin1String("MOUSE_REGION"))) {
-            m_mouseRegion = s->windowProperties().value("MOUSE_REGION").value<QRegion>();
-            m_mouseRegionValid = true;
-            if (LipstickCompositor::instance()->debug())
-                qDebug() << "Window" << windowId() << "mouse region set:" << m_mouseRegion;
-        } else {
-            m_mouseRegionValid = false;
-            if (LipstickCompositor::instance()->debug())
-                qDebug() << "Window" << windowId() << "mouse region cleared";
-        }
-
-        emit mouseRegionBoundsChanged();
-    }
-}
-
-void LipstickCompositorWindow::refreshGrabbedKeys()
-{
-    QWaylandSurface *s = surface();
-    if (s) {
-        const QStringList grabbedKeys = s->windowProperties().value(
-                    QLatin1String("GRABBED_KEYS")).value<QStringList>();
-
-        if (m_grabbedKeys.isEmpty() && !grabbedKeys.isEmpty()) {
-            qApp->installEventFilter(this);
-        } else if (!m_grabbedKeys.isEmpty() && grabbedKeys.isEmpty() && m_pressedGrabbedKeys.keys.isEmpty()) {
-            // we don't remove the event filter if m_pressedGrabbedKeys.keys contains still some key.
-            // we wait the key release for that.
-            qApp->removeEventFilter(this);
-        }
-
-        m_grabbedKeys.clear();
-        foreach (const QString &key, grabbedKeys)
-            m_grabbedKeys.append(key.toInt());
-
-        if (LipstickCompositor::instance()->debug())
-            qDebug() << "Window" << windowId() << "grabbed keys changed:" << grabbedKeys;
-    }
-}
-
 bool LipstickCompositorWindow::eventFilter(QObject *obj, QEvent *event)
 {
     if (obj == window() && m_interceptingTouch) {
@@ -228,25 +205,13 @@ bool LipstickCompositorWindow::eventFilter(QObject *obj, QEvent *event)
     if (event->type() == QEvent::KeyPress || event->type() == QEvent::KeyRelease) {
         QKeyEvent *ke = static_cast<QKeyEvent *>(event);
         QWaylandSurface *m_surface = surface();
-        if (m_surface && (m_grabbedKeys.contains(ke->key()) || m_pressedGrabbedKeys.keys.contains(ke->key())) && !ke->isAutoRepeat()) {
-            QWaylandInputDevice *inputDevice = m_surface->compositor()->defaultInputDevice();
-            if (event->type() == QEvent::KeyPress) {
-                if (m_pressedGrabbedKeys.keys.isEmpty()) {
-                    QWaylandSurface *old = inputDevice->keyboardFocus();
-                    m_pressedGrabbedKeys.oldFocus = old;
-                    inputDevice->setKeyboardFocus(m_surface);
-                }
-                m_pressedGrabbedKeys.keys << ke->key();
-            }
+        if (m_surface) {
+            QWaylandSeat *inputDevice = m_surface->compositor()->seatFor(ke);
+            if (event->type() == QEvent::KeyPress)
+                inputDevice->setKeyboardFocus(m_surface);
             inputDevice->sendFullKeyEvent(ke);
-            if (event->type() == QEvent::KeyRelease) {
-                m_pressedGrabbedKeys.keys.removeOne(ke->key());
-                if (m_pressedGrabbedKeys.keys.isEmpty()) {
-                    inputDevice->setKeyboardFocus(m_pressedGrabbedKeys.oldFocus.data());
-                    if (m_grabbedKeys.isEmpty())
-                        qApp->removeEventFilter(this);
-                }
-            }
+            if (event->type() == QEvent::KeyRelease)
+                qApp->removeEventFilter(this);
             return true;
         }
     }
@@ -272,12 +237,12 @@ void LipstickCompositorWindow::itemChange(ItemChange change, const ItemChangeDat
         }
 
     }
-    QWaylandSurfaceItem::itemChange(change, data);
+    QWaylandQuickItem::itemChange(change, data);
 }
 
 bool LipstickCompositorWindow::event(QEvent *e)
 {
-    bool rv = QWaylandSurfaceItem::event(e);
+    bool rv = QWaylandQuickItem::event(e);
     if (e->type() == QEvent::User) {
         m_removePosted = false;
         if (canRemove()) delete this;
@@ -288,16 +253,16 @@ bool LipstickCompositorWindow::event(QEvent *e)
 void LipstickCompositorWindow::mousePressEvent(QMouseEvent *event)
 {
     QWaylandSurface *m_surface = surface();
-    if (m_surface && (!m_mouseRegionValid || m_mouseRegion.contains(event->pos())) &&
-        m_surface->inputRegionContains(event->pos()) && event->source() != Qt::MouseEventSynthesizedByQt) {
-        QWaylandInputDevice *inputDevice = m_surface->compositor()->defaultInputDevice();
-        if (inputDevice->mouseFocus() != this) {
-            inputDevice->setMouseFocus(this, event->pos(), event->globalPos());
+    if (m_surface && m_surface->inputRegionContains(event->pos()) && event->source() != Qt::MouseEventSynthesizedByQt) {
+        QWaylandSeat *inputDevice = m_surface->compositor()->seatFor(event);
+        QWaylandView *v = view();
+        if (inputDevice->mouseFocus() != v) {
+            inputDevice->setMouseFocus(v);
             if (m_focusOnTouch && inputDevice->keyboardFocus() != m_surface) {
                 takeFocus();
             }
         }
-        inputDevice->sendMousePressEvent(event->button(), event->pos(), event->globalPos());
+        inputDevice->sendMousePressEvent(event->button());
     } else {
         event->ignore();
     }
@@ -307,8 +272,9 @@ void LipstickCompositorWindow::mouseMoveEvent(QMouseEvent *event)
 {
     QWaylandSurface *m_surface = surface();
     if (m_surface && event->source() != Qt::MouseEventSynthesizedByQt) {
-        QWaylandInputDevice *inputDevice = m_surface->compositor()->defaultInputDevice();
-        inputDevice->sendMouseMoveEvent(this, event->pos(), event->globalPos());
+        QWaylandView *v = view();
+        QWaylandSeat *inputDevice = m_surface->compositor()->seatFor(event);
+        inputDevice->sendMouseMoveEvent(v, event->localPos(), event->globalPos());
     } else {
         event->ignore();
     }
@@ -318,8 +284,8 @@ void LipstickCompositorWindow::mouseReleaseEvent(QMouseEvent *event)
 {
     QWaylandSurface *m_surface = surface();
     if (m_surface && event->source() != Qt::MouseEventSynthesizedByQt) {
-        QWaylandInputDevice *inputDevice = m_surface->compositor()->defaultInputDevice();
-        inputDevice->sendMouseReleaseEvent(event->button(), event->pos(), event->globalPos());
+        QWaylandSeat *inputDevice = m_surface->compositor()->seatFor(event);
+        inputDevice->sendMouseReleaseEvent(event->button());
     } else {
         event->ignore();
     }
@@ -329,7 +295,7 @@ void LipstickCompositorWindow::wheelEvent(QWheelEvent *event)
 {
     QWaylandSurface *m_surface = surface();
     if (m_surface) {
-        QWaylandInputDevice *inputDevice = m_surface->compositor()->defaultInputDevice();
+        QWaylandSeat *inputDevice = m_surface->compositor()->seatFor(event);
         inputDevice->sendMouseWheelEvent(event->orientation(), event->delta());
     } else {
         event->ignore();
@@ -366,28 +332,33 @@ void LipstickCompositorWindow::handleTouchEvent(QTouchEvent *event)
 
     if (event->touchPointStates() & Qt::TouchPointPressed) {
         foreach (const QTouchEvent::TouchPoint &p, points) {
-            if ((m_mouseRegionValid && !m_mouseRegion.contains(p.pos().toPoint())) ||
-                !m_surface->inputRegionContains(p.pos().toPoint())) {
+            if (!m_surface->inputRegionContains(p.pos().toPoint())) {
                 event->ignore();
                 return;
             }
         }
     }
 
-    QWaylandInputDevice *inputDevice = m_surface->compositor()->defaultInputDevice();
+    QWaylandSeat *inputDevice = m_surface->compositor()->seatFor(event);
     event->accept();
 
-    if (inputDevice->mouseFocus() != this) {
+    QWaylandView *vview = view();
+    if (vview && (!vview->surface() || vview->surface()->isCursorSurface()))
+        vview = Q_NULLPTR;
+    inputDevice->setMouseFocus(vview);
+
+    QWaylandView *v = view();
+    if (inputDevice->mouseFocus() != v) {
         QPoint pointPos;
         if (!points.isEmpty())
             pointPos = points.at(0).pos().toPoint();
-        inputDevice->setMouseFocus(this, pointPos, pointPos);
+        inputDevice->setMouseFocus(v);
 
         if (m_focusOnTouch && inputDevice->keyboardFocus() != m_surface) {
             takeFocus();
         }
     }
-    inputDevice->sendFullTouchEvent(event);
+    inputDevice->sendFullTouchEvent(surface(), event);
 }
 
 void LipstickCompositorWindow::handleTouchCancel()
@@ -395,11 +366,12 @@ void LipstickCompositorWindow::handleTouchCancel()
     QWaylandSurface *m_surface = surface();
     if (!m_surface)
         return;
-    QWaylandInputDevice *inputDevice = m_surface->compositor()->defaultInputDevice();
-    if (inputDevice->mouseFocus() == this &&
+    QWaylandSeat *inputDevice = m_surface->compositor()->defaultSeat();
+    QWaylandView *v = view();
+    if (inputDevice->mouseFocus() == v &&
             (!isVisible() || !isEnabled() || !touchEventsEnabled())) {
-        inputDevice->sendTouchCancelEvent();
-        inputDevice->setMouseFocus(0, QPointF());
+        inputDevice->sendTouchCancelEvent(surface()->client());
+        inputDevice->setMouseFocus(0);
     }
     if (QWindow *w = window())
         w->removeEventFilter(this);
@@ -431,7 +403,6 @@ void LipstickCompositorWindow::connectSurfaceSignals()
 
     m_surfaceConnections.clear();
     if (surface()) {
-        m_surfaceConnections << connect(surface(), SIGNAL(titleChanged()), SIGNAL(titleChanged()));
         m_surfaceConnections << connect(surface(), &QWaylandSurface::configure, this, &LipstickCompositorWindow::committed);
     }
 }
@@ -445,18 +416,13 @@ static Ptr_eglHybrisAcquireNativeBufferWL eglHybrisAcquireNativeBufferWL;
 static Ptr_eglHybrisNativeBufferHandle eglHybrisNativeBufferHandle;
 static Ptr_eglHybrisReleaseNativeBuffer eglHybrisReleaseNativeBuffer;
 
-struct QWlSurface_Accessor : public QtWayland::Surface {
-    QtWayland::SurfaceBuffer *surfaceBuffer() const { return m_buffer; };
-    wl_resource *surfaceBufferHandle() const { return m_buffer ? m_buffer->waylandBufferHandle() : 0; }
-};
-
 class LipstickCompositorWindowHwcNode : public HwcNode
 {
 public:
     LipstickCompositorWindowHwcNode(QQuickWindow *window) : HwcNode(window), eglBuffer(0) { }
     ~LipstickCompositorWindowHwcNode();
 
-    void update(QWlSurface_Accessor *s, EGLClientBuffer newBuffer, void *newHandle, QSGNode *contentNode);
+    void update(QWaylandSurfacePrivate *s, EGLClientBuffer newBuffer, void *newHandle, QSGNode *contentNode);
 
     EGLClientBuffer eglBuffer;
     QWaylandBufferRef waylandBuffer;
@@ -484,7 +450,7 @@ void LipstickCompositorWindow::onSync()
 QSGNode *LipstickCompositorWindow::updatePaintNode(QSGNode *old, UpdatePaintNodeData *data)
 {
     if (!hwc_windowsurface_is_enabled() || m_noHardwareComposition)
-        return QWaylandSurfaceItem::updatePaintNode(old, data);
+        return QWaylandQuickItem::updatePaintNode(old, data);
 
     // qCDebug(LIPSTICK_LOG_HWC, "LipstickCompositorWindow(%p)::updatePaintNode(), old=%p", this, old);
 
@@ -497,17 +463,19 @@ QSGNode *LipstickCompositorWindow::updatePaintNode(QSGNode *old, UpdatePaintNode
     // Added to this logic, we have the case of a window surface suddenly
     // appearing with a shm buffer. We then need to switch to normal
     // composition.
-    bool hwBuffer = surface() && surface()->type() == QWaylandSurface::Texture;
+
+                               // TODO: a327ca8d8a1f6e0a44a3aa6bd4dac716911c434e
+    bool hwBuffer = surface(); // TODO && surface()->type() == QWaylandSurface::Texture;
     int wantedNodeType = m_hasVisibleReferences || !hwBuffer ? QSGNode::GeometryNodeType : QSG_HWC_NODE_TYPE;
     if (old && old->type() != wantedNodeType) {
         delete old;
         old = 0;
     }
     if (m_hasVisibleReferences || !hwBuffer)
-        return QWaylandSurfaceItem::updatePaintNode(old, data);
+        return QWaylandQuickItem::updatePaintNode(old, data);
 
     // No surface, abort..
-    if (!surface() || !surface()->handle() || !surface()->isMapped() || !textureProvider()->texture()) {
+    if (!surface() || !QWaylandSurfacePrivate::get(surface()) || !surface()->hasContent() || !textureProvider()->texture()) {
         delete old;
         return 0;
     }
@@ -515,8 +483,9 @@ QSGNode *LipstickCompositorWindow::updatePaintNode(QSGNode *old, UpdatePaintNode
     // Follow the unmaplock logic inside QtWayland. If a surface is still
     // visible but has a null buffer attached, we retain the copy we have
     // until further notice...
-    QWlSurface_Accessor *s = static_cast<QWlSurface_Accessor *>(surface()->handle());
-    if (!s->surfaceBufferHandle() && s->mapped()) {
+    QWaylandSurfacePrivate *s = QWaylandSurfacePrivate::get(surface());
+    wl_resource *surfaceBufferHandle = s->bufferRef.hasBuffer() ? s->bufferRef.wl_buffer() : 0;
+    if (!surfaceBufferHandle && surface()->hasContent()) {
         qCDebug(LIPSTICK_LOG_HWC, " - visible with attached 'null' buffer, reusing previous buffer");
         return old;
     }
@@ -525,7 +494,7 @@ QSGNode *LipstickCompositorWindow::updatePaintNode(QSGNode *old, UpdatePaintNode
     // surface item. If this results in a null node, we abort.
     LipstickCompositorWindowHwcNode *hwcNode = old ? static_cast<LipstickCompositorWindowHwcNode *>(old) : 0;
     QSGNode *oldContentNode = hwcNode ? hwcNode->firstChild() : 0;
-    QSGNode *newContentNode = QWaylandSurfaceItem::updatePaintNode(oldContentNode, data);
+    QSGNode *newContentNode = QWaylandQuickItem::updatePaintNode(oldContentNode, data);
     if (!newContentNode) {
         delete old;
         return 0;
@@ -536,11 +505,11 @@ QSGNode *LipstickCompositorWindow::updatePaintNode(QSGNode *old, UpdatePaintNode
     EGLDisplay display = eglGetCurrentDisplay();
     EGLClientBuffer eglBuffer = 0;
     void *hwcHandle = 0;
-    if (!eglHybrisAcquireNativeBufferWL(display, s->surfaceBufferHandle(), &eglBuffer)) {
+    if (!eglHybrisAcquireNativeBufferWL(display, surfaceBufferHandle, &eglBuffer)) {
         qCDebug(LIPSTICK_LOG_HWC, " - failed to acquire native buffer (buffers are probably not allocated server-side)");
         m_noHardwareComposition = true;
         delete old;
-        return QWaylandSurfaceItem::updatePaintNode(0, data);
+        return QWaylandQuickItem::updatePaintNode(0, data);
     }
     eglHybrisNativeBufferHandle(eglGetCurrentDisplay(), eglBuffer, &hwcHandle);
     Q_ASSERT(hwcHandle);
@@ -552,7 +521,7 @@ QSGNode *LipstickCompositorWindow::updatePaintNode(QSGNode *old, UpdatePaintNode
 
     // Add the new content node. The old one, if present would already have
     // been removed because it was deleted in the
-    // QWaylandSurfaceItem::updatePaintNode() call above.
+    // QWaylandQuickItem::updatePaintNode() call above.
     if (newContentNode != hwcNode->firstChild())
         hwcNode->appendChildNode(newContentNode);
 
@@ -643,7 +612,7 @@ void hwc_windowsurface_release_native_buffer(void *, void *callbackData)
     QCoreApplication::postEvent(e->eventTarget, e);
 }
 
-void LipstickCompositorWindowHwcNode::update(QWlSurface_Accessor *s, EGLClientBuffer newBuffer, void *newHandle, QSGNode *contentNode)
+void LipstickCompositorWindowHwcNode::update(QWaylandSurfacePrivate *s, EGLClientBuffer newBuffer, void *newHandle, QSGNode *contentNode)
 {
     // If we're taking a new buffer into use when there already was
     // one, set up the old to be removed.
@@ -655,7 +624,7 @@ void LipstickCompositorWindowHwcNode::update(QWlSurface_Accessor *s, EGLClientBu
     }
     // qCDebug(LIPSTICK_LOG_HWC, " - setting buffers on HwcNode, EGLClientBuffer=%p, gralloc=%p", newBuffer, newHandle);
     eglBuffer = newBuffer;
-    waylandBuffer = QWaylandBufferRef(s->surfaceBuffer());
+    waylandBuffer = QWaylandBufferRef(s->bufferRef);
 
     Q_ASSERT(contentNode->type() == QSGNode::GeometryNodeType);
     HwcNode::update(static_cast<QSGGeometryNode *>(contentNode), newHandle);
diff --git a/src/compositor/lipstickcompositorwindow.h b/src/compositor/lipstickcompositorwindow.h
index 95ef721a..add20c90 100644
--- a/src/compositor/lipstickcompositorwindow.h
+++ b/src/compositor/lipstickcompositorwindow.h
@@ -16,14 +16,18 @@
 #ifndef LIPSTICKCOMPOSITORWINDOW_H
 #define LIPSTICKCOMPOSITORWINDOW_H
 
-#include <QWaylandSurfaceItem>
+#include <QWaylandQuickItem>
 #include <QWaylandBufferRef>
 #include <QPointer>
+#include <QWaylandWlShellSurface>
 #include "lipstickglobal.h"
 
+namespace QtWayland {
+    class ExtendedSurface;
+}
 class LipstickCompositorWindowHwcNode;
 
-class LIPSTICK_EXPORT LipstickCompositorWindow : public QWaylandSurfaceItem
+class LIPSTICK_EXPORT LipstickCompositorWindow : public QWaylandQuickItem
 {
     Q_OBJECT
 
@@ -37,12 +41,12 @@ class LIPSTICK_EXPORT LipstickCompositorWindow : public QWaylandSurfaceItem
     Q_PROPERTY(QString category READ category CONSTANT)
     Q_PROPERTY(QString title READ title NOTIFY titleChanged)
     Q_PROPERTY(qint64 processId READ processId CONSTANT)
+    Q_PROPERTY(qint16 windowFlags READ windowFlags NOTIFY windowFlagsChanged)
 
-    Q_PROPERTY(QRect mouseRegionBounds READ mouseRegionBounds NOTIFY mouseRegionBoundsChanged)
     Q_PROPERTY(bool focusOnTouch READ focusOnTouch WRITE setFocusOnTouch NOTIFY focusOnTouchChanged)
 
 public:
-    LipstickCompositorWindow(int windowId, const QString &, QWaylandQuickSurface *surface, QQuickItem *parent = 0);
+    LipstickCompositorWindow(int windowId, const QString &, QWaylandSurface *surface, QQuickItem *parent = 0);
     ~LipstickCompositorWindow();
 
     QVariant userData() const;
@@ -58,9 +62,7 @@ public:
     virtual QString title() const;
     virtual bool isInProcess() const;
 
-    bool isAlien() const;
-
-    QRect mouseRegionBounds() const;
+    qint16 windowFlags();
 
     bool eventFilter(QObject *object, QEvent *event);
 
@@ -71,6 +73,7 @@ public:
     bool focusOnTouch() const;
     void setFocusOnTouch(bool focusOnTouch);
 
+    QVariantMap windowProperties();
 
 protected:
     void itemChange(ItemChange change, const ItemChangeData &data);
@@ -86,9 +89,9 @@ signals:
     void userDataChanged();
     void titleChanged();
     void delayRemoveChanged();
-    void mouseRegionBoundsChanged();
     void committed();
     void focusOnTouchChanged();
+    void windowFlagsChanged();
 
 private slots:
     void handleTouchCancel();
@@ -97,6 +100,7 @@ private slots:
 
 private:
     friend class LipstickCompositor;
+    friend class WindowModel;
     friend class WindowPixmapItem;
     void imageAddref(QQuickItem *item);
     void imageRelease(QQuickItem *item);
@@ -104,31 +108,29 @@ private:
 
     bool canRemove() const;
     void tryRemove();
-    void refreshMouseRegion();
-    void refreshGrabbedKeys();
     void handleTouchEvent(QTouchEvent *e);
 
+    void setExtendedSurface(QtWayland::ExtendedSurface *extSurface);
+    QtWayland::ExtendedSurface *extendedSurface();
+    void setTitle(QString title);
+    QString m_title;
+
     int m_windowId;
     bool m_isAlien;
     QString m_category;
     bool m_delayRemove:1;
     bool m_windowClosed:1;
     bool m_removePosted:1;
-    bool m_mouseRegionValid:1;
     bool m_interceptingTouch:1;
     bool m_mapped : 1;
     bool m_noHardwareComposition: 1;
     bool m_focusOnTouch : 1;
     bool m_hasVisibleReferences : 1;
     QVariant m_data;
-    QRegion m_mouseRegion;
-    QList<int> m_grabbedKeys;
-    struct {
-        QPointer<QWaylandSurface> oldFocus;
-        QList<int> keys;
-    } m_pressedGrabbedKeys;
     QList<QMetaObject::Connection> m_surfaceConnections;
     QVector<QQuickItem *> m_refs;
+    QtWayland::ExtendedSurface *m_extSurface;
+    QWaylandWlShellSurface *m_wlShellSurface;
 };
 
 #endif // LIPSTICKCOMPOSITORWINDOW_H
diff --git a/src/compositor/lipstickkeymap.cpp b/src/compositor/lipstickkeymap.cpp
deleted file mode 100644
index 7eb5abaa..00000000
--- a/src/compositor/lipstickkeymap.cpp
+++ /dev/null
@@ -1,82 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2015 Jolla Ltd.
-** Contact: Andres Gomez <andres.gomez@jolla.com>
-**
-** This file is part of lipstick.
-**
-** This library is free software; you can redistribute it and/or
-** modify it under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation
-** and appearing in the file LICENSE.LGPL included in the packaging
-** of this file.
-**
-****************************************************************************/
-
-#include "lipstickkeymap.h"
-
-
-LipstickKeymap::LipstickKeymap(QObject *parent)
-    : QObject(parent)
-{
-    QWaylandKeymap keymap;
-    m_rules = keymap.rules();
-    m_model = keymap.model();
-    m_layout = keymap.layout();
-    m_variant = keymap.variant();
-    m_options = keymap.options();
-}
-
-LipstickKeymap::~LipstickKeymap()
-{
-}
-
-void LipstickKeymap::setRules(const QString &rules)
-{
-    if (m_rules != rules) {
-        m_rules = rules;
-        emit rulesChanged();
-    }
-}
-
-void LipstickKeymap::setModel(const QString &model)
-{
-    if (m_model != model) {
-        m_model = model;
-        emit modelChanged();
-    }
-}
-
-void LipstickKeymap::setLayout(const QString &layout)
-{
-    if (m_layout != layout) {
-        m_layout = layout;
-        emit layoutChanged();
-    }
-}
-
-void LipstickKeymap::setVariant(const QString &variant)
-{
-    if (m_variant != variant) {
-        m_variant = variant;
-        emit variantChanged();
-    }
-}
-
-void LipstickKeymap::setOptions(const QString &options)
-{
-    if (m_options != options) {
-        m_options = options;
-        emit optionsChanged();
-    }
-}
-
-bool operator!=(const LipstickKeymap &a, const LipstickKeymap &b)
-{
-    return a.rules() != b.rules() ||
-        a.model() != b.model() ||
-        a.layout() != b.layout() ||
-        a.variant() != b.variant() ||
-        a.options() != b.options();
-}
-
diff --git a/src/compositor/lipstickkeymap.h b/src/compositor/lipstickkeymap.h
deleted file mode 100644
index 5480061d..00000000
--- a/src/compositor/lipstickkeymap.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2015 Jolla Ltd.
-** Contact: Andres Gomez <andres.gomez@jolla.com>
-**
-** This file is part of lipstick.
-**
-** This library is free software; you can redistribute it and/or
-** modify it under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation
-** and appearing in the file LICENSE.LGPL included in the packaging
-** of this file.
-**
-****************************************************************************/
-
-#ifndef LIPSTICKKEYMAP_H
-#define LIPSTICKKEYMAP_H
-
-#include <QWaylandInputDevice>
-#include <QString>
-#include <QObject>
-#include "lipstickglobal.h"
-
-
-class LIPSTICK_EXPORT LipstickKeymap : public QObject
-{
-    Q_OBJECT
-
-    Q_PROPERTY(QString rules READ rules WRITE setRules NOTIFY rulesChanged)
-    Q_PROPERTY(QString model READ model WRITE setModel NOTIFY modelChanged)
-    Q_PROPERTY(QString layout READ layout WRITE setLayout NOTIFY layoutChanged)
-    Q_PROPERTY(QString variant READ variant WRITE setVariant NOTIFY variantChanged)
-    Q_PROPERTY(QString options READ options WRITE setOptions NOTIFY optionsChanged)
-
-public:
-    explicit LipstickKeymap(QObject *parent = 0);
-    ~LipstickKeymap();
-
-    inline QString rules() const { return m_rules; }
-    void setRules(const QString &rules);
-
-    inline QString model() const { return m_model; }
-    void setModel(const QString &model);
-
-    inline QString layout() const { return m_layout; }
-    void setLayout(const QString &layout);
-
-    inline QString variant() const { return m_variant; }
-    void setVariant(const QString &variant);
-
-    inline QString options() const { return m_options; }
-    void setOptions(const QString &options);
-
-    inline QWaylandKeymap waylandKeymap() const { return QWaylandKeymap(m_layout, m_variant, m_options, m_model, m_rules); };
-
-signals:
-    void rulesChanged();
-    void modelChanged();
-    void layoutChanged();
-    void variantChanged();
-    void optionsChanged();
-
-private:
-    QString m_layout;
-    QString m_variant;
-    QString m_options;
-    QString m_rules;
-    QString m_model;
-};
-
-bool operator!=(const LipstickKeymap &a, const LipstickKeymap &b);
-
-
-#endif // LIPSTICKKEYMAP_H
diff --git a/src/compositor/lipstickrecorder.cpp b/src/compositor/lipstickrecorder.cpp
deleted file mode 100644
index a7583635..00000000
--- a/src/compositor/lipstickrecorder.cpp
+++ /dev/null
@@ -1,195 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2014 Jolla Ltd.
-** Contact: Giulio Camuffo <giulio.camuffo@jollamobile.com>
-**
-** This file is part of lipstick.
-**
-** This library is free software; you can redistribute it and/or
-** modify it under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation
-** and appearing in the file LICENSE.LGPL included in the packaging
-** of this file.
-**
-****************************************************************************/
-
-#include <sys/time.h>
-#include <grp.h>
-
-#include <QMutexLocker>
-
-#include "lipstickrecorder.h"
-#include "lipstickcompositor.h"
-
-static uint32_t getTime()
-{
-    struct timeval tv;
-    gettimeofday(&tv, NULL);
-    return tv.tv_sec * 1000 + tv.tv_usec / 1000;
-}
-
-static const QEvent::Type FrameEventType = (QEvent::Type)QEvent::registerEventType();
-static const QEvent::Type FailedEventType = (QEvent::Type)QEvent::registerEventType();
-
-class FrameEvent : public QEvent
-{
-public:
-    FrameEvent(uint32_t t)
-        : QEvent(FrameEventType)
-        , time(t)
-    { }
-    uint32_t time;
-};
-
-class FailedEvent : public QEvent
-{
-public:
-    FailedEvent(int r)
-        : QEvent(FailedEventType)
-        , result(r)
-    { }
-    int result;
-};
-
-LipstickRecorderManager::LipstickRecorderManager()
-                       : QWaylandGlobalInterface()
-{
-}
-
-const wl_interface* LipstickRecorderManager::interface() const
-{
-    return &lipstick_recorder_manager_interface;
-}
-
-void LipstickRecorderManager::recordFrame(QWindow *window)
-{
-    QMutexLocker lock(&m_mutex);
-    if (m_requests.isEmpty())
-        return;
-
-    uchar *pixels;
-    uint32_t time = getTime();
-    foreach (LipstickRecorder *recorder, m_requests.values(window)) {
-        wl_shm_buffer *buffer = recorder->buffer();
-        pixels = static_cast<uchar *>(wl_shm_buffer_get_data(buffer));
-        int width = wl_shm_buffer_get_width(buffer);
-        int height = wl_shm_buffer_get_height(buffer);
-        int stride = wl_shm_buffer_get_stride(buffer);
-        int bpp = 4;
-
-        if (width < window->width() || height < window->height() || stride < window->width() * bpp) {
-            qApp->postEvent(recorder, new FailedEvent(QtWaylandServer::lipstick_recorder::result_bad_buffer));
-            continue;
-        }
-
-        glPixelStorei(GL_PACK_ALIGNMENT, 1);
-        glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
-        qApp->postEvent(recorder, new FrameEvent(time));
-
-        m_requests.remove(window, recorder);
-    }
-}
-
-void LipstickRecorderManager::requestFrame(QWindow *window, LipstickRecorder *recorder)
-{
-    QMutexLocker lock(&m_mutex);
-    m_requests.insert(window, recorder);
-}
-
-void LipstickRecorderManager::remove(QWindow *window, LipstickRecorder *recorder)
-{
-    QMutexLocker lock(&m_mutex);
-    m_requests.remove(window, recorder);
-}
-
-void LipstickRecorderManager::bind(wl_client *client, quint32 version, quint32 id)
-{
-    Q_UNUSED(version)
-
-    Resource *res = add(client, id, version);
-
-    gid_t gid;
-    wl_client_get_credentials(client, Q_NULLPTR, Q_NULLPTR, &gid);
-    group *g = getgrgid(gid);
-    if (strcmp(g->gr_name, "privileged") != 0) {
-        wl_resource_post_error(res->handle, WL_DISPLAY_ERROR_INVALID_OBJECT, "Permission to bind lipstick_recorder_manager denied");
-        wl_resource_destroy(res->handle);
-    }
-}
-
-void LipstickRecorderManager::lipstick_recorder_manager_create_recorder(Resource *resource, uint32_t id, ::wl_resource *output)
-{
-    // TODO: we should find out the window associated with this output, but there isn't
-    // a way to do that in qtcompositor yet. Just ignore it for now and use the one window we have.
-    Q_UNUSED(output)
-
-    new LipstickRecorder(this, resource->client(), id, LipstickCompositor::instance());
-}
-
-
-LipstickRecorder::LipstickRecorder(LipstickRecorderManager *manager, wl_client *client, quint32 id, QQuickWindow *window)
-                : QtWaylandServer::lipstick_recorder(client, id, 1)
-                , m_manager(manager)
-                , m_bufferResource(Q_NULLPTR)
-                , m_client(client)
-                , m_window(window)
-{
-    send_setup(window->width(), window->height(), window->width() * 4, WL_SHM_FORMAT_RGBA8888);
-}
-
-LipstickRecorder::~LipstickRecorder()
-{
-    m_manager->remove(m_window, this);
-}
-
-void LipstickRecorder::lipstick_recorder_destroy_resource(Resource *resource)
-{
-    Q_UNUSED(resource)
-    delete this;
-}
-
-void LipstickRecorder::lipstick_recorder_destroy(Resource *resource)
-{
-    wl_resource_destroy(resource->handle);
-}
-
-void LipstickRecorder::lipstick_recorder_record_frame(Resource *resource, ::wl_resource *buffer)
-{
-    Q_UNUSED(resource)
-    if (m_bufferResource) {
-        send_cancelled(buffer);
-    }
-    m_bufferResource = buffer;
-    m_buffer = wl_shm_buffer_get(buffer);
-    if (m_buffer) {
-        m_manager->requestFrame(m_window, this);
-    } else {
-        m_bufferResource = Q_NULLPTR;
-        send_failed(result_bad_buffer, buffer);
-    }
-}
-
-void LipstickRecorder::lipstick_recorder_repaint(Resource *resource)
-{
-    Q_UNUSED(resource)
-    if (m_bufferResource) {
-        m_window->update();
-    }
-}
-
-bool LipstickRecorder::event(QEvent *e)
-{
-    if (e->type() == FrameEventType) {
-        FrameEvent *fe = static_cast<FrameEvent *>(e);
-        send_frame(m_bufferResource, fe->time, QtWaylandServer::lipstick_recorder::transform_y_inverted);
-    } else if (e->type() == FailedEventType) {
-        FailedEvent *fe = static_cast<FailedEvent *>(e);
-        send_failed(fe->result, m_bufferResource);
-    } else {
-        return QObject::event(e);
-    }
-
-    m_bufferResource = Q_NULLPTR;
-    wl_client_flush(client());
-    return true;
-}
diff --git a/src/compositor/lipstickrecorder.h b/src/compositor/lipstickrecorder.h
deleted file mode 100644
index 8a4cc433..00000000
--- a/src/compositor/lipstickrecorder.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2014 Jolla Ltd.
-** Contact: Giulio Camuffo <giulio.camuffo@jollamobile.com>
-**
-** This file is part of lipstick.
-**
-** This library is free software; you can redistribute it and/or
-** modify it under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation
-** and appearing in the file LICENSE.LGPL included in the packaging
-** of this file.
-**
-****************************************************************************/
-
-#ifndef LIPSTICKCOMPOSITORRECORDER_H
-#define LIPSTICKCOMPOSITORRECORDER_H
-
-#include <QObject>
-#include <QMultiHash>
-#include <QMutex>
-#include <QWaylandGlobalInterface>
-
-#include "qwayland-server-lipstick-recorder.h"
-
-struct wl_shm_buffer;
-struct wl_client;
-
-class QWindow;
-class QQuickWindow;
-class QEvent;
-class LipstickRecorder;
-
-class LipstickRecorderManager : public QWaylandGlobalInterface, public QtWaylandServer::lipstick_recorder_manager
-{
-public:
-    LipstickRecorderManager();
-
-    const wl_interface* interface() const Q_DECL_OVERRIDE;
-
-    void recordFrame(QWindow *window);
-    void requestFrame(QWindow *window, LipstickRecorder *recorder);
-    void remove(QWindow *window, LipstickRecorder *recorder);
-
-protected:
-    void bind(wl_client *client, quint32 version, quint32 id) Q_DECL_OVERRIDE;
-    void lipstick_recorder_manager_create_recorder(Resource *resource, uint32_t id, ::wl_resource *output) Q_DECL_OVERRIDE;
-
-private:
-    QMultiHash<QWindow *, LipstickRecorder *> m_requests;
-    QMutex m_mutex;
-};
-
-class LipstickRecorder : public QObject, public QtWaylandServer::lipstick_recorder
-{
-public:
-    LipstickRecorder(LipstickRecorderManager *manager, wl_client *client, quint32 id, QQuickWindow *window);
-    ~LipstickRecorder();
-
-    wl_shm_buffer *buffer() const { return m_buffer; }
-    wl_client *client() const { return m_client; }
-
-protected:
-    bool event(QEvent *e) Q_DECL_OVERRIDE;
-    void lipstick_recorder_destroy_resource(Resource *resource) Q_DECL_OVERRIDE;
-    void lipstick_recorder_destroy(Resource *resource) Q_DECL_OVERRIDE;
-    void lipstick_recorder_record_frame(Resource *resource, ::wl_resource *buffer) Q_DECL_OVERRIDE;
-    void lipstick_recorder_repaint(Resource *resource) Q_DECL_OVERRIDE;
-
-private:
-    LipstickRecorderManager *m_manager;
-    wl_resource *m_bufferResource;
-    wl_shm_buffer *m_buffer;
-    wl_client *m_client;
-    QQuickWindow *m_window;
-};
-
-#endif
diff --git a/src/compositor/lipsticksurfaceinterface.cpp b/src/compositor/lipsticksurfaceinterface.cpp
deleted file mode 100644
index 4134ae81..00000000
--- a/src/compositor/lipsticksurfaceinterface.cpp
+++ /dev/null
@@ -1,22 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2014 Jolla Ltd.
-** Contact: Giulio Camuffo <giulio.camuffo@jollamobile.com>
-**
-** This file is part of lipstick.
-**
-** This library is free software; you can redistribute it and/or
-** modify it under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation
-** and appearing in the file LICENSE.LGPL included in the packaging
-** of this file.
-**
-****************************************************************************/
-
-#include "lipsticksurfaceinterface.h"
-
-LipstickOomScoreOp::LipstickOomScoreOp(int score)
-                  : QWaylandSurfaceOp((QWaylandSurfaceOp::Type)Type)
-                  , m_score(score)
-{
-}
diff --git a/src/compositor/lipsticksurfaceinterface.h b/src/compositor/lipsticksurfaceinterface.h
deleted file mode 100644
index 85d02655..00000000
--- a/src/compositor/lipsticksurfaceinterface.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2014 Jolla Ltd.
-** Contact: Giulio Camuffo <giulio.camuffo@jollamobile.com>
-**
-** This file is part of lipstick.
-**
-** This library is free software; you can redistribute it and/or
-** modify it under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation
-** and appearing in the file LICENSE.LGPL included in the packaging
-** of this file.
-**
-****************************************************************************/
-
-#ifndef LIPSTICKSURFACEINTERFACE
-#define LIPSTICKSURFACEINTERFACE
-
-#include <QtCompositor/QWaylandSurfaceInterface>
-
-#include "lipstickglobal.h"
-
-class LIPSTICK_EXPORT LipstickOomScoreOp : public QWaylandSurfaceOp
-{
-public:
-    enum { Type = QWaylandSurfaceOp::UserType + 1 };
-    LipstickOomScoreOp(int score);
-
-    int score() const { return m_score; }
-
-private:
-    int m_score;
-};
-
-#endif
diff --git a/src/compositor/windowmodel.cpp b/src/compositor/windowmodel.cpp
index 7ecd4d4b..245e23a2 100644
--- a/src/compositor/windowmodel.cpp
+++ b/src/compositor/windowmodel.cpp
@@ -14,6 +14,7 @@
 ****************************************************************************/
 
 #include <QDBusConnection>
+#include <QtWaylandCompositor/private/qwlextendedsurface_p.h>
 #include "lipstickcompositorwindow.h"
 #include "lipstickcompositor.h"
 #include "windowmodel.h"
@@ -68,7 +69,7 @@ QVariant WindowModel::data(const QModelIndex &index, int role) const
         return m_items.at(idx);
     } else if (role == Qt::UserRole + 2) {
         QWaylandSurface *s = c->surfaceForId(m_items.at(idx));
-        return s?s->processId():0;
+        return s?s->client()->processId():0;
     } else if (role == Qt::UserRole + 3) {
         LipstickCompositorWindow *w = static_cast<LipstickCompositorWindow *>(c->windowForId(m_items.at(idx)));
         return w->title();
@@ -101,7 +102,7 @@ void WindowModel::componentComplete()
 */
 bool WindowModel::approveWindow(LipstickCompositorWindow *window)
 {
-    return window->isInProcess() == false && 
+    return window && window->isInProcess() == false &&
         window->category() != QLatin1String("overlay");
 }
 
@@ -219,7 +220,7 @@ void WindowModel::launchProcess(const QString &binaryName)
         }
 
         if (match) {
-            win->surface()->raiseRequested();
+            emit win->extendedSurface()->raiseRequested();
             break;
         }
     }
diff --git a/src/compositor/windowpixmapitem.cpp b/src/compositor/windowpixmapitem.cpp
index 1d4fd165..36dc2420 100644
--- a/src/compositor/windowpixmapitem.cpp
+++ b/src/compositor/windowpixmapitem.cpp
@@ -13,355 +13,15 @@
 **
 ****************************************************************************/
 
-#include <QtCore/qmath.h>
-#include <QSGGeometryNode>
-#include <QSGSimpleMaterial>
-#include <QOpenGLFramebufferObject>
-#include <QWaylandSurfaceItem>
-#include "lipstickcompositorwindow.h"
-#include "lipstickcompositor.h"
 #include "windowpixmapitem.h"
+#include "lipstickcompositor.h"
+#include "lipstickcompositorwindow.h"
+#include <QDebug>
 
-namespace {
-
-class SurfaceTextureState {
-public:
-    SurfaceTextureState() : m_texture(0), m_xScale(1), m_yScale(1) {}
-    void setTexture(QSGTexture *texture) { m_texture = texture; }
-    QSGTexture *texture() const { return m_texture; }
-    void setXOffset(float xOffset) { m_xOffset = xOffset; }
-    float xOffset() const { return m_xOffset; }
-    void setYOffset(float yOffset) { m_yOffset = yOffset; }
-    float yOffset() const { return m_yOffset; }
-    void setXScale(float xScale) { m_xScale = xScale; }
-    float xScale() const { return m_xScale; }
-    void setYScale(float yScale) { m_yScale = yScale; }
-    float yScale() const { return m_yScale; }
-
-private:
-    QSGTexture *m_texture;
-    float m_xOffset;
-    float m_yOffset;
-    float m_xScale;
-    float m_yScale;
-};
-
-class SurfaceTextureMaterial : public QSGSimpleMaterialShader<SurfaceTextureState>
-{
-    QSG_DECLARE_SIMPLE_SHADER(SurfaceTextureMaterial, SurfaceTextureState)
-public:
-    QList<QByteArray> attributes() const;
-    void updateState(const SurfaceTextureState *newState, const SurfaceTextureState *oldState);
-protected:
-    void initialize();
-    const char *vertexShader() const;
-    const char *fragmentShader() const;
-private:
-    int m_id_texOffset;
-    int m_id_texScale;
-};
-
-class SurfaceNode : public QObject, public QSGGeometryNode
-{
-    Q_OBJECT
-public:
-    SurfaceNode();
-    ~SurfaceNode();
-    void setRect(const QRectF &);
-    void setTextureProvider(QSGTextureProvider *, bool owned);
-    void setBlending(bool);
-    void setRadius(qreal radius);
-    void setXOffset(qreal xOffset);
-    void setYOffset(qreal yOffset);
-    void setXScale(qreal xScale);
-    void setYScale(qreal yScale);
-    void setUpdateTexture(bool upd);
-
-private slots:
-    void providerDestroyed();
-    void textureChanged();
-
-private:
-    void setTexture(QSGTexture *texture);
-    void updateGeometry();
-
-    QSGSimpleMaterial<SurfaceTextureState> *m_material;
-    QRectF m_rect;
-    qreal m_radius;
-
-    QSGTextureProvider *m_provider;
-    QSGTexture *m_texture;
-    QSGGeometry m_geometry;
-    QRectF m_textureRect;
-    bool m_providerOwned;
-};
-
-QList<QByteArray> SurfaceTextureMaterial::attributes() const
-{
-    QList<QByteArray> attributeList;
-    attributeList << "qt_VertexPosition";
-    attributeList << "qt_VertexTexCoord";
-    return attributeList;
-}
-
-void SurfaceTextureMaterial::updateState(const SurfaceTextureState *newState,
-                                         const SurfaceTextureState *)
-{
-    Q_ASSERT(newState->texture());
-    if (QSGTexture *tex = newState->texture())
-        tex->bind();
-    program()->setUniformValue(m_id_texOffset, newState->xOffset(), newState->yOffset());
-    program()->setUniformValue(m_id_texScale, newState->xScale(), newState->yScale());
-}
-
-void SurfaceTextureMaterial::initialize()
-{
-    QSGSimpleMaterialShader::initialize();
-    m_id_texOffset = program()->uniformLocation("texOffset");
-    m_id_texScale = program()->uniformLocation("texScale");
-}
-
-const char *SurfaceTextureMaterial::vertexShader() const
-{
-    return "uniform highp mat4 qt_Matrix;                      \n"
-           "attribute highp vec4 qt_VertexPosition;            \n"
-           "attribute highp vec2 qt_VertexTexCoord;            \n"
-           "varying highp vec2 qt_TexCoord;                    \n"
-           "uniform highp vec2 texOffset;                      \n"
-           "uniform highp vec2 texScale;                       \n"
-           "void main() {                                      \n"
-           "    qt_TexCoord = qt_VertexTexCoord * texScale + texOffset;\n"
-           "    gl_Position = qt_Matrix * qt_VertexPosition;   \n"
-           "}";
-}
-
-const char *SurfaceTextureMaterial::fragmentShader() const
-{
-    return "varying highp vec2 qt_TexCoord;                    \n"
-           "uniform sampler2D qt_Texture;                      \n"
-           "uniform lowp float qt_Opacity;                     \n"
-           "void main() {                                      \n"
-           "    gl_FragColor = texture2D(qt_Texture, qt_TexCoord) * qt_Opacity; \n"
-           "}";
-}
-
-SurfaceNode::SurfaceNode()
-: m_material(0), m_radius(0), m_provider(0), m_texture(0),
-  m_geometry(QSGGeometry::defaultAttributes_TexturedPoint2D(), 0)
-{
-    setGeometry(&m_geometry);
-    m_material = SurfaceTextureMaterial::createMaterial();
-    setMaterial(m_material);
-}
-
-SurfaceNode::~SurfaceNode()
-{
-    if (m_provider && m_providerOwned)
-        delete m_provider;
-}
-
-void SurfaceNode::setRect(const QRectF &r)
-{
-    if (m_rect == r)
-        return;
-
-    m_rect = r;
-
-    updateGeometry();
-}
-
-void SurfaceNode::setTextureProvider(QSGTextureProvider *p, bool owned)
-{
-    if (p == m_provider)
-        return;
-
-    if (m_provider) {
-        QObject::disconnect(m_provider, SIGNAL(destroyed(QObject *)), this, SLOT(providerDestroyed()));
-        QObject::disconnect(m_provider, SIGNAL(textureChanged()), this, SLOT(textureChanged()));
-        m_provider = 0;
-    }
-
-    m_provider = p;
-    m_providerOwned = owned;
-
-    if (m_provider) {
-        QObject::connect(m_provider, SIGNAL(destroyed(QObject *)), this, SLOT(providerDestroyed()));
-        QObject::connect(m_provider, SIGNAL(textureChanged()), this, SLOT(textureChanged()));
-
-        setTexture(m_provider->texture());
-    }
-}
-
-void SurfaceNode::updateGeometry()
-{
-    if (m_texture) {
-        QSize ts = m_texture->textureSize();
-        QRectF sourceRect(0, 0, ts.width(), ts.height());
-        QRectF textureRect = m_texture->convertToNormalizedSourceRect(sourceRect);
-
-        if (m_radius) {
-            float radius = qMin(float(qMin(m_rect.width(), m_rect.height()) * 0.5f), float(m_radius));
-            int segments = qBound(5, qCeil(radius * (M_PI / 6)), 18);
-            float angle = 0.5f * float(M_PI) / segments;
-
-            m_geometry.allocate((segments + 1) * 2 * 2);
-
-            QSGGeometry::TexturedPoint2D *v = m_geometry.vertexDataAsTexturedPoint2D();
-            QSGGeometry::TexturedPoint2D *vlast = v + (segments + 1) * 2 * 2 - 2;
-
-            float textureXRadius = radius * textureRect.width() / m_rect.width();
-            float textureYRadius = radius * textureRect.height() / m_rect.height();
-
-            float c = 1; float cosStep = qFastCos(angle);
-            float s = 0; float sinStep = qFastSin(angle);
-
-            for (int ii = 0; ii <= segments; ++ii) {
-                float px = m_rect.left() + radius - radius * c;
-                float tx = textureRect.left() + textureXRadius - textureXRadius * c;
-
-                float px2 = m_rect.right() - radius + radius * c;
-                float tx2 = textureRect.right() - textureXRadius + textureXRadius * c;
-
-                float py = m_rect.top() + radius - radius * s;
-                float ty = textureRect.top() + textureYRadius - textureYRadius * s;
-
-                float py2 = m_rect.bottom() - radius + radius * s;
-                float ty2 = textureRect.bottom() - textureYRadius + textureYRadius * s;
-
-                v[0].x = px; v[0].y = py;
-                v[0].tx = tx; v[0].ty = ty;
-
-                v[1].x = px; v[1].y = py2;
-                v[1].tx = tx; v[1].ty = ty2;
-
-                vlast[0].x = px2; vlast[0].y = py;
-                vlast[0].tx = tx2; vlast[0].ty = ty;
-
-                vlast[1].x = px2; vlast[1].y = py2;
-                vlast[1].tx = tx2; vlast[1].ty = ty2;
-
-                v += 2;
-                vlast -= 2;
-
-                float t = c;
-                c = c * cosStep - s * sinStep;
-                s = s * cosStep + t * sinStep;
-            }
-        } else {
-            m_geometry.allocate(4);
-            QSGGeometry::updateTexturedRectGeometry(&m_geometry, m_rect, textureRect);
-        }
-
-        markDirty(DirtyGeometry);
-    }
-}
-
-void SurfaceNode::setBlending(bool b)
-{
-    m_material->setFlag(QSGMaterial::Blending, b);
-}
-
-void SurfaceNode::setRadius(qreal radius)
-{
-    if (m_radius == radius)
-        return;
-
-    m_radius = radius;
-
-    updateGeometry();
-}
-
-void SurfaceNode::setTexture(QSGTexture *texture)
-{
-    m_material->state()->setTexture(texture);
-
-    QRectF tr;
-    if (texture) tr = texture->convertToNormalizedSourceRect(QRect(QPoint(0,0), texture->textureSize()));
-
-    bool ug = !m_texture || tr != m_textureRect;
-
-    m_texture = texture;
-    m_textureRect = tr;
-
-    if (ug) updateGeometry();
-
-    markDirty(DirtyMaterial);
-}
-
-void SurfaceNode::setXOffset(qreal offset)
-{
-    m_material->state()->setXOffset(offset);
-
-    markDirty(DirtyMaterial);
-}
-
-void SurfaceNode::setYOffset(qreal offset)
-{
-    m_material->state()->setYOffset(offset);
-
-    markDirty(DirtyMaterial);
-}
-
-void SurfaceNode::setXScale(qreal xScale)
-{
-    m_material->state()->setXScale(xScale);
-
-    markDirty(DirtyMaterial);
-}
-
-void SurfaceNode::setYScale(qreal yScale)
-{
-    m_material->state()->setYScale(yScale);
-
-    markDirty(DirtyMaterial);
-}
-
-void SurfaceNode::textureChanged()
-{
-    setTexture(m_provider->texture());
-}
-
-void SurfaceNode::providerDestroyed()
-{
-    m_provider = 0;
-    setTexture(0);
-}
-
-}
-
-SnapshotProgram *WindowPixmapItem::s_snapshotProgram = 0;
-
-struct SnapshotProgram
-{
-    QOpenGLShaderProgram program;
-    int vertexLocation;
-    int textureLocation;
-};
-
-class SnapshotTextureProvider : public QSGTextureProvider
-{
-public:
-    SnapshotTextureProvider() : t(0), fbo(0) {}
-    ~SnapshotTextureProvider()
-    {
-        delete fbo;
-        delete t;
-    }
-    QSGTexture *texture() const Q_DECL_OVERRIDE
-    {
-        return t;
-    }
-    QSGTexture *t;
-    QOpenGLFramebufferObject *fbo;
-};
-
-
-WindowPixmapItem::WindowPixmapItem()
-: m_item(0), m_shaderEffect(0), m_id(0), m_opaque(false), m_radius(0), m_xOffset(0), m_yOffset(0)
-, m_xScale(1), m_yScale(1), m_unmapLock(0), m_hasBuffer(false), m_hasPixmap(false), m_surfaceDestroyed(false), m_haveSnapshot(false)
-, m_textureProvider(0)
+WindowPixmapItem::WindowPixmapItem() : m_id(0)
 {
-    setFlag(ItemHasContents);
+    setSizeFollowsSurface(false);
+    setEnabled(false);
 }
 
 WindowPixmapItem::~WindowPixmapItem()
@@ -378,384 +38,14 @@ void WindowPixmapItem::setWindowId(int id)
 {
     if (m_id == id)
         return;
-
-    QSize oldSize = windowSize();
-    if (m_item) {
-        disconnect(m_item.data(), &QObject::destroyed, this, &WindowPixmapItem::itemDestroyed);
-        if (m_item->surface()) {
-            disconnect(m_item->surface(), &QWaylandSurface::sizeChanged, this, &WindowPixmapItem::handleWindowSizeChanged);
-            disconnect(m_item->surface(), &QWaylandSurface::configure, this, &WindowPixmapItem::configure);
-            disconnect(m_item.data(), &QWaylandSurfaceItem::surfaceDestroyed, this, &WindowPixmapItem::surfaceDestroyed);
-        }
-        if (!m_surfaceDestroyed)
-            m_item->imageRelease(this);
-        m_item->setDelayRemove(false);
-        m_item = 0;
-        delete m_unmapLock;
-        m_unmapLock = 0;
-    }
-
-    m_surfaceDestroyed = false;
-    m_hasBuffer = false;
     m_id = id;
-    updateItem();
-
-    emit windowIdChanged();
-    if (windowSize() != oldSize)
-        emit windowSizeChanged();
-}
-
-void WindowPixmapItem::surfaceDestroyed()
-{
-    m_surfaceDestroyed = true;
-    m_hasBuffer = false;
-    m_unmapLock = new QWaylandUnmapLock(m_item->surface());
-    m_item->imageRelease(this);
-    update();
-}
-
-bool WindowPixmapItem::hasPixmap() const
-{
-    return m_hasPixmap;
-}
-
-bool WindowPixmapItem::opaque() const
-{
-    return m_opaque;
-}
-
-void WindowPixmapItem::setOpaque(bool o)
-{
-    if (m_opaque == o)
-        return;
-
-    m_opaque = o;
-    if (m_item) update();
-
-    emit opaqueChanged();
-}
-
-qreal WindowPixmapItem::radius() const
-{
-    return m_radius;
-}
-
-void WindowPixmapItem::setRadius(qreal r)
-{
-    if (m_radius == r)
-        return;
-
-    m_radius = r;
-    if (m_item) update();
-
-    emit radiusChanged();
-}
-
-qreal WindowPixmapItem::xOffset() const
-{
-    return m_xOffset;
-}
-
-void WindowPixmapItem::setXOffset(qreal xOffset)
-{
-    if (m_xOffset == xOffset)
-        return;
-
-    m_xOffset = xOffset;
-    if (m_item) update();
-
-    emit xOffsetChanged();
-}
-
-qreal WindowPixmapItem::yOffset() const
-{
-    return m_yOffset;
-}
-
-void WindowPixmapItem::setYOffset(qreal yOffset)
-{
-    if (m_yOffset == yOffset)
-        return;
-
-    m_yOffset = yOffset;
-    if (m_item) update();
-
-    emit yOffsetChanged();
-}
-
-qreal WindowPixmapItem::xScale() const
-{
-    return m_xScale;
-}
-
-void WindowPixmapItem::setXScale(qreal xScale)
-{
-    if (m_xScale == xScale)
-        return;
-
-    m_xScale = xScale;
-    if (m_item || m_haveSnapshot) update();
-
-    emit xScaleChanged();
-}
-
-qreal WindowPixmapItem::yScale() const
-{
-    return m_yScale;
-}
-
-void WindowPixmapItem::setYScale(qreal yScale)
-{
-    if (m_yScale == yScale)
-        return;
-
-    m_yScale = yScale;
-    if (m_item || m_haveSnapshot) update();
-
-    emit yScaleChanged();
-}
-
-QSize WindowPixmapItem::windowSize() const
-{
-    return m_windowSize;
-}
-
-void WindowPixmapItem::setWindowSize(const QSize &s)
-{
-    if (!m_item || !m_item->surface()) {
-        return;
-    }
-
-    m_item->surface()->requestSize(s);
-}
-
-void WindowPixmapItem::handleWindowSizeChanged()
-{
-    if (m_item->surface()->size().isValid()) {
-        // Window size is retained even when surface is destroyed. This allows snapshots to continue
-        // rendering correctly.
-        m_windowSize = m_item->surface()->size();
-        emit windowSizeChanged();
-    }
-}
-
-void WindowPixmapItem::itemDestroyed(QObject *)
-{
-    m_item = 0;
-    if (!m_haveSnapshot) {
-        m_hasPixmap = false;
-        emit hasPixmapChanged();
-    }
-}
-
-QSGNode *WindowPixmapItem::updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *)
-{
-    SurfaceNode *node = static_cast<SurfaceNode *>(oldNode);
-
-    if (m_item == 0 && !m_haveSnapshot) {
-        if (node)
-            node->setTextureProvider(0, false);
-        delete node;
-        return 0;
-    }
-
-    QSGTextureProvider *provider = 0;
-    QSGTexture *texture = 0;
-    if (m_item) {
-        provider = m_item->textureProvider();
-        texture = provider->texture();
-        if (texture && !m_surfaceDestroyed) {
-            m_haveSnapshot = false;
-        }
-    }
-
-    if (!m_hasBuffer && texture) {
-        if (!m_textureProvider) {
-            SnapshotTextureProvider *prov = new SnapshotTextureProvider;
-            m_textureProvider = prov;
-
-            if (!s_snapshotProgram) {
-                s_snapshotProgram = new SnapshotProgram;
-                s_snapshotProgram->program.addShaderFromSourceCode(QOpenGLShader::Vertex,
-                    "attribute highp vec4 vertex;\n"
-                    "varying highp vec2 texPos;\n"
-                    "void main(void) {\n"
-                    "   texPos = vertex.xy;\n"
-                    "   gl_Position = vec4(vertex.xy * 2.0 - 1.0, 0, 1);\n"
-                    "}");
-                s_snapshotProgram->program.addShaderFromSourceCode(QOpenGLShader::Fragment,
-                    "uniform sampler2D texture;\n"
-                    "varying highp vec2 texPos;\n"
-                    "void main(void) {\n"
-                    "   gl_FragColor = texture2D(texture, texPos);\n"
-                    "}");
-                if (!s_snapshotProgram->program.link())
-                    qDebug() << s_snapshotProgram->program.log();
-
-                s_snapshotProgram->vertexLocation = s_snapshotProgram->program.attributeLocation("vertex");
-                s_snapshotProgram->textureLocation = s_snapshotProgram->program.uniformLocation("texture");
-
-                connect(window(), &QQuickWindow::sceneGraphInvalidated, this, &WindowPixmapItem::cleanupOpenGL);
-            }
-        }
-        provider = m_textureProvider;
-
-        if (m_unmapLock) {
-            SnapshotTextureProvider *prov = static_cast<SnapshotTextureProvider *>(provider);
-
-            if (!prov->fbo || prov->fbo->size() != QSize(width(), height())) {
-                delete prov->fbo;
-                delete prov->t;
-                prov->t = 0;
-                prov->fbo = new QOpenGLFramebufferObject(width(), height());
-            }
-
-            prov->fbo->bind();
-            s_snapshotProgram->program.bind();
-
-            texture->bind();
-
-            static GLfloat const triangleVertices[] = {
-                1.f, 0.f,
-                1.f, 1.f,
-                0.f, 0.f,
-                0.f, 1.f,
-            };
-            s_snapshotProgram->program.enableAttributeArray(s_snapshotProgram->vertexLocation);
-            s_snapshotProgram->program.setAttributeArray(s_snapshotProgram->vertexLocation, triangleVertices, 2);
-
-            glViewport(0, 0, width(), height());
-            glDisable(GL_BLEND);
-            glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
-
-            s_snapshotProgram->program.release();
-
-            if (!prov->t) {
-                prov->t = window()->createTextureFromId(prov->fbo->texture(), prov->fbo->size(), 0);
-                emit prov->textureChanged();
-            }
-            prov->fbo->release();
-            delete m_unmapLock;
-            m_unmapLock = 0;
-            s_snapshotProgram->program.disableAttributeArray(s_snapshotProgram->vertexLocation);
-
-            m_haveSnapshot = true;
-        }
-    } else if (!m_hasBuffer && m_textureProvider) {
-        provider = m_textureProvider;
-    } else if (!provider) {
-        if (node)
-            node->setTextureProvider(0, false);
-        delete node;
-        return 0;
-    }
-    // The else case here is no buffer and no screenshot, so no way to show a sane image.
-    // It should normally not happen, though.
-
-    if (provider != m_textureProvider) {
-        delete m_textureProvider;
-        m_textureProvider = 0;
-    }
-
-    if (m_surfaceDestroyed && m_item) {
-        m_item->setDelayRemove(false);
-    }
-
-    if (!provider->texture()) {
-        qWarning("WindowPixmapItem does not have a source texture, cover will be dropped..");
-        if (node) {
-            node->setTextureProvider(0, false);
-            delete node;
-        }
-        return 0;
-    }
-
-    if (!node) node = new SurfaceNode;
-
-    node->setTextureProvider(provider, provider == m_textureProvider);
-    node->setRect(QRectF(0, 0, width(), height()));
-    node->setBlending(!m_opaque);
-    node->setRadius(m_radius);
-    node->setXOffset(m_xOffset);
-    node->setYOffset(m_yOffset);
-    node->setXScale(m_xScale);
-    node->setYScale(m_yScale);
-
-    return node;
-}
-
-void WindowPixmapItem::geometryChanged(const QRectF &n, const QRectF &o)
-{
-    QQuickItem::geometryChanged(n, o);
-
-    if (m_shaderEffect) m_shaderEffect->setSize(n.size());
-}
-
-void WindowPixmapItem::updateItem()
-{
     LipstickCompositor *c = LipstickCompositor::instance();
-    Q_ASSERT(m_item == 0);
-
     if (c && m_id) {
         LipstickCompositorWindow *w = static_cast<LipstickCompositorWindow *>(c->windowForId(m_id));
 
-        if (!w) {
-            delete m_shaderEffect;
-            m_shaderEffect = 0;
-            if (m_hasPixmap && !m_haveSnapshot) {
-                m_hasPixmap = false;
-                emit hasPixmapChanged();
-            }
-            return;
-        } else if (w->surface()) {
-            m_item = w;
-            delete m_shaderEffect; m_shaderEffect = 0;
-            m_item->setDelayRemove(true);
-            connect(m_item->surface(), &QWaylandSurface::sizeChanged, this, &WindowPixmapItem::handleWindowSizeChanged);
-            connect(m_item->surface(), &QWaylandSurface::configure, this, &WindowPixmapItem::configure);
-            connect(m_item.data(), &QWaylandSurfaceItem::surfaceDestroyed, this, &WindowPixmapItem::surfaceDestroyed);
-            connect(m_item.data(), &QObject::destroyed, this, &WindowPixmapItem::itemDestroyed);
-            m_windowSize = m_item->surface()->size();
-            m_unmapLock = new QWaylandUnmapLock(m_item->surface());
-        } else {
-            if (!m_shaderEffect) {
-                m_shaderEffect = static_cast<QQuickItem *>(c->shaderEffectComponent()->create());
-                Q_ASSERT(m_shaderEffect);
-                m_shaderEffect->setParentItem(this);
-                m_shaderEffect->setSize(QSizeF(width(), height()));
-            }
-
-            m_shaderEffect->setProperty("window", qVariantFromValue((QObject *)w));
-        }
-
-        w->imageAddref(this);
-
-        update();
+        if (w)
+            setSurface(w->surface());
     }
-
-    const bool hadPixmap = m_hasPixmap;
-    m_hasPixmap = m_item || m_haveSnapshot;
-    if (m_hasPixmap != hadPixmap) {
-        emit hasPixmapChanged();
-    }
-}
-
-void WindowPixmapItem::configure(bool hasBuffer)
-{
-    if (hasBuffer != m_hasBuffer) {
-        m_hasBuffer = hasBuffer;
-        if (m_hasBuffer && !m_unmapLock)
-            m_unmapLock = new QWaylandUnmapLock(m_item->surface());
-
-        update();
-    }
-}
-
-void WindowPixmapItem::cleanupOpenGL()
-{
-    disconnect(window(), &QQuickWindow::sceneGraphInvalidated, this, &WindowPixmapItem::cleanupOpenGL);
-    delete s_snapshotProgram;
-    s_snapshotProgram = 0;
+    emit windowIdChanged();
 }
 
-#include "windowpixmapitem.moc"
diff --git a/src/compositor/windowpixmapitem.h b/src/compositor/windowpixmapitem.h
index 6cef6cc9..8df7d29e 100644
--- a/src/compositor/windowpixmapitem.h
+++ b/src/compositor/windowpixmapitem.h
@@ -16,26 +16,13 @@
 #ifndef WINDOWPIXMAPITEM_H
 #define WINDOWPIXMAPITEM_H
 
-#include <QQuickItem>
-#include <QPointer>
-#include "lipstickglobal.h"
+#include <QWaylandQuickItem>
+#include "lipstickapi.h"
 
-class QWaylandUnmapLock;
-
-class LipstickCompositor;
-class LipstickCompositorWindow;
-class LIPSTICK_EXPORT WindowPixmapItem : public QQuickItem
+class LIPSTICK_EXPORT WindowPixmapItem : public QWaylandQuickItem
 {
     Q_OBJECT
     Q_PROPERTY(int windowId READ windowId WRITE setWindowId NOTIFY windowIdChanged)
-    Q_PROPERTY(bool hasPixmap READ hasPixmap NOTIFY hasPixmapChanged)
-    Q_PROPERTY(bool opaque READ opaque WRITE setOpaque NOTIFY opaqueChanged)
-    Q_PROPERTY(qreal radius READ radius WRITE setRadius NOTIFY radiusChanged)
-    Q_PROPERTY(QSize windowSize READ windowSize WRITE setWindowSize NOTIFY windowSizeChanged)
-    Q_PROPERTY(qreal xOffset READ xOffset WRITE setXOffset NOTIFY xOffsetChanged)
-    Q_PROPERTY(qreal yOffset READ yOffset WRITE setYOffset NOTIFY yOffsetChanged)
-    Q_PROPERTY(qreal xScale READ xScale WRITE setXScale NOTIFY xScaleChanged)
-    Q_PROPERTY(qreal yScale READ yScale WRITE setYScale NOTIFY yScaleChanged)
 
 public:
     WindowPixmapItem();
@@ -44,72 +31,12 @@ public:
     int windowId() const;
     void setWindowId(int);
 
-    bool hasPixmap() const;
-
-    bool opaque() const;
-    void setOpaque(bool);
-
-    qreal radius() const;
-    void setRadius(qreal);
-
-    QSize windowSize() const;
-    void setWindowSize(const QSize &size);
-
-    qreal xOffset() const;
-    void setXOffset(qreal);
-
-    qreal yOffset() const;
-    void setYOffset(qreal);
-
-    qreal xScale() const;
-    void setXScale(qreal);
-
-    qreal yScale() const;
-    void setYScale(qreal);
-
-protected:
-    QSGNode *updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *);
-    virtual void geometryChanged(const QRectF &, const QRectF &);
-
 signals:
     void windowIdChanged();
-    void hasPixmapChanged();
-    void opaqueChanged();
-    void radiusChanged();
-    void windowSizeChanged();
-    void xOffsetChanged();
-    void yOffsetChanged();
-    void xScaleChanged();
-    void yScaleChanged();
-
-private slots:
-    void handleWindowSizeChanged();
-    void itemDestroyed(QObject *);
 
 private:
     void updateItem();
-    void surfaceDestroyed();
-    void configure(bool hasBuffer);
-    void cleanupOpenGL();
-
-    QPointer<LipstickCompositorWindow> m_item;
-    QQuickItem *m_shaderEffect;
     int m_id;
-    bool m_opaque;
-    qreal m_radius;
-    qreal m_xOffset;
-    qreal m_yOffset;
-    qreal m_xScale;
-    qreal m_yScale;
-    QSize m_windowSize;
-    QWaylandUnmapLock *m_unmapLock;
-    bool m_hasBuffer;
-    bool m_hasPixmap;
-    bool m_surfaceDestroyed;
-    bool m_haveSnapshot;
-    QSGTextureProvider *m_textureProvider;
-
-    static struct SnapshotProgram *s_snapshotProgram;
 };
 
 #endif // WINDOWPIXMAPITEM_H
diff --git a/src/compositor/windowproperty.cpp b/src/compositor/windowproperty.cpp
deleted file mode 100644
index 9c323d53..00000000
--- a/src/compositor/windowproperty.cpp
+++ /dev/null
@@ -1,120 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2013 Jolla Ltd.
-** Contact: Aaron Kennedy <aaron.kennedy@jollamobile.com>
-**
-** This file is part of lipstick.
-**
-** This library is free software; you can redistribute it and/or
-** modify it under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation
-** and appearing in the file LICENSE.LGPL included in the packaging
-** of this file.
-**
-****************************************************************************/
-
-#include "windowproperty.h"
-
-#include "lipstickcompositor.h"
-
-WindowProperty::WindowProperty()
-: m_windowId(0), m_waitingRefProperty(false)
-{
-    LipstickCompositor *c = LipstickCompositor::instance();
-    if (!c)
-        qWarning("WindowProperty: Compositor must be created before WindowProperty");
-}
-
-int WindowProperty::windowId() const
-{
-    return m_windowId;
-}
-
-void WindowProperty::setWindowId(int window)
-{
-    if (m_windowId == window)
-        return;
-
-    m_windowId = window;
-
-    if (m_surface) {
-        QObject::disconnect(m_surface, SIGNAL(windowPropertyChanged(QString,QVariant)), 
-                            this, SLOT(windowPropertyChanged(QString)));
-        QObject::disconnect(m_surface, SIGNAL(destroyed(QObject *)),
-                            this, SIGNAL(valueChanged()));
-        m_surface = 0;
-    }
-
-    LipstickCompositor *c = LipstickCompositor::instance();
-    if (c) m_surface = c->surfaceForId(window);
-
-    if (m_surface) {
-        // this must use a queued connection in order to avoid QTBUG-32859
-        QObject::connect(m_surface, SIGNAL(windowPropertyChanged(QString,QVariant)), 
-                         this, SLOT(windowPropertyChanged(QString)), Qt::QueuedConnection);
-        QObject::connect(m_surface, SIGNAL(destroyed(QObject *)),
-                         this, SIGNAL(valueChanged()));
-    }
-
-    emit windowIdChanged();
-    emit valueChanged();
-}
-
-void WindowProperty::windowPropertyChanged(const QString &name)
-{
-    if (name == m_property)
-        emit valueChanged();
-}
-
-QString WindowProperty::property() const
-{
-    return m_property;
-}
-
-void WindowProperty::setProperty(const QString &p)
-{
-    if (m_property == p)
-        return;
-    
-    m_property = p;
-    emit propertyChanged();
-    emit valueChanged();
-}
-
-void WindowProperty::connectRef()
-{
-    LipstickCompositor *c = LipstickCompositor::instance();
-    if (c && !m_waitingRefProperty) {
-        m_waitingRefProperty = true;
-        QObject::connect(c, SIGNAL(availableWinIdsChanged()), this, SLOT(availableWinIdsChanged()));
-    }
-}
-
-QVariant WindowProperty::value()
-{
-    if (!m_surface)
-        return QVariant();
-
-
-    QVariant rv = m_surface->windowProperties().value(m_property);
-    if (rv.type() == QVariant::String && rv.toString().startsWith("__winref:")) {
-        QString refId = rv.toString().mid(9);
-        uint id = refId.toUInt();
-        connectRef();
-
-        if (id) {
-            int win = LipstickCompositor::instance()->windowIdForLink(m_surface, id);
-            return QVariant(win);
-        } else {
-            return QVariant(0);
-        }
-    } else {
-        return rv;
-    }
-}
-
-void WindowProperty::availableWinIdsChanged()
-{
-    if (value().isValid())
-        emit valueChanged();
-}
diff --git a/src/compositor/windowproperty.h b/src/compositor/windowproperty.h
deleted file mode 100644
index 5b87355a..00000000
--- a/src/compositor/windowproperty.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/***************************************************************************
-**
-** Copyright (C) 2013 Jolla Ltd.
-** Contact: Aaron Kennedy <aaron.kennedy@jollamobile.com>
-**
-** This file is part of lipstick.
-**
-** This library is free software; you can redistribute it and/or
-** modify it under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation
-** and appearing in the file LICENSE.LGPL included in the packaging
-** of this file.
-**
-****************************************************************************/
-
-#ifndef WINDOWPROPERTY_H
-#define WINDOWPROPERTY_H
-
-#include <QObject>
-#include <QPointer>
-#include <QVariant>
-#include "lipstickglobal.h"
-
-class QWaylandSurface;
-
-class LIPSTICK_EXPORT WindowProperty : public QObject
-{
-    Q_OBJECT
-    Q_PROPERTY(int windowId READ windowId WRITE setWindowId NOTIFY windowIdChanged)
-    Q_PROPERTY(QString property READ property WRITE setProperty NOTIFY propertyChanged)
-    Q_PROPERTY(QVariant value READ value NOTIFY valueChanged)
-public:
-    WindowProperty();
-
-    int windowId() const;
-    void setWindowId(int);
-
-    QString property() const;
-    void setProperty(const QString &);
-
-    QVariant value();
-
-signals:
-    void windowIdChanged();
-    void propertyChanged();
-    void valueChanged();
-
-private slots:
-    void availableWinIdsChanged();
-    void windowPropertyChanged(const QString &);
-
-private:
-    int m_windowId;
-    bool m_waitingRefProperty;
-    void connectRef();
-    QString m_property;
-    QPointer<QWaylandSurface> m_surface;
-};
-
-#endif // WINDOWPROPERTY_H
diff --git a/src/homeapplication.cpp b/src/homeapplication.cpp
index b88d6264..a9711917 100644
--- a/src/homeapplication.cpp
+++ b/src/homeapplication.cpp
@@ -259,7 +259,8 @@ void HomeApplication::sendHomeReadySignalIfNotAlreadySent()
 {
     if (!m_homeReadySent) {
         m_homeReadySent = true;
-        disconnect(LipstickCompositor::instance(), SIGNAL(frameSwapped()), this, SLOT(sendHomeReadySignalIfNotAlreadySent()));
+
+        disconnect(LipstickCompositor::instance()->quickWindow(), SIGNAL(frameSwapped()), this, SLOT(sendHomeReadySignalIfNotAlreadySent()));
 
         emit homeReady();
     }
@@ -359,20 +360,22 @@ void HomeApplication::setCompositorPath(const QString &path)
         return;
     } 
 
-    QObject *compositor = component.beginCreate(m_qmlEngine->rootContext());
+    QQuickItem *compositor = qobject_cast<QQuickItem*>(component.beginCreate(qmlEngine->rootContext()));
     if (compositor) {
         compositor->setParent(this);
+
         if (LipstickCompositor::instance()) {
-            LipstickCompositor::instance()->setGeometry(QRect(QPoint(0, 0), QGuiApplication::primaryScreen()->size()));
-            connect(m_usbModeSelector, SIGNAL(showUnlockScreen()),
+            LipstickCompositor::instance()->quickWindow()->setGeometry(QRect(QPoint(0, 0), QGuiApplication::primaryScreen()->size()));
+            connect(usbModeSelector, SIGNAL(showUnlockScreen()),
                     LipstickCompositor::instance(), SIGNAL(showUnlockScreen()));
+            compositor->setParentItem(LipstickCompositor::instance()->quickWindow()->contentItem());
         }
 
         component.completeCreate();
 
         if (!m_qmlEngine->incubationController() && LipstickCompositor::instance()) {
             // install default incubation controller
-            m_qmlEngine->setIncubationController(LipstickCompositor::instance()->incubationController());
+            m_qmlEngine->setIncubationController(LipstickCompositor::instance()->quickWindow()->incubationController());
         }
     } else {
         qWarning() << "HomeApplication: Error creating compositor from" << path;
@@ -406,7 +409,7 @@ QQmlEngine *HomeApplication::engine() const
 void HomeApplication::connectFrameSwappedSignal(bool mainWindowVisible)
 {
     if (!m_homeReadySent && mainWindowVisible) {
-        connect(LipstickCompositor::instance(), SIGNAL(frameSwapped()), this, SLOT(sendHomeReadySignalIfNotAlreadySent()));
+        connect(LipstickCompositor::instance()->quickWindow(), SIGNAL(frameSwapped()), this, SLOT(sendHomeReadySignalIfNotAlreadySent()));
     }
 }
 
diff --git a/src/homewindow.cpp b/src/homewindow.cpp
index 8054d45d..49c4b7a5 100644
--- a/src/homewindow.cpp
+++ b/src/homewindow.cpp
@@ -63,7 +63,7 @@ HomeWindowPrivate::HomeWindowPrivate()
         // XXX
         // window->setResizeMode(QQuickView::SizeRootObjectToView);
     } else {
-        window = LipstickCompositor::instance();
+        window = LipstickCompositor::instance()->quickWindow();
     }
 }
 
diff --git a/src/notifications/lipsticknotification.cpp b/src/notifications/lipsticknotification.cpp
index fb618703..2ed78e17 100644
--- a/src/notifications/lipsticknotification.cpp
+++ b/src/notifications/lipsticknotification.cpp
@@ -19,6 +19,7 @@
 #include <QDBusArgument>
 #include <QDataStream>
 #include <QtDebug>
+#include <QDataStream>
 
 const char *LipstickNotification::HINT_URGENCY = "urgency";
 const char *LipstickNotification::HINT_CATEGORY = "category";
diff --git a/src/notifications/notificationfeedbackplayer.cpp b/src/notifications/notificationfeedbackplayer.cpp
index 7e0305bf..dffcc2a0 100644
--- a/src/notifications/notificationfeedbackplayer.cpp
+++ b/src/notifications/notificationfeedbackplayer.cpp
@@ -16,6 +16,7 @@
 #include <NgfClient>
 #include <QWaylandSurface>
 #include "lipstickcompositor.h"
+#include "lipstickcompositorwindow.h"
 #include "notificationmanager.h"
 #include "lipsticknotification.h"
 #include "notificationfeedbackplayer.h"
@@ -109,9 +110,9 @@ bool NotificationFeedbackPlayer::isEnabled(LipstickNotification *notification)
         return false;
 
     uint mode = AllNotificationsEnabled;
-    QWaylandSurface *surface = LipstickCompositor::instance()->surfaceForId(LipstickCompositor::instance()->topmostWindowId());
-    if (surface != 0) {
-        mode = surface->windowProperties().value("NOTIFICATION_PREVIEWS_DISABLED", uint(AllNotificationsEnabled)).toUInt();
+    LipstickCompositorWindow *win = LipstickCompositor::instance()->m_windows.value(LipstickCompositor::instance()->topmostWindowId());
+    if (win != 0) {
+        mode = win->windowProperties().value("NOTIFICATION_PREVIEWS_DISABLED", uint(AllNotificationsEnabled)).toUInt();
     }
 
     int urgency = notification->urgency();
diff --git a/src/notifications/notificationmanager.cpp b/src/notifications/notificationmanager.cpp
index fbff66da..ab4dd022 100644
--- a/src/notifications/notificationmanager.cpp
+++ b/src/notifications/notificationmanager.cpp
@@ -656,7 +656,7 @@ void NotificationManager::restoreNotifications(bool update)
 
 bool NotificationManager::connectToDatabase()
 {
-    QString databasePath = "/home/nemo" + QString(PRIVILEGED_DATA_PATH) + QDir::separator() + "Notifications";
+    QString databasePath = "/home/ceres" + QString(PRIVILEGED_DATA_PATH) + QDir::separator() + "Notifications";
     if (!QDir::root().exists(databasePath)) {
         QDir::root().mkpath(databasePath);
     }
diff --git a/src/notifications/notificationpreviewpresenter.cpp b/src/notifications/notificationpreviewpresenter.cpp
index f908186a..9274917e 100644
--- a/src/notifications/notificationpreviewpresenter.cpp
+++ b/src/notifications/notificationpreviewpresenter.cpp
@@ -21,6 +21,7 @@
 #include "notifications/lipsticknotification.h"
 #include <QScreen> // should be included by lipstickcompositor.h
 #include "compositor/lipstickcompositor.h"
+#include "compositor/lipstickcompositorwindow.h"
 #include "notificationpreviewpresenter.h"
 #include "lipstickqmlpath.h"
 
@@ -213,9 +214,9 @@ bool NotificationPreviewPresenter::notificationShouldBeShown(LipstickNotificatio
     const bool notificationIsCritical = notification->urgency() >= 2 || notification->hints().value(LipstickNotification::HINT_DISPLAY_ON).toBool();
 
     uint mode = AllNotificationsEnabled;
-    QWaylandSurface *surface = LipstickCompositor::instance()->surfaceForId(LipstickCompositor::instance()->topmostWindowId());
-    if (surface != 0) {
-        mode = surface->windowProperties().value("NOTIFICATION_PREVIEWS_DISABLED", uint(AllNotificationsEnabled)).toUInt();
+    LipstickCompositorWindow *win = LipstickCompositor::instance()->m_windows.value(LipstickCompositor::instance()->topmostWindowId(), 0);
+    if (win != 0) {
+        mode = win->windowProperties().value("NOTIFICATION_PREVIEWS_DISABLED", uint(AllNotificationsEnabled)).toUInt();
     }
 
     return ((!screenLocked && !deviceLocked) || notificationIsCritical) &&
diff --git a/src/screenshotservice.cpp b/src/screenshotservice.cpp
index c184fa55..32bb0478 100644
--- a/src/screenshotservice.cpp
+++ b/src/screenshotservice.cpp
@@ -33,12 +33,12 @@ ScreenshotService::ScreenshotService(QObject *parent) :
 void ScreenshotService::saveScreenshot(const QString &path)
 {
     if (LipstickCompositor *compositor = LipstickCompositor::instance()) {
-        QQuickWindowPrivate *wd = QQuickWindowPrivate::get(compositor);
+        QQuickWindowPrivate *wd = QQuickWindowPrivate::get(compositor->quickWindow());
         HwcRenderStage *renderStage = (HwcRenderStage *) wd->customRenderStage;
         if (renderStage)
             renderStage->setBypassHwc(true);
 
-        QImage grab(compositor->grabWindow());
+        QImage grab(compositor->quickWindow()->grabWindow());
 
         int rotation(QGuiApplication::primaryScreen()->angleBetween(Qt::PrimaryOrientation, compositor->topmostWindowOrientation()));
         if (rotation != 0) {
diff --git a/src/src.pro b/src/src.pro
index 5d63f3d9..45355833 100644
--- a/src/src.pro
+++ b/src/src.pro
@@ -24,7 +24,6 @@ MOC_DIR = .moc
 INCLUDEPATH += utilities touchscreen components xtools 3rdparty qmsystem2
 
 include(compositor/compositor.pri)
-include(compositor/alienmanager/alienmanager.pri)
 
 PUBLICHEADERS += \
     utilities/qobjectlistmodel.h \
diff --git a/tests/ut_notificationfeedbackplayer/ut_notificationfeedbackplayer.pro b/tests/ut_notificationfeedbackplayer/ut_notificationfeedbackplayer.pro
index e6b797c6..05529bdb 100644
--- a/tests/ut_notificationfeedbackplayer/ut_notificationfeedbackplayer.pro
+++ b/tests/ut_notificationfeedbackplayer/ut_notificationfeedbackplayer.pro
@@ -2,7 +2,7 @@ include(../common.pri)
 TARGET = ut_notificationfeedbackplayer
 INCLUDEPATH += $$NOTIFICATIONSRCDIR $$COMPOSITORSRCDIR $$TOUCHSCREENSRCDIR /usr/include/ngf-qt5 $$QMSYSTEM2
 CONFIG += link_pkgconfig
-QT += dbus compositor quick
+QT += dbus waylandcompositor quick
 DEFINES += QT_COMPOSITOR_QUICK
 
 HEADERS += \
diff --git a/tests/ut_notificationpreviewpresenter/ut_notificationpreviewpresenter.pro b/tests/ut_notificationpreviewpresenter/ut_notificationpreviewpresenter.pro
index 39757ef6..5d206109 100644
--- a/tests/ut_notificationpreviewpresenter/ut_notificationpreviewpresenter.pro
+++ b/tests/ut_notificationpreviewpresenter/ut_notificationpreviewpresenter.pro
@@ -1,7 +1,19 @@
 include(../common.pri)
 TARGET = ut_notificationpreviewpresenter
-INCLUDEPATH += $$SRCDIR $$NOTIFICATIONSRCDIR $$UTILITYSRCDIR $$TOUCHSCREENSRCDIR $$SRCDIR/compositor $$QMSYSTEM2 $$SCREENLOCKSRCDIR
-QT += qml quick dbus compositor
+INCLUDEPATH += \
+    $$SRCDIR \
+    $$NOTIFICATIONSRCDIR \
+    $$UTILITYSRCDIR \
+    $$TOUCHSCREENSRCDIR \
+    $$SRCDIR/compositor \
+    $$QMSYSTEM2 \
+    $$SCREENLOCKSRCDIR
+
+QT += \
+    dbus \
+    qml \
+    quick \
+    waylandcompositor
 
 # unit test and unit
 SOURCES += \
diff --git a/tools/simple-compositor/main.cpp b/tools/simple-compositor/main.cpp
deleted file mode 100644
index 93dcf759..00000000
--- a/tools/simple-compositor/main.cpp
+++ /dev/null
@@ -1,10 +0,0 @@
-#include <lipstickcompositor.h>
-#include <homeapplication.h>
-#include <QQmlApplicationEngine>
-
-int main(int argc, char **argv)
-{
-    HomeApplication app(argc, argv, QString());
-    app.setCompositorPath("simplecompositor.qml");
-    return app.exec();
-}
\ No newline at end of file
diff --git a/tools/simple-compositor/simple-compositor.pro b/tools/simple-compositor/simple-compositor.pro
deleted file mode 100644
index 0b0509b3..00000000
--- a/tools/simple-compositor/simple-compositor.pro
+++ /dev/null
@@ -1,28 +0,0 @@
-######################################################################
-# Automatically generated by qmake (3.0) Wed Mar 25 07:44:58 2015
-######################################################################
-
-TEMPLATE = app
-TARGET = simplecompositor
-INCLUDEPATH += .
-
-QT += quick compositor
-
-# Input
-SOURCES += main.cpp
-
-DEPENDPATH += ../../src
-INCLUDEPATH += ../../src ../../src/compositor ../../src/qmsystem2 ../../src/touchscreen
-QMAKE_LIBDIR = ../../src
-LIBS = -llipstick-qt5
-
-CONFIG += link_pkgconfig
-PKGCONFIG += mlite5 dsme_dbus_if thermalmanager_dbus_if usb_moded
-
-qmls.path += /usr/share/lipstick/simplecompositor
-qmls.files += simplecompositor.qml
-
-target.path += /usr/bin
-target.files += simplecompositor
-
-INSTALLS = target qmls
diff --git a/tools/simple-compositor/simplecompositor.qml b/tools/simple-compositor/simplecompositor.qml
deleted file mode 100644
index 7b319a67..00000000
--- a/tools/simple-compositor/simplecompositor.qml
+++ /dev/null
@@ -1,58 +0,0 @@
-import org.nemomobile.lipstick 0.1
-import QtQuick 2.2
-
-Compositor
-{
-    id: root
-
-    color: "transparent"
-
-    property bool doAsync: false
-
-    HwcImage {
-        id: image1
-        asynchronous: root.doAsync
-        textureSize: Qt.size(540, 960);
-    }
-
-    HwcImage {
-        id: image2
-        asynchronous: root.doAsync
-        x: 100
-        y: 100
-        textureSize: Qt.size(540, 960);
-    }
-
-    Timer {
-        running: true
-        interval: 1000
-        repeat: false
-        onTriggered: {
-            print("setting the first batch of sources...", root.doAsync ? "async" : "sync");
-            image1.source = "/home/nemo/Pictures/Jolla/Jolla_01.jpg"
-            image2.source = "/home/nemo/Pictures/Jolla/Jolla_02.jpg"
-            // image3.source = "/home/nemo/Pictures/Jolla/Jolla_03.jpg"
-            // image4.source = "/home/nemo/Pictures/Jolla/Jolla_04.jpg"
-            print("All done setting sources...")
-        }
-    }
-
-    Timer {
-        running: true
-        interval: 400
-        repeat: true
-        onTriggered: {
-            print("toggling visibility...");
-            image1.visible = !image1.visible;
-        }
-    }
-
-    // Text {
-    //     color: "white"
-    //     anchors.centerIn: parent
-    //     text: "Simple Compositor..."
-    //     RotationAnimator on rotation { from: 0; to: 360; duration: 5000; loops: -1 }
-    //     font.pixelSize: 20
-    // }
-
-}
diff --git a/tools/tools.pro b/tools/tools.pro
index 8da0967f..82f61f42 100644
--- a/tools/tools.pro
+++ b/tools/tools.pro
@@ -1,2 +1,4 @@
 TEMPLATE = subdirs
-SUBDIRS += notificationtool simple-compositor
+
+SUBDIRS += \
+    notificationtool
-- 
2.23.0


From 7dcdbbc8a276f7f092d95aebaf9dc32f42bd2d93 Mon Sep 17 00:00:00 2001
From: Chris Adams <chris.adams@jollamobile.com>
Date: Mon, 20 Aug 2018 16:32:38 +1000
Subject: [PATCH 2/3] [lipstick-qt5] Emit appropriate WL_OUTPUT_TRANSFORM for
 orientation change. Contributes to JB#42625

This commit ensures that the transform we emit matches the expectation
of the qtwaylandscreen implementation in
qtwayland:src/client/qwaylandscreen.cpp: QWaylandScreen::output_done().
---
 src/compositor/lipstickcompositor.cpp | 33 ++++++++++++---------------
 1 file changed, 15 insertions(+), 18 deletions(-)

diff --git a/src/compositor/lipstickcompositor.cpp b/src/compositor/lipstickcompositor.cpp
index 086e7d6a..20b52466 100644
--- a/src/compositor/lipstickcompositor.cpp
+++ b/src/compositor/lipstickcompositor.cpp
@@ -613,38 +613,35 @@ void LipstickCompositor::setScreenOrientation(Qt::ScreenOrientation screenOrient
         if (debug())
             qDebug() << "Setting screen orientation on QWaylandCompositor";
 
-        QSize physSize = m_output->physicalSize();
+        const QSize physSize = m_output->physicalSize();
+        const bool isPortrait = physSize.height() > physSize.width();
         switch(screenOrientation) {
         case Qt::PrimaryOrientation:
             m_output->setTransform(QWaylandOutput::TransformNormal);
             break;
         case Qt::LandscapeOrientation:
-            if(physSize.width() > physSize.height())
-                m_output->setTransform(QWaylandOutput::TransformNormal);
-            else
-                m_output->setTransform(QWaylandOutput::Transform90);
+            m_output->setTransform(isPortrait
+                    ? QWaylandOutput::Transform270
+                    : QWaylandOutput::TransformNormal);
             break;
         case Qt::PortraitOrientation:
-            if(physSize.width() > physSize.height())
-                m_output->setTransform(QWaylandOutput::Transform90);
-            else
-                m_output->setTransform(QWaylandOutput::TransformNormal);
+            m_output->setTransform(isPortrait
+                    ? QWaylandOutput::TransformNormal
+                    : QWaylandOutput::Transform90);
             break;
         case Qt::InvertedLandscapeOrientation:
-            if(physSize.width() > physSize.height())
-                m_output->setTransform(QWaylandOutput::Transform180);
-            else
-                m_output->setTransform(QWaylandOutput::Transform270);
+            m_output->setTransform(isPortrait
+                    ? QWaylandOutput::Transform90
+                    : QWaylandOutput::Transform180);
             break;
         case Qt::InvertedPortraitOrientation:
-            if(physSize.width() > physSize.height())
-                m_output->setTransform(QWaylandOutput::Transform270);
-            else
-                m_output->setTransform(QWaylandOutput::Transform180);
+            m_output->setTransform(isPortrait
+                    ? QWaylandOutput::Transform180
+                    : QWaylandOutput::Transform270);
             break;
         }
-        QWindowSystemInterface::handleScreenOrientationChange(qApp->primaryScreen(),screenOrientation);
 
+        QWindowSystemInterface::handleScreenOrientationChange(qApp->primaryScreen(), screenOrientation);
         m_screenOrientation = screenOrientation;
         emit screenOrientationChanged();
     }
-- 
2.23.0


From 4edfbc5083e8967967a30638de82a796ad9f0136 Mon Sep 17 00:00:00 2001
From: Andrew den Exter <andrew.den.exter@jolla.com>
Date: Fri, 7 Sep 2018 08:41:26 +1000
Subject: [PATCH 3/3] [lipstick] Restore API for window properties and add new
 for closing windows. Contributes to JB#42170

---
 doc/doc.pro                                   |  44 +-
 doc/doxygen.cfg                               |   2 +-
 doc/notifications/doxygen.cfg                 |   2 +-
 plugin/lipstickplugin.cpp                     |   3 +
 protocol/alien-manager.xml                    | 218 ++++++
 rpm/lipstick-qt5.spec                         |  19 +-
 src/compositor/alienmanager/alienmanager.cpp  |  91 +++
 src/compositor/alienmanager/alienmanager.h    |  61 ++
 src/compositor/alienmanager/alienmanager.pri  |  11 +
 src/compositor/alienmanager/aliensurface.cpp  | 165 +++++
 src/compositor/alienmanager/aliensurface.h    |  80 +++
 src/compositor/compositor.pri                 |   4 +
 src/compositor/hwcimage.cpp                   |   8 +-
 src/compositor/lipstickcompositor.cpp         | 370 ++++------
 src/compositor/lipstickcompositor.h           |  73 +-
 .../lipstickcompositorprocwindow.cpp          |  23 +-
 src/compositor/lipstickcompositorprocwindow.h |   8 +-
 src/compositor/lipstickcompositorwindow.cpp   | 611 +++++++++++++---
 src/compositor/lipstickcompositorwindow.h     | 129 +++-
 src/compositor/windowmodel.h                  |   2 +
 src/compositor/windowpixmapitem.cpp           | 677 +++++++++++++++++-
 src/compositor/windowpixmapitem.h             |  75 +-
 src/compositor/windowpropertymap.cpp          |  73 ++
 src/compositor/windowpropertymap.h            |  48 ++
 src/homeapplication.cpp                       |  57 +-
 .../notificationfeedbackplayer.cpp            |   4 +-
 src/notifications/notificationmanager.cpp     |   2 +-
 .../notificationpreviewpresenter.cpp          |   4 +-
 src/src.pro                                   |  15 +-
 tests/stubs/lipstickcompositor_stub.h         | 200 ++----
 .../ut_notificationfeedbackplayer.cpp         |  19 +-
 .../ut_notificationfeedbackplayer.pro         |   1 +
 .../ut_notificationpreviewpresenter.cpp       |  12 +-
 .../ut_notificationpreviewpresenter.pro       |   9 +-
 tools/tools.pro                               |   4 +-
 35 files changed, 2488 insertions(+), 636 deletions(-)
 create mode 100644 protocol/alien-manager.xml
 create mode 100644 src/compositor/alienmanager/alienmanager.cpp
 create mode 100644 src/compositor/alienmanager/alienmanager.h
 create mode 100644 src/compositor/alienmanager/alienmanager.pri
 create mode 100644 src/compositor/alienmanager/aliensurface.cpp
 create mode 100644 src/compositor/alienmanager/aliensurface.h
 create mode 100644 src/compositor/windowpropertymap.cpp
 create mode 100644 src/compositor/windowpropertymap.h

diff --git a/doc/doc.pro b/doc/doc.pro
index 5c472ec6..c29cf5b5 100644
--- a/doc/doc.pro
+++ b/doc/doc.pro
@@ -1,33 +1,31 @@
-# Stupid qmake wants to link everything.
-QMAKE_LINK = @: IGNORE THIS LINE
+TEMPLATE = aux
 
-QMAKE_EXTRA_TARGETS += doc notification_doc
-QMAKE_EXTRA_COMPILER += doc notification_doc
+lipstick_doc.config       += no_check_exist no_link explicit_dependencies
+lipstick_doc.commands      = doxygen $$PWD/doxygen.cfg
+lipstick_doc.input         = $$PWD/doxygen.cfg
+lipstick_doc.output        = $$OUT_PWD/html/index.html
 
-doc.target        = html/index.html
-doc.config       += no_check_exist no_link explicit_dependencies
-doc.commands      = doxygen doxygen.cfg
-doc.input         = $${doc.depends}
-doc.output        = $${doc.target}
-
-notification_doc.target        = notifications/html/index.html
 notification_doc.config       += no_check_exist no_link explicit_dependencies
-notification_doc.commands      = doxygen notifications/doxygen.cfg
-notification_doc.input         = $${notification_doc.depends}
-notification_doc.output        = $${notification_doc.target}
-
-## Make are doc target build by default If 'make' is executed in doc folder
-PRE_TARGETDEPS += $${doc.output} $${notification_doc.output}
+notification_doc.commands      = doxygen $$PWD/notifications/doxygen.cfg
+notification_doc.input         = $$PWD/notifications/doxygen.cfg
+notification_doc.output        = $$OUT_PWD/notifications/html/index.html
 
 # Install rules
-htmldocs.files = html/*
-htmldocs.path = /usr/share/doc/lipstick
+htmldocs.files = \
+    lipstick \
+    lipstick-notification
+htmldocs.path = /usr/share/doc
 htmldocs.CONFIG += no_check_exist
 
-notification_htmldocs.files = notifications/html/*
-notification_htmldocs.path = /usr/share/doc/lipstick-notification
-notification_htmldocs.CONFIG += no_check_exist
+QMAKE_EXTRA_COMPILERS += \
+    lipstick_doc \
+    notification_doc
+
+QMAKE_EXTRA_TARGETS += \
+    lipstick_doc \
+    notification_doc
 
-INSTALLS += htmldocs notification_htmldocs
+INSTALLS += \
+    htmldocs \
 
 OTHER_FILES = src/*.dox
diff --git a/doc/doxygen.cfg b/doc/doxygen.cfg
index 2d794a70..efc76f98 100644
--- a/doc/doxygen.cfg
+++ b/doc/doxygen.cfg
@@ -872,7 +872,7 @@ GENERATE_HTML          = YES
 # If a relative path is entered the value of OUTPUT_DIRECTORY will be
 # put in front of it. If left blank `html' will be used as the default path.
 
-HTML_OUTPUT            = html
+HTML_OUTPUT            = lipstick
 
 # The HTML_FILE_EXTENSION tag can be used to specify the file extension for
 # each generated HTML page (for example: .htm,.php,.asp). If it is left blank
diff --git a/doc/notifications/doxygen.cfg b/doc/notifications/doxygen.cfg
index 0c5ca1f7..dc96b46d 100644
--- a/doc/notifications/doxygen.cfg
+++ b/doc/notifications/doxygen.cfg
@@ -872,7 +872,7 @@ GENERATE_HTML          = YES
 # If a relative path is entered the value of OUTPUT_DIRECTORY will be
 # put in front of it. If left blank `html' will be used as the default path.
 
-HTML_OUTPUT            = notifications/html
+HTML_OUTPUT            = lipstick-notification
 
 # The HTML_FILE_EXTENSION tag can be used to specify the file extension for
 # each generated HTML page (for example: .htm,.php,.asp). If it is left blank
diff --git a/plugin/lipstickplugin.cpp b/plugin/lipstickplugin.cpp
index b14e0b1f..524d7a4a 100644
--- a/plugin/lipstickplugin.cpp
+++ b/plugin/lipstickplugin.cpp
@@ -30,6 +30,7 @@
 #include <compositor/lipstickcompositorwindow.h>
 #include <compositor/windowmodel.h>
 #include <compositor/windowpixmapitem.h>
+#include <compositor/windowpropertymap.h>
 #include <lipstickapi.h>
 #include <hwcimage.h>
 
@@ -70,6 +71,8 @@ void LipstickPlugin::registerTypes(const char *uri)
 
     qmlRegisterType<LipstickCompositorWindow>();
     qmlRegisterType<QObjectListModel>();
+    qmlRegisterType<WindowPropertyMap>();
+    qmlRegisterType<QWaylandKeymap>();
 
     qmlRegisterRevision<QQuickWindow,1>("org.nemomobile.lipstick", 0, 1);
 }
diff --git a/protocol/alien-manager.xml b/protocol/alien-manager.xml
new file mode 100644
index 00000000..93f99c5e
--- /dev/null
+++ b/protocol/alien-manager.xml
@@ -0,0 +1,218 @@
+<protocol name="alien_manager">
+    <copyright>
+        Copyright (C) 2014 Jolla Ltd.
+
+        Permission to use, copy, modify, distribute, and sell this
+        software and its documentation for any purpose is hereby granted
+        without fee, provided that the above copyright notice appear in
+        all copies and that both that copyright notice and this permission
+        notice appear in supporting documentation, and that the name of
+        the copyright holders not be used in advertising or publicity
+        pertaining to distribution of the software without specific,
+        written prior permission.  The copyright holders make no
+        representations about the suitability of this software for any
+        purpose.  It is provided "as is" without express or implied
+        warranty.
+
+        THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+        SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+        FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+        SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+        WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+        AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+        ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+        THIS SOFTWARE.
+    </copyright>
+
+    <interface name="alien_manager" version="1">
+        <description summary="manager interface for alien clients">
+            This global interface is used by alien clients to integrate
+            with the shell.
+        </description>
+
+        <request name="destroy" type="destructor">
+            <description summary="destroy the manager">
+                Destroy this alien_manager. All its alien_client children
+                are inactive and should be destroyed by the client.
+            </description>
+        </request>
+
+        <request name="create_alien_client">
+            <description summary="create a new alien_client handle">
+                This request creates a new alien_client. For each
+                alien_client there should be a real alien application
+                associated with it.
+                The package parameter should be the android package of
+                the external application.
+            </description>
+            <arg name="id" type="new_id" interface="alien_client"/>
+            <arg name="package" type="string"/>
+        </request>
+
+        <request name="pong">
+            <description summary="respond to a ping event">
+                A client must respond to a ping event with a pong request or
+                the client may be deemed unresponsive.
+            </description>
+            <arg name="serial" type="uint"/>
+        </request>
+
+        <event name="ping">
+            <description summary="ping client">
+                A client must respond to a ping event with a pong request or
+                the client may be deemed unresponsive.
+            </description>
+            <arg name="serial" type="uint"/>
+        </event>
+    </interface>
+
+    <interface name="alien_client" version="1">
+        <description summary="alien client metadata interface">
+            Interface used to associate one or more wl_surfaces with an
+            external alien application.
+        </description>
+
+        <request name="destroy" type="destructor">
+            <description summary="destroy this alien_client">
+                Destroy this alien_client. All its alien_surface children
+                are unmapped and become inactive and should be destroyed
+                by the client.
+            </description>
+        </request>
+
+        <request name="get_alien_surface">
+            <description summary="create a new alien_surface">
+                Extend 'surface' with the alien_surface role.
+
+                If the surface has a role already a protocol error will
+                be raised.
+            </description>
+            <arg name="id" type="new_id" interface="alien_surface"/>
+            <arg name="surface" type="object" interface="wl_surface"/>
+        </request>
+
+        <event name="oom_score">
+            <description summary="the oom score for the client">
+                After receiving this event the client should set the
+                oom score for the real application to the given value.
+            </description>
+            <arg name="score" type="int"/>
+        </event>
+    </interface>
+
+    <interface name="alien_surface" version="1">
+        <description summary="main window interface for alien clients">
+            This interface extends a basic wl_surface with additional metadata
+            needed to map it on screen.
+
+            If its wl_surface is destroyed, an alien_surface becomes inactive
+            but will not be automatically destroyed.
+        </description>
+
+        <request name="destroy" type="destructor">
+            <description summary="delete surface">
+                Deletes the surface and invalidates its object ID.
+
+                The wl_surface loses its role, and all the associated properties.
+                The surface is unmapped.
+            </description>
+        </request>
+
+        <request name="set_title">
+            <description summary="set surface title">
+                Set a short title for the surface.
+
+                This string may be used to identify the surface in a task bar,
+                window list, or other user interface elements provided by the
+                compositor.
+
+                The string must be encoded in UTF-8.
+            </description>
+            <arg name="title" type="string"/>
+        </request>
+
+        <enum name="state">
+            <description summary="types of state on the surface">
+                The different state values used on the surface. They are paired with
+                the configure event to ensure that both the client and the compositor
+                setting the state can be synchronized.
+
+                States set in this way are double-buffered. They will get applied on
+                the next commit.
+            </description>
+            <entry name="hidden" value="1" summary="the surface is not visible">
+                The surface is hidden, it should stop drawing and free memory
+                if possible.
+            </entry>
+            <entry name="cover" value="2" summary="the surface is used as a cover">
+                The surface is being used as a non-fullscreen cover, and cannot
+                receive input.
+            </entry>
+        </enum>
+
+        <event name="configure">
+            <description summary="suggest a surface change">
+                The configure event asks the client to resize its surface.
+
+                The width and height arguments specify a hint to the window
+                about how its surface should be resized in surface local
+                coordinates. The states listed in the event specify additional
+                information about the surface.
+
+                A client should send an ack_configure request with the serial
+                sent in this configure event before attaching a new buffer.
+
+                If the client receives multiple configure events before it
+                can respond to one, it is free to discard all but the last
+                event it received.
+            </description>
+            <arg name="width" type="uint"/>
+            <arg name="height" type="uint"/>
+            <arg name="states" type="array"/>
+            <arg name="serial" type="uint"/>
+        </event>
+
+        <request name="ack_configure">
+            <description summary="ack a configure event">
+                When a configure event is received, a client should then ack it
+                using the ack_configure request to ensure that the compositor
+                knows the client has seen the event.
+
+                By this point, the state is confirmed, and the next attach should
+                contain the buffer drawn for the configure event you are acking.
+            </description>
+            <arg name="serial" type="uint"/>
+        </request>
+
+        <request name="request_state">
+            <description summary="request a surface change">
+                Ask the compositor to send a configure event with the
+                requested states. The compositor is free to ignore the
+                request, or to send a different states value than the
+                one requested.
+                The value of the 'serial' argument should be the last serial
+                the client received in an event.
+            </description>
+            <arg name="states" type="array"/>
+            <arg name="serial" type="uint" summary="serial for focus stealing prevenction"/>
+        </request>
+
+        <request name="set_minimized">
+            <description summary="ask the server to minimize the surface">
+                By calling this request the client asks the compositor to minimize
+                this surface. The actual behavior is compositor specific, the client
+                should not assume this surface is going to be unmapped.
+            </description>
+        </request>
+
+        <event name="close">
+            <description summary="request to close this surface">
+                This event requests the client to destroy this surface. The client is
+                free to choose if it wants to quit or to just destroy this surface and
+                keep running, however if the client ignores the request or takes too
+                much time to destroy the surface the server may decide to forcefully
+                kill it.
+            </description>
+        </event>
+    </interface>
+</protocol>
diff --git a/rpm/lipstick-qt5.spec b/rpm/lipstick-qt5.spec
index a485a7af..7dea29be 100644
--- a/rpm/lipstick-qt5.spec
+++ b/rpm/lipstick-qt5.spec
@@ -40,9 +40,10 @@ BuildRequires:  pkgconfig(wayland-server)
 BuildRequires:  pkgconfig(usb-moded-qt5) >= 1.6
 BuildRequires:  pkgconfig(systemsettings)
 BuildRequires:  pkgconfig(nemodevicelock)
+BuildRequires:  pkgconfig(ssu-sysinfo)
 BuildRequires:  qt5-qttools-linguist
 BuildRequires:  qt5-qtgui-devel >= 5.2.1+git24
-BuildRequires:  qt5-qtwayland-wayland_egl-devel >= 5.4.0+git26
+BuildRequires:  qt5-qtwayland-compositor-devel >= 5.9.5
 BuildRequires:  doxygen
 BuildRequires:  qt5-qttools-qthelp-devel
 Conflicts:   meegotouch-systemui < 1.5.7
@@ -56,6 +57,7 @@ A QML toolkit for homescreen creation
 Summary:    Development files for lipstick
 License:    LGPLv2.1
 Requires:   %{name} = %{version}-%{release}
+Requires:   qt5-qtwayland-compositor-devel >= 5.9.5
 
 %description devel
 Files useful for building homescreens.
@@ -76,15 +78,6 @@ Requires:   %{name} = %{version}-%{release}
 %description tools
 Tools for the lipstick package (warning: these tools installed by default).
 
-%package simplecompositor
-Summary:    Lipstick Simple Compositor
-License:    LGPLv2.1
-Requires:   %{name} = %{version}-%{release}
-
-%description simplecompositor
-Debugging tool to debug the compositor logic without pulling in all of the
-homescreen and all the other app logic lipstick has.
-
 %package doc
 Summary:    Documentation for lipstick
 License:    LGPLv2.1
@@ -120,6 +113,7 @@ Translation files for the lipstick package.
 %qmake5 VERSION=%{version}
 
 make %{?_smp_mflags}
+make -C doc lipstick_doc notification_doc
 
 %install
 rm -rf %{buildroot}
@@ -159,11 +153,6 @@ mkdir -p %{buildroot}/%{icondirectory}
 %defattr(-,root,root,-)
 %{_bindir}/notificationtool
 
-%files simplecompositor
-%defattr(-,root,root,-)
-%{_bindir}/simplecompositor
-%{_datadir}/lipstick/simplecompositor/*
-
 %files doc
 %defattr(-,root,root,-)
 %{_datadir}/doc/lipstick/*
diff --git a/src/compositor/alienmanager/alienmanager.cpp b/src/compositor/alienmanager/alienmanager.cpp
new file mode 100644
index 00000000..edf22266
--- /dev/null
+++ b/src/compositor/alienmanager/alienmanager.cpp
@@ -0,0 +1,91 @@
+/***************************************************************************
+**
+** Copyright (C) 2014 Jolla Ltd.
+** Contact: Giulio Camuffo <giulio.camuffo@jollamobile.com>
+**
+** This file is part of lipstick.
+**
+** This library is free software; you can redistribute it and/or
+** modify it under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation
+** and appearing in the file LICENSE.LGPL included in the packaging
+** of this file.
+**
+****************************************************************************/
+
+#include "alienmanager.h"
+#include "aliensurface.h"
+
+#include <QWaylandCompositor>
+
+#include <lipstickcompositor.h>
+
+AlienManager::AlienManager(QWaylandCompositor *compositor)
+    : QWaylandShellTemplate(compositor)
+    , QtWaylandServer::alien_manager(compositor->display(), 1)
+{
+}
+
+AlienManager::~AlienManager()
+{
+}
+
+void AlienManager::ping(uint32_t serial, AlienSurface *surface)
+{
+    if (Resource *resource = resourceMap().value(surface->surface()->client()->client())) {
+        m_pings.insert(serial, surface);
+        send_ping(resource->handle, serial);
+    }
+}
+
+void AlienManager::alien_manager_destroy(Resource *resource)
+{
+    wl_resource_destroy(resource->handle);
+}
+
+void AlienManager::alien_manager_create_alien_client(Resource *resource, uint32_t id, const QString &package)
+{
+    new AlienClient(this, resource->client(), wl_resource_get_version(resource->handle), id, package);
+}
+
+void AlienManager::alien_manager_pong(Resource *resource, uint32_t serial)
+{
+    Q_UNUSED(resource);
+
+    AlienSurface * const surface = m_pings.take(serial);
+    if (surface)
+        surface->pong();
+}
+
+AlienClient::AlienClient(AlienManager *mgr, wl_client *client, uint32_t version, uint32_t id, const QString &package)
+           : QWaylandCompositorExtensionTemplate<AlienManager>()
+           , QtWaylandServer::alien_client(client, id, version)
+           , m_package(package)
+           , m_manager(mgr)
+{
+}
+
+AlienClient::~AlienClient()
+{
+}
+
+AlienManager *AlienClient::manager() const
+{
+    return m_manager;
+}
+
+void AlienClient::alien_client_destroy(Resource *resource)
+{
+    delete this;
+}
+
+void AlienClient::alien_client_get_alien_surface(
+        Resource *resource, uint32_t id, ::wl_resource *surface_resource)
+{
+    QWaylandSurface *surface = QWaylandSurface::fromResource(surface_resource);
+
+    AlienSurface *alienSurface = new AlienSurface(
+                resource->client(), id, wl_resource_get_version(resource->handle), surface, this, m_package);
+
+    LipstickCompositor::instance()->onAlienSurfaceCreated(alienSurface, surface);
+}
diff --git a/src/compositor/alienmanager/alienmanager.h b/src/compositor/alienmanager/alienmanager.h
new file mode 100644
index 00000000..bd9a91e2
--- /dev/null
+++ b/src/compositor/alienmanager/alienmanager.h
@@ -0,0 +1,61 @@
+/***************************************************************************
+**
+** Copyright (C) 2014 Jolla Ltd.
+** Contact: Giulio Camuffo <giulio.camuffo@jollamobile.com>
+**
+** This file is part of lipstick.
+**
+** This library is free software; you can redistribute it and/or
+** modify it under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation
+** and appearing in the file LICENSE.LGPL included in the packaging
+** of this file.
+**
+****************************************************************************/
+
+#ifndef ALIENMANAGER_H
+#define ALIENMANAGER_H
+
+#include <QWaylandCompositorExtension>
+#include <QWaylandShellTemplate>
+
+#include "qwayland-server-alien-manager.h"
+
+class AlienClient;
+class AlienSurface;
+
+class AlienManager : public QWaylandShellTemplate<AlienManager>, public QtWaylandServer::alien_manager
+{
+public:
+    AlienManager(QWaylandCompositor *compositor);
+    ~AlienManager();
+
+    void ping(uint32_t serial, AlienSurface *surface);
+
+protected:
+    void alien_manager_destroy(Resource *resource) override;
+    void alien_manager_create_alien_client(Resource *resource, uint32_t id, const QString &package) override;
+    void alien_manager_pong(Resource *resource, uint32_t serial) override;
+
+private:
+    QMap<uint32_t, AlienSurface *> m_pings;
+};
+
+class AlienClient : public QWaylandCompositorExtensionTemplate<AlienManager>, public QtWaylandServer::alien_client
+{
+public:
+    AlienClient(AlienManager *mgr, wl_client *client, uint32_t version, uint32_t id, const QString &package);
+    ~AlienClient();
+
+    AlienManager *manager() const;
+
+protected:
+    void alien_client_destroy(Resource *resource) override;
+    void alien_client_get_alien_surface(Resource *resource, uint32_t id, ::wl_resource *surface) override;
+
+private:
+    QString m_package;
+    AlienManager *m_manager;
+};
+
+#endif
diff --git a/src/compositor/alienmanager/alienmanager.pri b/src/compositor/alienmanager/alienmanager.pri
new file mode 100644
index 00000000..c3081a07
--- /dev/null
+++ b/src/compositor/alienmanager/alienmanager.pri
@@ -0,0 +1,11 @@
+INCLUDEPATH += $$PWD
+
+HEADERS += \
+    $$PWD/alienmanager.h \
+    $$PWD/aliensurface.h
+
+SOURCES += \
+    $$PWD/alienmanager.cpp \
+    $$PWD/aliensurface.cpp
+
+WAYLANDSERVERSOURCES += $$PWD/../../../protocol/alien-manager.xml
diff --git a/src/compositor/alienmanager/aliensurface.cpp b/src/compositor/alienmanager/aliensurface.cpp
new file mode 100644
index 00000000..eb9e8df9
--- /dev/null
+++ b/src/compositor/alienmanager/aliensurface.cpp
@@ -0,0 +1,165 @@
+/***************************************************************************
+**
+** Copyright (C) 2014 Jolla Ltd.
+** Contact: Giulio Camuffo <giulio.camuffo@jollamobile.com>
+**
+** This file is part of lipstick.
+**
+** This library is free software; you can redistribute it and/or
+** modify it under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation
+** and appearing in the file LICENSE.LGPL included in the packaging
+** of this file.
+**
+****************************************************************************/
+
+#include <QWaylandSurface>
+
+#include "aliensurface.h"
+#include "alienmanager.h"
+
+#include <lipstickcompositor.h>
+#include <lipstickcompositorwindow.h>
+
+AlienSurface::AlienSurface(
+        struct wl_client *client,
+        uint32_t id,
+        int version,
+        QWaylandSurface *surface,
+        AlienClient *alien,
+        const QString &package)
+    : QWaylandCompositorExtensionTemplate()
+    , QtWaylandServer::alien_surface(client, id, version)
+    , m_client(alien)
+    , m_surface(surface)
+    , m_className(package)
+{
+    m_lastSize = LipstickCompositor::instance()->quickWindow()->size();
+    connect(surface, &QWaylandSurface::sizeChanged, this, [this]() {
+        m_lastSize = m_surface->size();
+    });
+
+    sendConfigure();
+}
+
+AlienSurface::~AlienSurface()
+{
+}
+
+QString AlienSurface::title() const
+{
+    return m_title;
+}
+
+QString AlienSurface::className() const
+{
+    return m_className;
+}
+
+QWaylandSurface *AlienSurface::surface() const
+{
+    return m_surface;
+}
+
+void AlienSurface::show(bool isCover)
+{
+    m_hidden = false;
+    m_coverized = isCover;
+    sendConfigure();
+}
+
+void AlienSurface::hide()
+{
+    m_hidden = true;
+    m_coverized = false;
+    sendConfigure();
+}
+
+void AlienSurface::resize(const QSize &size)
+{
+    m_lastSize = size;
+    sendConfigure();
+}
+
+void AlienSurface::close()
+{
+    send_close();
+}
+
+void AlienSurface::ping()
+{
+    m_client->manager()->ping(m_surface->compositor()->nextSerial(), this);
+}
+
+void AlienSurface::sendOomScore(int score)
+{
+    m_client->send_oom_score(score);
+}
+
+void AlienSurface::alien_surface_destroy(Resource *)
+{
+    delete this;
+}
+
+void AlienSurface::alien_surface_set_title(Resource *resource, const QString &title)
+{
+    Q_UNUSED(resource)
+    if (m_title != title) {
+        m_title = title;
+        emit titleChanged(title);
+    }
+}
+
+void AlienSurface::alien_surface_ack_configure(Resource *resource, uint32_t serial)
+{
+    Q_UNUSED(resource);
+    if (serial == m_serial) {
+        m_serial = 0;
+    }
+}
+
+void AlienSurface::alien_surface_request_state(Resource *resource, wl_array *array, uint32_t serial)
+{
+    Q_UNUSED(resource);
+    bool wasHiddenOrCover = m_hidden | m_coverized;
+    m_hidden = false;
+
+    for (uint32_t *ptr = (uint32_t *)array->data; (char *)ptr < (char *)array->data + array->size; ++ptr) {
+        if (*ptr == ALIEN_SURFACE_STATE_HIDDEN) {
+            m_hidden = true;
+        }
+    }
+    // do some focus stealing prevenction
+    if (wasHiddenOrCover && !m_hidden && serial == m_lastSerial) {
+        if (LipstickCompositorWindow *window = LipstickCompositor::surfaceWindow(m_surface)) {
+            LipstickCompositor::instance()->windowRaised(window);
+        }
+    } else {
+        sendConfigure();
+    }
+}
+
+void AlienSurface::alien_surface_set_minimized(Resource *resource)
+{
+    Q_UNUSED(resource)
+    if (LipstickCompositorWindow *window = LipstickCompositor::surfaceWindow(m_surface)) {
+        LipstickCompositor::instance()->windowLowered(window);
+    }
+}
+
+void AlienSurface::sendConfigure()
+{
+    QVector<uint32_t> states;
+    if (m_hidden) {
+        states << ALIEN_SURFACE_STATE_HIDDEN;
+    }
+    if (m_coverized) {
+        states << ALIEN_SURFACE_STATE_COVER;
+    }
+    QByteArray data = QByteArray::fromRawData((char *)states.data(), states.size() * sizeof(uint32_t));
+    m_serial = m_surface->compositor()->nextSerial();
+    m_lastSerial = m_serial;
+
+    send_configure(m_lastSize.width(), m_lastSize.height(), data, m_serial);
+}
+
diff --git a/src/compositor/alienmanager/aliensurface.h b/src/compositor/alienmanager/aliensurface.h
new file mode 100644
index 00000000..a04a0538
--- /dev/null
+++ b/src/compositor/alienmanager/aliensurface.h
@@ -0,0 +1,80 @@
+/***************************************************************************
+**
+** Copyright (C) 2014 Jolla Ltd.
+** Contact: Giulio Camuffo <giulio.camuffo@jollamobile.com>
+**
+** This file is part of lipstick.
+**
+** This library is free software; you can redistribute it and/or
+** modify it under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation
+** and appearing in the file LICENSE.LGPL included in the packaging
+** of this file.
+**
+****************************************************************************/
+
+#ifndef ALIENSURFACE_H
+#define ALIENSURFACE_H
+
+#include <QSize>
+#include <QWaylandCompositorExtension>
+
+#include "qwayland-server-alien-manager.h"
+
+QT_BEGIN_NAMESPACE
+class QWaylandSurface;
+QT_END_NAMESPACE
+
+class AlienClient;
+
+class AlienSurface : public QWaylandCompositorExtensionTemplate<AlienSurface>, public QtWaylandServer::alien_surface
+{
+    Q_OBJECT
+public:
+    AlienSurface(
+            struct wl_client *client,
+            uint32_t id,
+            int version,
+            QWaylandSurface *surface,
+            AlienClient *alien,
+            const QString &package);
+    ~AlienSurface();
+
+    QString title() const;
+    QString className() const;
+
+    QWaylandSurface *surface() const;
+
+    void show(bool isCover);
+    void hide();
+    void resize(const QSize &size);
+    void close();
+    void ping();
+    void sendOomScore(int score);
+
+signals:
+    void titleChanged(const QString &title);
+    void pong();
+
+protected:
+    void alien_surface_destroy(Resource *resource) override;
+    void alien_surface_set_title(Resource *resource, const QString &title) override;
+    void alien_surface_ack_configure(Resource *resource, uint32_t serial) override;
+    void alien_surface_request_state(Resource *resource, wl_array *states, uint32_t serial) override;
+    void alien_surface_set_minimized(Resource *resource) override;
+
+private:
+    inline void sendConfigure();
+
+    AlienClient * const m_client;
+    QWaylandSurface * const m_surface;
+    QSize m_lastSize;
+    QString m_title;
+    const QString m_className;
+    uint32_t m_serial = 0;
+    uint32_t m_lastSerial = 0;
+    bool m_hidden = false;
+    bool m_coverized = false;
+};
+
+#endif
diff --git a/src/compositor/compositor.pri b/src/compositor/compositor.pri
index 44d6a224..67dd02d6 100644
--- a/src/compositor/compositor.pri
+++ b/src/compositor/compositor.pri
@@ -1,5 +1,7 @@
 system(qdbusxml2cpp compositor.xml -a lipstickcompositoradaptor -c LipstickCompositorAdaptor -l LipstickCompositor -i lipstickcompositor.h)
 
+include(alienmanager/alienmanager.pri)
+
 INCLUDEPATH += $$PWD
 
 PUBLICHEADERS += \
@@ -8,6 +10,7 @@ PUBLICHEADERS += \
     $$PWD/lipstickcompositorprocwindow.h \
     $$PWD/lipstickcompositoradaptor.h \
     $$PWD/windowmodel.h \
+    $$PWD/windowpropertymap.h
 
 HEADERS += \
     $$PWD/windowpixmapitem.h \
@@ -22,6 +25,7 @@ SOURCES += \
     $$PWD/lipstickcompositoradaptor.cpp \
     $$PWD/windowmodel.cpp \
     $$PWD/windowpixmapitem.cpp \
+    $$PWD/windowpropertymap.cpp \
     $$PWD/hwcrenderstage.cpp \
     $$PWD/hwcimage.cpp \
 
diff --git a/src/compositor/hwcimage.cpp b/src/compositor/hwcimage.cpp
index 6b1bf296..7b239e9a 100644
--- a/src/compositor/hwcimage.cpp
+++ b/src/compositor/hwcimage.cpp
@@ -435,10 +435,12 @@ HwcImageNode *HwcImage::updateActualPaintNode(QSGNode *old)
     if (m_updateImage) {
         tn->releaseTexture();
         QSGTexture *t = HwcImageTexture::create(m_image, window());
-        if (t)
+        if (t) {
             tn->setTexture(t);
-        else
-            tn->setTexture(window()->createTextureFromImage(m_image));
+        } else {
+            auto tx = window()->createTextureFromImage(m_image);
+            tn->setTexture(tx);
+        }
         m_image = QImage();
         m_updateImage = false;
     }
diff --git a/src/compositor/lipstickcompositor.cpp b/src/compositor/lipstickcompositor.cpp
index 20b52466..88c207df 100644
--- a/src/compositor/lipstickcompositor.cpp
+++ b/src/compositor/lipstickcompositor.cpp
@@ -30,12 +30,18 @@
 #include "lipstickcompositor.h"
 #include "lipstickcompositoradaptor.h"
 #include "lipsticksettings.h"
+#include "windowpropertymap.h"
 #include <qpa/qwindowsysteminterface.h>
 #include "hwcrenderstage.h"
 #include <private/qguiapplication_p.h>
 #include <QtGui/qpa/qplatformintegration.h>
 #include <QWaylandQuickShellSurfaceItem>
 #include <QtWaylandCompositor/private/qwlextendedsurface_p.h>
+#include <QtWaylandCompositor/private/qwlqtkey_p.h>
+
+#include <QWaylandXdgShellV5>
+
+#include "alienmanager/alienmanager.h"
 
 LipstickCompositor *LipstickCompositor::m_instance = 0;
 
@@ -57,19 +63,20 @@ LipstickCompositor::LipstickCompositor()
     , m_onUpdatesDisabledUnfocusedWindowId(0)
     , m_fakeRepaintTriggered(false)
 {
-    m_window = new QQuickWindow();
-    m_window->setColor(Qt::black);
-    m_window->setVisible(true);
+    m_output.reset(new QWaylandQuickOutput);
+
+    m_wlShell.reset(new QWaylandWlShell(this));
+    connect(m_wlShell.data(), &QWaylandWlShell::wlShellSurfaceCreated, this, &LipstickCompositor::onShellSurfaceCreated);
 
-    m_output = new QWaylandQuickOutput(this, m_window);
-    m_output->setSizeFollowsWindow(true);
-    connect(this, &QWaylandCompositor::surfaceCreated, this, &LipstickCompositor::onSurfaceCreated);
+    m_xdgShell.reset(new QWaylandXdgShellV5(this));
+    connect(m_xdgShell.data(), &QWaylandXdgShellV5::xdgSurfaceCreated, this, &LipstickCompositor::onXdgSurfaceCreated);
 
-    m_wlShell = new QWaylandWlShell(this);
-    connect(m_wlShell, &QWaylandWlShell::wlShellSurfaceCreated, this, &LipstickCompositor::onShellSurfaceCreated);
+    m_alienManager.reset(new AlienManager(this));
 
-    m_surfExtGlob = new QtWayland::SurfaceExtensionGlobal(this);
-    connect(m_surfExtGlob, &QtWayland::SurfaceExtensionGlobal::extendedSurfaceReady, this, &LipstickCompositor::onExtendedSurfaceReady);
+    m_surfExtGlob.reset(new QtWayland::SurfaceExtensionGlobal(this));
+    connect(m_surfExtGlob.data(), &QtWayland::SurfaceExtensionGlobal::extendedSurfaceReady, this, &LipstickCompositor::onExtendedSurfaceReady);
+
+    m_keyExtension.reset(new QtWayland::QtKeyExtensionGlobal(this));
 
     setRetainedSelectionEnabled(true);
 
@@ -77,12 +84,8 @@ LipstickCompositor::LipstickCompositor()
     m_instance = this;
 
     m_orientationLock = new MGConfItem("/lipstick/orientationLock", this);
-    connect(m_orientationLock, SIGNAL(valueChanged()), SIGNAL(orientationLockChanged()));
+    connect(m_orientationLock, &MGConfItem::valueChanged, this, &LipstickCompositor::orientationLockChanged);
 
-<<<<<<< HEAD
-    connect(this, SIGNAL(visibleChanged(bool)), this, SLOT(onVisibleChanged(bool)));
-    QObject::connect(this, SIGNAL(afterRendering()), this, SLOT(windowSwapped()));
-=======
     // Load legacy settings from the config file and delete it from there
     QSettings legacySettings("nemomobile", "lipstick");
     QString legacyOrientationKey("Compositor/orientationLock");
@@ -91,12 +94,10 @@ LipstickCompositor::LipstickCompositor()
         legacySettings.remove(legacyOrientationKey);
     }
 
-    connect(m_window, SIGNAL(visibleChanged(bool)), this, SLOT(onVisibleChanged(bool)));
->>>>>>> 0274da62... Upgrade QtWaylandCompositor API to Qt5.8 and removes some unused/untested code
-    QObject::connect(HomeApplication::instance(), SIGNAL(aboutToDestroy()), this, SLOT(homeApplicationAboutToDestroy()));
+    connect(HomeApplication::instance(), &HomeApplication::aboutToDestroy, this, &LipstickCompositor::homeApplicationAboutToDestroy);
 
     m_orientationSensor = new QOrientationSensor(this);
-    QObject::connect(m_orientationSensor, SIGNAL(readingChanged()), this, SLOT(setScreenOrientationFromSensor()));
+    connect(m_orientationSensor, &QOrientationSensor::readingChanged, this, &LipstickCompositor::setScreenOrientationFromSensor);
     if (!m_orientationSensor->connectToBackend()) {
         qWarning() << "Could not connect to the orientation sensor backend";
     } else {
@@ -109,13 +110,9 @@ LipstickCompositor::LipstickCompositor()
     QDesktopServices::setUrlHandler("https", this, "openUrl");
     QDesktopServices::setUrlHandler("mailto", this, "openUrl");
 
-    connect(QGuiApplication::clipboard(), SIGNAL(dataChanged()), SLOT(clipboardDataChanged()));
+    connect(QGuiApplication::clipboard(), &QClipboard::dataChanged, this, &LipstickCompositor::clipboardDataChanged);
 
-    HwcRenderStage::initialize(this);
-
-    QTimer::singleShot(0, this, SLOT(initialize()));
-
-    setClientFullScreenHint(true);
+    QTimer::singleShot(0, this, &LipstickCompositor::initialize);
 }
 
 static inline bool displayStateIsDimmed(TouchScreen::DisplayState state)
@@ -132,18 +129,73 @@ LipstickCompositor::~LipstickCompositor()
 {
     // ~QWindow can a call into onVisibleChanged and QWaylandCompositor after we
     // are destroyed, so disconnect it.
-    disconnect(m_window, SIGNAL(visibleChanged(bool)), this, SLOT(onVisibleChanged(bool)));
+    disconnect(m_window.data(), &QWindow::visibleChanged, this, &LipstickCompositor::onVisibleChanged);
 
     delete m_shaderEffect;
 
     m_instance = nullptr;
 }
 
+void LipstickCompositor::componentComplete()
+{
+    HwcRenderStage::initialize(this);
+
+    QWaylandQuickCompositor::componentComplete();
+}
+
 LipstickCompositor *LipstickCompositor::instance()
 {
     return m_instance;
 }
 
+QQmlListProperty<QObject> LipstickCompositor::data()
+{
+    return QQmlListProperty<QObject>(this, this, data_append, data_count, data_at, data_clear);
+}
+
+void LipstickCompositor::data_append(QQmlListProperty<QObject> *property, QObject *object)
+{
+    static_cast<LipstickCompositor *>(property->object)->m_data.append(object);
+}
+
+int LipstickCompositor::data_count(QQmlListProperty<QObject> *property)
+{
+    return static_cast<LipstickCompositor *>(property->object)->m_data.count();
+}
+
+QObject *LipstickCompositor::data_at(QQmlListProperty<QObject> *property, int index)
+{
+    return static_cast<LipstickCompositor *>(property->object)->m_data.value(index);
+}
+
+void LipstickCompositor::data_clear(QQmlListProperty<QObject> *property)
+{
+    static_cast<LipstickCompositor *>(property->object)->m_data.clear();
+}
+
+QWaylandKeymap *LipstickCompositor::keymap()
+{
+    return defaultSeat()->keymap();
+}
+
+void LipstickCompositor::setQuickWindow(QQuickWindow *window)
+{
+    if (!m_window && window) {
+        m_window = window;
+
+        m_output->setCompositor(this);
+        m_output->setWindow(m_window.data());
+        m_output->setSizeFollowsWindow(true);
+
+        if (QScreen *screen = m_window->screen()) {
+            m_output->setPhysicalSize(screen->physicalSize().toSize());
+        }
+
+        connect(m_window.data(), &QWindow::visibleChanged, this, &LipstickCompositor::onVisibleChanged);
+        connect(m_window.data(), &QQuickWindow::afterRendering, this, &LipstickCompositor::windowSwapped);
+    }
+}
+
 void LipstickCompositor::homeApplicationAboutToDestroy()
 {
     m_window->hide();
@@ -169,33 +221,36 @@ void LipstickCompositor::onVisibleChanged(bool visible)
     }
 }
 
-static LipstickCompositorWindow *surfaceWindow(QWaylandSurface *surface)
+LipstickCompositorWindow *LipstickCompositor::surfaceWindow(QWaylandSurface *surface)
 {
-    return surface->views().isEmpty() ? 0 : static_cast<LipstickCompositorWindow *>(surface->views().first()->renderObject());
+    for (QWaylandView *view : surface->views()) {
+        if (LipstickCompositorWindow *window = qobject_cast<LipstickCompositorWindow *>(view->renderObject())) {
+            return window;
+        }
+    }
+    return nullptr;
 }
 
 void LipstickCompositor::onShellSurfaceCreated(QWaylandWlShellSurface *shellSurface)
 {
-    QWaylandSurface *surface = shellSurface->surface();
-    LipstickCompositorWindow *window = surfaceWindow(surface);
-    if(window) {
-//        window->setWlShellSurface(shellSurface);
-        connect(shellSurface, &QWaylandWlShellSurface::titleChanged, this, &LipstickCompositor::surfaceTitleChanged);
-        connect(shellSurface, &QWaylandWlShellSurface::setTransient, this, &LipstickCompositor::surfaceSetTransient);
-        connect(shellSurface, &QWaylandWlShellSurface::setFullScreen, this, &LipstickCompositor::surfaceSetFullScreen);
-    }
+    QWaylandSurface * const surface = shellSurface->surface();
+    LipstickCompositorWindow * const item = new LipstickCompositorWindow(m_nextWindowId++, QString(), shellSurface);
+
+    m_windows.insert(item->windowId(), item);
+
+    connect(surface, &QWaylandSurface::damaged, this, &LipstickCompositor::surfaceDamaged);
+    connect(surface, &QWaylandSurface::redraw, this, &LipstickCompositor::windowSwapped);
 }
 
-void LipstickCompositor::onSurfaceCreated(QWaylandSurface *surface)
+void LipstickCompositor::onXdgSurfaceCreated(QWaylandXdgSurfaceV5 *xdgSurface)
 {
-    LipstickCompositorWindow *item = surfaceWindow(surface);
-    if (!item)
-        item = createView(surface);
-    connect(surface, SIGNAL(hasContentChanged()), this, SLOT(onHasContentChanged()));
-    connect(surface, SIGNAL(sizeChanged()), this, SLOT(surfaceSizeChanged()));
-    connect(surface, SIGNAL(damaged(QRegion)), this, SLOT(surfaceDamaged(QRegion)));
-    connect(surface, SIGNAL(redraw()), this, SLOT(windowSwapped()));
-    connect(surface, SIGNAL(surfaceDestroyed()), this, SLOT(windowSwapped()));
+    QWaylandSurface * const surface = xdgSurface->surface();
+    LipstickCompositorWindow * const item = new LipstickCompositorWindow(m_nextWindowId++, QString(), xdgSurface);
+
+    m_windows.insert(item->windowId(), item);
+
+    connect(surface, &QWaylandSurface::damaged, this, &LipstickCompositor::surfaceDamaged);
+    connect(surface, &QWaylandSurface::redraw, this, &LipstickCompositor::windowSwapped);
 }
 
 void LipstickCompositor::onExtendedSurfaceReady(QtWayland::ExtendedSurface *extSurface, QWaylandSurface *surface)
@@ -203,6 +258,23 @@ void LipstickCompositor::onExtendedSurfaceReady(QtWayland::ExtendedSurface *extS
     LipstickCompositorWindow *window = surfaceWindow(surface);
     if(window)
         window->setExtendedSurface(extSurface);
+
+    connect(extSurface, &QtWayland::ExtendedSurface::raiseRequested, this, [this, window]() {
+        windowRaised(window);
+    });
+    connect(extSurface, &QtWayland::ExtendedSurface::lowerRequested, this, [this, window]() {
+        windowLowered(window);
+    });
+}
+
+void LipstickCompositor::onAlienSurfaceCreated(AlienSurface *alienSurface, QWaylandSurface *surface)
+{
+    LipstickCompositorWindow * const item = new LipstickCompositorWindow(m_nextWindowId++, alienSurface);
+
+    m_windows.insert(item->windowId(), item);
+
+    connect(surface, &QWaylandSurface::damaged, this, &LipstickCompositor::surfaceDamaged);
+    connect(surface, &QWaylandSurface::redraw, this, &LipstickCompositor::windowSwapped);
 }
 
 bool LipstickCompositor::openUrl(QWaylandClient *client, const QUrl &url)
@@ -276,10 +348,9 @@ bool LipstickCompositor::debug() const
     return status == Yes;
 }
 
-QObject *LipstickCompositor::windowForId(int id) const
+LipstickCompositorWindow *LipstickCompositor::windowForId(int id) const
 {
-    QObject *window = m_windows.value(id, NULL);
-    return window;
+    return m_windows.value(id, NULL);
 }
 
 void LipstickCompositor::closeClientForWindowId(int id)
@@ -300,18 +371,19 @@ bool LipstickCompositor::completed()
     return m_completed;
 }
 
-int LipstickCompositor::windowIdForLink(QWaylandSurface *s, uint link) const
+int LipstickCompositor::windowIdForLink(QWaylandSurface *surface, uint link) const
 {
-    for (QHash<int, LipstickCompositorWindow *>::ConstIterator iter = m_windows.begin();
-        iter != m_windows.end(); ++iter) {
+    for (LipstickCompositorWindow *window : m_windows) {
+        QWaylandSurface * const windowSurface = window->surface();
 
-        QWaylandSurface *windowSurface = iter.value()->surface();
-        LipstickCompositorWindow *window = surfaceWindow(windowSurface);
-
-        if (windowSurface && windowSurface->client() && s->client() && window &&
-            windowSurface->client()->processId() == s->client()->processId() &&
-            window->windowProperties().value("WINID", uint(0)).toUInt() == link)
-            return iter.value()->windowId();
+        if (windowSurface
+                && windowSurface->client()
+                && surface->client()
+                && window
+                && windowSurface->client()->processId() == surface->client()->processId()
+                && window->windowProperty(QStringLiteral("WINID")).toUInt() == link) {
+            return window->windowId();
+        }
     }
 
     return 0;
@@ -319,7 +391,9 @@ int LipstickCompositor::windowIdForLink(QWaylandSurface *s, uint link) const
 
 void LipstickCompositor::clearKeyboardFocus()
 {
-//    defaultInputDevice()->setKeyboardFocus(NULL);
+    if (QWaylandSeat *seat = defaultSeat()) {
+        seat->setKeyboardFocus(nullptr);
+    }
 }
 
 void LipstickCompositor::setDisplayOff()
@@ -341,12 +415,6 @@ void LipstickCompositor::setFullscreenSurface(QWaylandSurface *surface)
     if (surface == m_fullscreenSurface)
         return;
 
-    // Prevent flicker when returning to composited mode
-    if (!surface && m_fullscreenSurface) {
-        foreach (QWaylandView *view, m_fullscreenSurface->views())
-            static_cast<LipstickCompositorWindow *>(view->renderObject())->update();
-    }
-
     m_fullscreenSurface = surface;
 
     emit fullscreenSurfaceChanged();
@@ -376,29 +444,6 @@ void LipstickCompositor::setTopmostWindowId(int id)
     }
 }
 
-LipstickCompositorWindow *LipstickCompositor::createView(QWaylandSurface *surface)
-{
-    int id = m_nextWindowId++;
-    LipstickCompositorWindow *item = new LipstickCompositorWindow(id, "", surface, m_window->contentItem());
-    QObject::connect(item, SIGNAL(destroyed(QObject*)), this, SLOT(windowDestroyed()));
-    m_windows.insert(item->windowId(), item);
-    return item;
-}
-
-void LipstickCompositor::onSurfaceDying()
-{
-    QWaylandSurface *surface = static_cast<QWaylandSurface *>(sender());
-    LipstickCompositorWindow *item = surfaceWindow(surface);
-
-    if (surface == m_fullscreenSurface)
-        setFullscreenSurface(0);
-
-    if (item) {
-        item->m_windowClosed = true;
-        item->tryRemove();
-    }
-}
-
 void LipstickCompositor::initialize()
 {
     TouchScreen *touchScreen = HomeApplication::instance()->touchScreen();
@@ -421,110 +466,33 @@ void LipstickCompositor::windowDestroyed(LipstickCompositorWindow *item)
     int id = item->windowId();
 
     m_windows.remove(id);
-    surfaceUnmapped(item);
-}
-
-void LipstickCompositor::onHasContentChanged()
-{
-    QWaylandSurface *surface = qobject_cast<QWaylandSurface *>(sender());
-
-    if(surface->isCursorSurface())
-        return;
-
-    if(surface->hasContent())
-        surfaceMapped(surface);
-    else
-        surfaceUnmapped(surface);
-}
-
-void LipstickCompositor::surfaceMapped(QWaylandSurface *surface)
-{
-    LipstickCompositorWindow *item = surfaceWindow(surface);
-    if (!item)
-        item = createView(surface);
-
-    // The surface was mapped for the first time
-    if (item->m_mapped)
-        return;
+    m_totalWindowCount--;
 
-    QVariantMap properties = item->windowProperties();
+    if (m_mappedSurfaces.remove(id) != 0) {
+        emit windowCountChanged();
+        emit windowRemoved(item);
 
-    item->m_mapped = true;
-    item->m_category = properties.value("CATEGORY").toString();
+        windowRemoved(id);
 
-    if (!item->parentItem()) {
-        // TODO why contentItem?
-        item->setParentItem(m_window->contentItem());
+        emit availableWinIdsChanged();
     }
 
-    item->setSize(surface->size());
-    QObject::connect(surface, &QWaylandSurface::surfaceDestroyed, this, &LipstickCompositor::onSurfaceDying);
-
-    m_totalWindowCount++;
-    m_mappedSurfaces.insert(item->windowId(), item);
-
-    item->setTouchEventsEnabled(true);
-
-    emit windowCountChanged();
-    emit windowAdded(item);
-
-    windowAdded(item->windowId());
-
-    emit availableWinIdsChanged();
-}
-
-void LipstickCompositor::surfaceSizeChanged()
-{
-    QWaylandSurface *surface = qobject_cast<QWaylandSurface *>(sender());
-
-    LipstickCompositorWindow *window = surfaceWindow(surface);
-    if (window)
-        window->setSize(surface->size());
+    emit ghostWindowCountChanged();
 }
 
-void LipstickCompositor::surfaceTitleChanged()
+void LipstickCompositor::surfaceMapped(LipstickCompositorWindow *window, QWaylandSurface *surface)
 {
-    QWaylandWlShellSurface *wlShellSurface = qobject_cast<QWaylandWlShellSurface*>(sender());
-    LipstickCompositorWindow *window = surfaceWindow(wlShellSurface->surface());
-    if (window) {
-        window->setTitle(wlShellSurface->title());
-        emit window->titleChanged();
+    Q_UNUSED(surface);
 
-        int windowId = window->windowId();
+    m_mappedSurfaces.insert(window->windowId(), window);
 
-        for (int ii = 0; ii < m_windowModels.count(); ++ii)
-            m_windowModels.at(ii)->titleChanged(windowId);
-    }
-}
-
-void LipstickCompositor::surfaceSetTransient(QWaylandSurface *transientParent, const QPoint &relativeToParent, bool inactive)
-{
-    Q_UNUSED(inactive)
-    QWaylandWlShellSurface *wlShellSurface = qobject_cast<QWaylandWlShellSurface*>(sender());
-    LipstickCompositorWindow *window = surfaceWindow(wlShellSurface->surface());
-    if (window && transientParent) {
-        LipstickCompositorWindow *transientParentItem = surfaceWindow(transientParent);
-        if (transientParentItem) {
-            window->setParentItem(transientParentItem);
-            window->setX(relativeToParent.x());
-            window->setY(relativeToParent.y());
-        } else {
-            qWarning("Surface was mapped without visible transient parent");
-        }
-    }
-}
+    emit windowCountChanged();
 
-void LipstickCompositor::surfaceSetFullScreen(QWaylandWlShellSurface::FullScreenMethod method, uint framerate, QWaylandOutput *output)
-{
-    Q_UNUSED(method)
-    Q_UNUSED(framerate)
-    QWaylandWlShellSurface *wlShellSurface = qobject_cast<QWaylandWlShellSurface*>(sender());
+    emit windowAdded(window);
 
-    QWaylandOutput *designatedOutput = output ? output : m_output;
-    if (!designatedOutput)
-        return;
+    windowAdded(window->windowId());
 
-    wlShellSurface->sendConfigure(designatedOutput->geometry().size(), QWaylandWlShellSurface::NoneEdge);
+    emit availableWinIdsChanged();
 }
 
 void LipstickCompositor::windowSwapped()
@@ -532,43 +500,13 @@ void LipstickCompositor::windowSwapped()
     m_output->sendFrameCallbacks();
 }
 
-void LipstickCompositor::windowDestroyed()
+void LipstickCompositor::surfaceUnmapped(LipstickCompositorWindow *window, QWaylandSurface *surface)
 {
-    m_totalWindowCount--;
-    m_windows.remove(static_cast<LipstickCompositorWindow *>(sender())->windowId());
-    emit ghostWindowCountChanged();
-}
-
-void LipstickCompositor::surfaceUnmapped(QWaylandSurface *surface)
-{
-    if (surface == m_fullscreenSurface)
-        setFullscreenSurface(0);
-
-    LipstickCompositorWindow *window = surfaceWindow(surface);
-    if (window)
-        emit windowHidden(window);
-}
-
-void LipstickCompositor::surfaceUnmapped(LipstickCompositorWindow *item)
-{
-    int id = item->windowId();
-
-    if (m_mappedSurfaces.remove(id) == 0) {
-        // It was unmapped already so nothing to do
-        return;
+    if (surface == m_fullscreenSurface) {
+        setFullscreenSurface(nullptr);
     }
 
-    emit windowCountChanged();
-    emit windowRemoved(item);
-
-    item->m_windowClosed = true;
-    item->tryRemove();
-
-    emit ghostWindowCountChanged();
-
-    windowRemoved(id);
-
-    emit availableWinIdsChanged();
+    emit windowHidden(window);
 }
 
 void LipstickCompositor::windowAdded(int id)
@@ -647,6 +585,12 @@ void LipstickCompositor::setScreenOrientation(Qt::ScreenOrientation screenOrient
     }
 }
 
+bool LipstickCompositor::displayDimmed() const
+{
+    TouchScreen *touchScreen = HomeApplication::instance()->touchScreen();
+    return displayStateIsDimmed(touchScreen->currentDisplayState());
+}
+
 void LipstickCompositor::reactOnDisplayStateChanges(TouchScreen::DisplayState oldState, TouchScreen::DisplayState newState)
 {
     bool oldOn = displayStateIsOn(oldState);
diff --git a/src/compositor/lipstickcompositor.h b/src/compositor/lipstickcompositor.h
index 4d1dff68..e24ed906 100644
--- a/src/compositor/lipstickcompositor.h
+++ b/src/compositor/lipstickcompositor.h
@@ -18,23 +18,38 @@
 
 #include <QQuickWindow>
 #include "lipstickglobal.h"
-#include "homeapplication.h"
-#include <QQmlParserStatus>]
 #include <QWaylandQuickCompositor>
 #include <QWaylandQuickOutput>
 #include <QWaylandWlShellSurface>
 #include <QQmlComponent>
 #include <QWaylandClient>
+#include <QWaylandSurface>
+#include <QWaylandKeymap>
 #include <QPointer>
 #include <QTimer>
 #include <MGConfItem>
 
+#include <touchscreen.h>
+
+QT_BEGIN_NAMESPACE
+
 namespace QtWayland {
     class SurfaceExtensionGlobal;
     class ExtendedSurface;
+    class QtKeyExtensionGlobal;
 }
 
+class QWaylandXdgShellV5;
+class QWaylandXdgSurfaceV5;
+class QWaylandOutput;
+
+QT_END_NAMESPACE
+
+class AlienClient;
+class AlienManager;
+class AlienSurface;
 class WindowModel;
+class WindowPropertyMap;
 class LipstickCompositorWindow;
 class LipstickCompositorProcWindow;
 class QOrientationSensor;
@@ -59,7 +74,10 @@ class LIPSTICK_EXPORT LipstickCompositor : public QWaylandQuickCompositor
     Q_PROPERTY(bool displayDimmed READ displayDimmed NOTIFY displayDimmedChanged)
     Q_PROPERTY(bool completed READ completed NOTIFY completedChanged)
     Q_PROPERTY(QQuickWindow *quickWindow READ quickWindow CONSTANT)
-
+    Q_PROPERTY(QQuickItem *contentItem READ contentItem CONSTANT)
+    Q_PROPERTY(QQmlListProperty<QObject> data READ data)
+    Q_PROPERTY(QWaylandKeymap *keymap READ keymap CONSTANT)
+    Q_CLASSINFO("DefaultProperty", "data")
 public:
     LipstickCompositor();
     ~LipstickCompositor();
@@ -99,7 +117,7 @@ public:
 
     bool debug() const;
 
-    Q_INVOKABLE QObject *windowForId(int) const;
+    Q_INVOKABLE LipstickCompositorWindow *windowForId(int) const;
     Q_INVOKABLE void closeClientForWindowId(int);
     Q_INVOKABLE void clearKeyboardFocus();
     Q_INVOKABLE void setDisplayOff();
@@ -114,12 +132,19 @@ public:
     bool completed();
 
     void setUpdatesEnabled(bool enabled);
-    LipstickCompositorWindow *createView(QWaylandSurface *surf);
 
-    QQuickWindow *quickWindow() { return m_window; }
+    QQuickWindow *quickWindow() { return m_window.data(); }
+    void setQuickWindow(QQuickWindow *window);
+
+    QQuickItem *contentItem() { return m_window->contentItem(); }
+    QQmlListProperty<QObject> data();
+    QWaylandKeymap *keymap();
+
+    static LipstickCompositorWindow *surfaceWindow(QWaylandSurface *surface);
 
 protected:
     void timerEvent(QTimerEvent *e) Q_DECL_OVERRIDE;
+    void componentComplete() override;
 
 signals:
     void windowAdded(QObject *window);
@@ -153,48 +178,52 @@ signals:
 
     void showUnlockScreen();
 
-private slots:
-    void onHasContentChanged();
+private:
     void surfaceSizeChanged();
     void surfaceTitleChanged();
     void surfaceSetTransient(QWaylandSurface *transientParent, const QPoint &relativeToParent, bool inactive);
     void surfaceSetFullScreen(QWaylandWlShellSurface::FullScreenMethod method, uint framerate, QWaylandOutput *output);
     void surfaceDamaged(const QRegion &);
     void windowSwapped();
-    void windowDestroyed();
     bool openUrl(const QUrl &);
     void reactOnDisplayStateChanges(TouchScreen::DisplayState oldState, TouchScreen::DisplayState newState);
     void homeApplicationAboutToDestroy();
     void setScreenOrientationFromSensor();
     void clipboardDataChanged();
     void onVisibleChanged(bool visible);
-    void onSurfaceDying();
     void initialize();
 
     void onShellSurfaceCreated(QWaylandWlShellSurface *wlShellSurface);
+    void onXdgSurfaceCreated(QWaylandXdgSurfaceV5 *xdgSurface);
+    void onAlienSurfaceCreated(AlienSurface *alienSurface, QWaylandSurface *surface);
     void onExtendedSurfaceReady(QtWayland::ExtendedSurface *extSurface, QWaylandSurface *surface);
 
-private:
+    friend class AlienClient;
     friend class LipstickCompositorWindow;
     friend class LipstickCompositorProcWindow;
     friend class WindowModel;
+    friend class WindowPropertyMap;
     friend class NotificationPreviewPresenter;
     friend class NotificationFeedbackPlayer;
 
-    void surfaceMapped(QWaylandSurface *surface);
-    void surfaceUnmapped(QWaylandSurface *surface);
-    void surfaceUnmapped(LipstickCompositorWindow *item);
+    void surfaceMapped(LipstickCompositorWindow *window, QWaylandSurface *surface);
+    void surfaceUnmapped(LipstickCompositorWindow *window, QWaylandSurface *surface);
 
     int windowIdForLink(QWaylandSurface *, uint) const;
     void windowAdded(int);
     void windowRemoved(int);
     void windowDestroyed(LipstickCompositorWindow *item);
     void surfaceCommitted();
-    void onSurfaceCreated(QWaylandSurface *surface);
 
     QQmlComponent *shaderEffectComponent();
 
+
+
     static LipstickCompositor *m_instance;
+    static inline void data_append(QQmlListProperty<QObject> *property, QObject *object);
+    static inline int data_count(QQmlListProperty<QObject> *property);
+    static inline QObject *data_at(QQmlListProperty<QObject> *property, int index);
+    static inline void data_clear(QQmlListProperty<QObject> *property);
 
     int m_totalWindowCount;
     QHash<int, LipstickCompositorWindow *> m_mappedSurfaces;
@@ -205,8 +234,16 @@ private:
 
     bool m_homeActive;
 
+    QVector<QObject *> m_data;
+    QPointer<QQuickWindow> m_window;
+    QScopedPointer<QWaylandOutput> m_output;
+    QScopedPointer<QWaylandWlShell> m_wlShell;
+    QScopedPointer<QWaylandXdgShellV5> m_xdgShell;
+    QScopedPointer<AlienManager> m_alienManager;
+    QScopedPointer<QtWayland::SurfaceExtensionGlobal> m_surfExtGlob;
+    QScopedPointer<QtWayland::QtKeyExtensionGlobal> m_keyExtension;
     QQmlComponent *m_shaderEffect;
-    QWaylandSurface *m_fullscreenSurface;
+    QPointer<QWaylandSurface> m_fullscreenSurface;
     bool m_directRenderingActive;
     int m_topmostWindowId;
     int m_topmostWindowProcessId;
@@ -220,10 +257,6 @@ private:
     bool m_completed;
     int m_onUpdatesDisabledUnfocusedWindowId;
     bool m_fakeRepaintTriggered;
-    QQuickWindow *m_window;
-    QWaylandOutput *m_output;
-    QWaylandWlShell *m_wlShell;
-    QtWayland::SurfaceExtensionGlobal *m_surfExtGlob;
 };
 
 #endif // LIPSTICKCOMPOSITOR_H
diff --git a/src/compositor/lipstickcompositorprocwindow.cpp b/src/compositor/lipstickcompositorprocwindow.cpp
index 04508c7a..5bb5c863 100644
--- a/src/compositor/lipstickcompositorprocwindow.cpp
+++ b/src/compositor/lipstickcompositorprocwindow.cpp
@@ -28,11 +28,10 @@ LipstickCompositorProcWindow *LipstickCompositor::mapProcWindow(const QString &t
 {
     int id = m_nextWindowId++;
 
-    LipstickCompositorProcWindow *item = new LipstickCompositorProcWindow(id, category, m_window->contentItem());
+    LipstickCompositorProcWindow *item = new LipstickCompositorProcWindow(id, category);
     item->setSize(g.size());
     item->setTitle(title);
     item->setRootItem(rootItem);
-    QObject::connect(item, SIGNAL(destroyed(QObject*)), this, SLOT(windowDestroyed()));
     m_totalWindowCount++;
     m_mappedSurfaces.insert(id, item);
     m_windows.insert(id, item);
@@ -50,8 +49,8 @@ LipstickCompositorProcWindow *LipstickCompositor::mapProcWindow(const QString &t
     return item;
 }
 
-LipstickCompositorProcWindow::LipstickCompositorProcWindow(int windowId, const QString &c, QQuickItem *parent)
-: LipstickCompositorWindow(windowId, c, 0, parent)
+LipstickCompositorProcWindow::LipstickCompositorProcWindow(int windowId, const QString &category)
+    : LipstickCompositorWindow(windowId, category)
 {
 }
 
@@ -61,7 +60,7 @@ LipstickCompositorProcWindow::LipstickCompositorProcWindow(int windowId, const Q
 void LipstickCompositorProcWindow::hide()
 {
     LipstickCompositor *c = LipstickCompositor::instance();
-    c->surfaceUnmapped(this);
+    c->surfaceUnmapped(this, nullptr);
 }
 
 bool LipstickCompositorProcWindow::isInProcess() const
@@ -69,20 +68,6 @@ bool LipstickCompositorProcWindow::isInProcess() const
     return true;
 }
 
-QString LipstickCompositorProcWindow::title() const
-{
-    return m_title;
-}
-
-void LipstickCompositorProcWindow::setTitle(const QString &t)
-{
-    if (t == m_title)
-        return;
-
-    m_title = t;
-    titleChanged();
-}
-
 QQuickItem *LipstickCompositorProcWindow::rootItem()
 {
     return m_rootItem.data();
diff --git a/src/compositor/lipstickcompositorprocwindow.h b/src/compositor/lipstickcompositorprocwindow.h
index c075d00a..301c422d 100644
--- a/src/compositor/lipstickcompositorprocwindow.h
+++ b/src/compositor/lipstickcompositorprocwindow.h
@@ -30,20 +30,18 @@ public:
     virtual bool isInProcess() const;
     virtual bool isTextureProvider() const { return false; }
 
-    virtual QString title() const;
-    void setTitle(const QString &);
-
     QQuickItem *rootItem();
     void setRootItem(QQuickItem *item);
 
+    using LipstickCompositorWindow::setTitle;
+
 signals:
     void rootItemChanged();
 
 private:
     friend class LipstickCompositor;
-    LipstickCompositorProcWindow(int windowId, const QString &, QQuickItem *parent = 0);
+    LipstickCompositorProcWindow(int windowId, const QString &);
 
-    QString m_title;
     QPointer<QQuickItem> m_rootItem;
 };
 
diff --git a/src/compositor/lipstickcompositorwindow.cpp b/src/compositor/lipstickcompositorwindow.cpp
index 82b46514..2f777e05 100644
--- a/src/compositor/lipstickcompositorwindow.cpp
+++ b/src/compositor/lipstickcompositorwindow.cpp
@@ -21,36 +21,179 @@
 #include <signal.h>
 #include "lipstickcompositor.h"
 #include "lipstickcompositorwindow.h"
+#include "windowpropertymap.h"
+#include "windowmodel.h"
 
 #include "hwcimage.h"
 #include "hwcrenderstage.h"
 #include <EGL/egl.h>
-#include <private/qwaylandsurface_p.h>
 #include <private/qquickwindow_p.h>
 #include <QtWaylandCompositor/private/qwlextendedsurface_p.h>
-
-LipstickCompositorWindow::LipstickCompositorWindow(int windowId, const QString &category,
-                                                   QWaylandSurface *surface, QQuickItem *parent)
-: QWaylandQuickItem(), m_windowId(windowId), m_category(category),
-  m_delayRemove(false), m_windowClosed(false), m_removePosted(false),
-  m_interceptingTouch(false), m_mapped(false), m_noHardwareComposition(false),
-  m_focusOnTouch(false), m_hasVisibleReferences(false)
+#include <QtWaylandCompositor/private/qwlqtkey_p.h>
+
+#include <QQmlEngine>
+#include <QWaylandXdgSurfaceV5>
+#include <QWaylandQuickSurface>
+#include "alienmanager/aliensurface.h"
+
+LipstickCompositorWindow::LipstickCompositorWindow(
+        int windowId, const QString &category, QWaylandSurface *surface)
+    : QWaylandQuickItem()
+    , m_category(category)
+    , m_transientPosition(0, 0)
+    , m_compositor(LipstickCompositor::instance())
+    , m_windowId(windowId)
+    , m_isAlien(false)
+    , m_delayRemove(false)
+    , m_windowClosed(false)
+    , m_removePosted(false)
+    , m_interceptingTouch(false)
+    , m_mapped(false)
+    , m_noHardwareComposition(false)
+    , m_focusOnTouch(false)
+    , m_hasVisibleReferences(false)
+    , m_exposed(true)
+    , m_exposedAsCover(false)
+    , m_explicitMouseRegion(false)
 {
     setFlags(QQuickItem::ItemIsFocusScope | flags());
 
+    if (QWaylandQuickSurface *quickSurface = qobject_cast<QWaylandQuickSurface *>(surface)) {
+        quickSurface->setUseTextureAlpha(true);
+    }
+
+    QQmlEngine::setObjectOwnership(this, QQmlEngine::CppOwnership);
+
     // Handle ungrab situations
     connect(this, SIGNAL(visibleChanged()), SLOT(handleTouchCancel()));
     connect(this, SIGNAL(enabledChanged()), SLOT(handleTouchCancel()));
     connect(this, SIGNAL(touchEventsEnabledChanged()), SLOT(handleTouchCancel()));
 
     if(surface) {
-        connect(surface, SIGNAL(surfaceDestroyed()), this, SLOT(deleteLater()));
+        connect(surface, &QWaylandSurface::surfaceDestroyed, this, [this]() {
+            m_windowClosed = true;
+            tryRemove();
+        });
+
+        connect(surface, &QWaylandSurface::sizeChanged, this, [this]() {
+            setSize(QWaylandQuickItem::surface()->size());
+        });
+
+        connect(surface, &QWaylandSurface::hasContentChanged, this, [this](){
+            QWaylandSurface * const surface = QWaylandQuickItem::surface();
+
+            if (!surface) {
+                // The signal has been emitted by the surface object so it exists, but during
+                // cleanup the QWaylandQuickItem may have cleared its pointer before the signal
+                // was received.
+            } else if (!surface->hasContent()) {
+                m_compositor->surfaceUnmapped(this, surface);
+            } else if (!m_mapped) {
+                m_mapped = true;
+                if (m_extSurface) {
+                    m_category = m_extSurface->windowProperty(QStringLiteral("CATEGORY")).toString();
+                }
+                setSize(surface->size());
+                setTouchEventsEnabled(true);
+
+                m_compositor->surfaceMapped(this, surface);
+            }
+        });
+
         setSurface(surface);
     }
-    Q_UNUSED(parent)
-    connectSurfaceSignals();
 }
 
+LipstickCompositorWindow::LipstickCompositorWindow(
+        int windowId, const QString &category, QWaylandWlShellSurface *wlSurface)
+    : LipstickCompositorWindow(windowId, category, wlSurface->surface())
+{
+    m_wlShellSurface = wlSurface;
+    connect(m_wlShellSurface.data(), &QWaylandWlShellSurface::classNameChanged,
+            this, &LipstickCompositorWindow::classNameChanged);
+    connect(m_wlShellSurface.data(), &QWaylandWlShellSurface::pong,
+            this, &LipstickCompositorWindow::pong);
+
+    connect(m_wlShellSurface.data(), &QWaylandWlShellSurface::titleChanged, this, [this]() {
+        setTitle(m_wlShellSurface->title());
+    });
+
+
+    connect(m_wlShellSurface.data(),
+                &QWaylandWlShellSurface::setTransient,
+                this,
+                [this](QWaylandSurface *transientParent, const QPoint &relativeToParent) {
+        if (LipstickCompositorWindow *parentItem = LipstickCompositor::surfaceWindow(transientParent)) {
+            m_transientParent = parentItem;
+            m_transientPosition = relativeToParent;
+            emit transientPositionChanged();
+            emit transientParentChanged();
+        } else {
+            qWarning("Surface was mapped without visible transient parent");
+        }
+    });
+    connect(m_wlShellSurface.data(),
+                &QWaylandWlShellSurface::setFullScreen,
+                this,
+                [this](QWaylandWlShellSurface::FullScreenMethod, uint, QWaylandOutput *output) {
+        if (!output) {
+            output = m_compositor->m_output.data();
+        }
+
+        m_wlShellSurface->sendConfigure(output->geometry().size(), QWaylandWlShellSurface::NoneEdge);
+    });
+
+    setTitle(m_wlShellSurface->title());
+}
+
+LipstickCompositorWindow::LipstickCompositorWindow(
+        int windowId, const QString &category, QWaylandXdgSurfaceV5 *xdgSurface)
+    : LipstickCompositorWindow(windowId, category, xdgSurface->surface())
+{
+    m_xdgSurface = xdgSurface;
+
+    connect(m_xdgSurface.data(), &QWaylandXdgSurfaceV5::titleChanged, this, [this]() {
+        setTitle(m_xdgSurface->title());
+    });
+    connect(m_xdgSurface.data(), &QWaylandXdgSurfaceV5::setTransient, this, [this]() {
+        if (LipstickCompositorWindow *parentItem = LipstickCompositor::surfaceWindow(m_xdgSurface->parentSurface()->surface())) {
+            m_transientParent = parentItem;
+
+            emit transientParentChanged();
+        } else {
+            qWarning("Surface was mapped without visible transient parent");
+        }
+    });
+    connect(m_xdgSurface.data(), &QWaylandXdgSurfaceV5::setFullscreen, this, [this]() {
+        QWaylandOutput *output = m_compositor->m_output.data();
+
+        m_xdgSurface->sendConfigure(
+                    output->geometry().size(),
+                    QVector<QWaylandXdgSurfaceV5::State>() << QWaylandXdgSurfaceV5::FullscreenState);
+    });
+    connect(m_compositor->m_xdgShell.data(), &QWaylandXdgShellV5::pong, this, [this](uint serial) {
+        if (m_pingSerial == serial) {
+            m_pingSerial = 0;
+            emit pong();
+        }
+    });
+
+    setTitle(m_xdgSurface->title());
+}
+
+LipstickCompositorWindow::LipstickCompositorWindow(int windowId, AlienSurface *alienSurface)
+    : LipstickCompositorWindow(windowId, QString(), alienSurface->surface())
+{
+    m_alienSurface = alienSurface;
+    m_isAlien = true;
+
+    connect(m_alienSurface.data(), &AlienSurface::titleChanged, this, &LipstickCompositorWindow::setTitle);
+    connect(m_alienSurface.data(), &AlienSurface::pong, this, &LipstickCompositorWindow::pong);
+
+    setTitle(m_alienSurface->title());
+}
+
+
 LipstickCompositorWindow::~LipstickCompositorWindow()
 {
     // We don't want tryRemove() posting an event anymore, we're dying anyway
@@ -100,10 +243,6 @@ void LipstickCompositorWindow::setDelayRemove(bool delay)
         return;
 
     m_delayRemove = delay;
-    if (m_delayRemove)
-        disconnect(surface(), SIGNAL(surfaceDestroyed()), this, SLOT(deleteLater()));
-    else
-        connect(surface(), SIGNAL(surfaceDestroyed()), this, SLOT(deleteLater()));
 
     emit delayRemoveChanged();
 
@@ -117,15 +256,149 @@ QString LipstickCompositorWindow::category() const
 
 QtWayland::ExtendedSurface *LipstickCompositorWindow::extendedSurface()
 {
-    return m_extSurface;
+    return m_extSurface.data();
 }
 
 void LipstickCompositorWindow::setExtendedSurface(QtWayland::ExtendedSurface *extSurface)
 {
     m_extSurface = extSurface;
-    connect(m_extSurface, SIGNAL(windowFlagsChanged()), this, SIGNAL(windowFlagsChanged()));
+    connect(m_extSurface.data(), &QtWayland::ExtendedSurface::windowFlagsChanged,
+            this, &LipstickCompositorWindow::windowFlagsChanged);
+
+    connect(m_extSurface.data(), &QtWayland::ExtendedSurface::windowPropertyChanged,
+            this, [this](const QString &key, const QVariant &value) {
+        if (key == QLatin1String("MOUSE_REGION")) {
+            updateMouseRegion(value);
+        }
+        if (key == QLatin1String("GRABBED_KEYS")) {
+            updateGrabbedKeys(value);
+        }
+    });
+}
+
+LipstickCompositorWindow *LipstickCompositorWindow::transientParent() const
+{
+    return m_transientParent.data();
+}
+
+QPoint LipstickCompositorWindow::transientPosition() const
+{
+    return m_transientPosition;
+}
+
+void LipstickCompositorWindow::resize(const QSize &size)
+{
+    if (m_wlShellSurface) {
+        m_wlShellSurface->sendConfigure(size, QWaylandWlShellSurface::BottomLeftEdge);
+    } else if (m_alienSurface) {
+        m_alienSurface->resize(size);
+    }
+}
+
+void LipstickCompositorWindow::ping()
+{
+    if (m_wlShellSurface) {
+        m_wlShellSurface->ping();
+    } else if (m_alienSurface) {
+        m_alienSurface->ping();
+    } else if (QWaylandSurface *surface = m_xdgSurface ? QWaylandQuickItem::surface() : nullptr) {
+        m_pingSerial = m_compositor->m_xdgShell->ping(surface->client());
+    }
 }
 
+void LipstickCompositorWindow::close()
+{
+    if (m_extSurface) {
+        // Qt extension, will only work with Qt applications, difficult to find as it's a
+        // code generated member of an undocumented class. Definition is in surface-extension.xml
+        m_extSurface->send_close();
+    } else if (m_xdgSurface) {
+        // Works with applications that support xdg-shell-v5. Qt applications don't by default
+        // but can if QT_WAYLAND_SHELL_INTEGRATION=xdg-shell-v5 is exported.
+        m_xdgSurface->sendClose();
+    } else if (m_alienSurface) {
+        m_alienSurface->close();
+    } else if (QWaylandSurface *surface = m_wlShellSurface ? QWaylandQuickItem::surface() : nullptr) {
+        // This is a somewhat brutal method. It will disconnect the socket connection to the
+        // application and Qt at least does not know how to deal with that gracefully and will
+        // assert out.
+        surface->client()->close();
+    }
+}
+
+void LipstickCompositorWindow::closePopup()
+{
+    if (m_wlShellSurface) {
+        m_wlShellSurface->sendPopupDone();
+    } else if (m_xdgSurface) {
+        m_xdgSurface->sendClose();
+    } else if (m_extSurface) {
+        m_extSurface->send_close();
+    } else if (m_alienSurface) {
+        m_alienSurface->close();
+    }
+}
+
+void LipstickCompositorWindow::sendOomScore(int score)
+{
+    if (m_alienSurface) {
+        m_alienSurface->sendOomScore(score);
+    }
+}
+
+bool LipstickCompositorWindow::isExposed() const
+{
+    return m_exposed;
+}
+
+void LipstickCompositorWindow::setExposed(bool exposed)
+{
+    if (m_exposed != exposed) {
+        m_exposed = exposed;
+
+        if (m_alienSurface) {
+            if (m_exposed) {
+                m_alienSurface->show(false);
+            } else if (m_exposedAsCover) {
+                m_alienSurface->show(true);
+            } else {
+                m_alienSurface->hide();
+            }
+        } else if (m_extSurface && !m_exposedAsCover) {
+            m_extSurface->sendOnScreenVisibilityChange(m_exposed);
+        }
+
+        emit exposedChanged();
+    }
+}
+
+bool LipstickCompositorWindow::isExposedAsCover() const
+{
+    return m_exposedAsCover;
+}
+
+void LipstickCompositorWindow::setExposedAsCover(bool exposed)
+{
+    if (m_exposedAsCover != exposed) {
+        m_exposedAsCover = exposed;
+
+        if (m_exposed) {
+            // We don't care about the cover state changing because the true window is exposed..
+        } else if (m_alienSurface) {
+            if (m_exposedAsCover) {
+                m_alienSurface->show(true);
+            } else {
+                m_alienSurface->hide();
+            }
+        } else if (m_extSurface) {
+            m_extSurface->sendOnScreenVisibilityChange(m_exposedAsCover);
+        }
+
+        emit exposedAsCoverChanged();
+    }
+}
+
+
 qint16 LipstickCompositorWindow::windowFlags()
 {
     if (m_extSurface) {
@@ -134,16 +407,32 @@ qint16 LipstickCompositorWindow::windowFlags()
     return 0;
 }
 
-QVariantMap LipstickCompositorWindow::windowProperties()
+WindowPropertyMap *LipstickCompositorWindow::windowProperties()
 {
-    if (m_extSurface)
-        return m_extSurface->windowProperties();
-    return QVariantMap();
+    if (!m_windowProperties) {
+        m_windowProperties.reset(new WindowPropertyMap(m_extSurface.data(), surface()));
+    }
+    return m_windowProperties.data();
 }
 
-void LipstickCompositorWindow::setTitle(QString title)
+QVariant LipstickCompositorWindow::windowProperty(const QString &key)
 {
-    m_title = title;
+    return m_extSurface
+            ? WindowPropertyMap::fixupWindowProperty(m_compositor, surface(), m_extSurface->windowProperty(key))
+            : QVariant();
+}
+
+void LipstickCompositorWindow::setTitle(const QString &title)
+{
+    if (m_title != title) {
+        m_title = title;
+
+        emit titleChanged();
+
+        for (WindowModel *model : LipstickCompositor::instance()->m_windowModels) {
+            model->titleChanged(m_windowId);
+        }
+    }
 }
 
 QString LipstickCompositorWindow::title() const
@@ -151,6 +440,63 @@ QString LipstickCompositorWindow::title() const
     return m_title;
 }
 
+QString LipstickCompositorWindow::className() const
+{
+    if (m_wlShellSurface) {
+        return m_wlShellSurface->className();
+    } else if (m_alienSurface) {
+        return m_alienSurface->className();
+    } else {
+        return QString();
+    }
+}
+
+QRect LipstickCompositorWindow::mouseRegionBounds() const
+{
+    return m_mouseRegion;
+}
+
+void LipstickCompositorWindow::updateMouseRegion(const QVariant &value)
+{
+    m_explicitMouseRegion = value.isValid();
+
+    const QRect rect = m_explicitMouseRegion
+            ? value.value<QRegion>().boundingRect()
+            : QRect(0, 0, width(), height());
+    if (m_mouseRegion != rect) {
+        m_mouseRegion = rect;
+        emit mouseRegionBoundsChanged();
+    }
+}
+
+void LipstickCompositorWindow::updateGrabbedKeys(const QVariant &value)
+{
+    const QStringList grabbedKeys = value.value<QStringList>();
+
+    if (m_grabbedKeys.isEmpty() && !grabbedKeys.isEmpty()) {
+        qApp->installEventFilter(this);
+    } else if (!m_grabbedKeys.isEmpty() && grabbedKeys.isEmpty() && m_pressedGrabbedKeys.isEmpty()) {
+        // we don't remove the event filter if m_pressedGrabbedKeys contains still some key.
+        // we wait the key release for that.
+        qApp->removeEventFilter(this);
+    }
+
+    m_grabbedKeys.clear();
+    for (const QString &key : grabbedKeys) {
+        m_grabbedKeys.append(key.toInt());
+    }
+
+    if (LipstickCompositor::instance()->debug()) {
+        qDebug() << "Window" << windowId() << "grabbed keys changed:" << grabbedKeys;
+    }
+}
+
+
+bool LipstickCompositorWindow::isTransient() const
+{
+    return m_transientParent;
+}
+
 void LipstickCompositorWindow::imageAddref(QQuickItem *item)
 {
     Q_ASSERT(!m_refs.contains(item));
@@ -202,6 +548,31 @@ bool LipstickCompositorWindow::eventFilter(QObject *obj, QEvent *event)
         }
         return false;
     }
+
+    if (event->type() == QEvent::KeyPress || event->type() == QEvent::KeyRelease) {
+        QKeyEvent *ke = static_cast<QKeyEvent *>(event);
+        QWaylandSurface *m_surface = surface();
+        if (QtWayland::QtKeyExtensionGlobal *ext = m_surface
+                    && (m_grabbedKeys.contains(ke->key()) || m_pressedGrabbedKeys.contains(ke->key()))
+                    && !ke->isAutoRepeat()
+                ? QtWayland::QtKeyExtensionGlobal::findIn(compositor())
+                : nullptr) {
+            if (event->type() == QEvent::KeyPress) {
+                m_pressedGrabbedKeys << ke->key();
+            }
+
+            ext->postQtKeyEvent(ke, m_surface);
+
+            if (event->type() == QEvent::KeyRelease) {
+                m_pressedGrabbedKeys.removeOne(ke->key());
+                if (m_grabbedKeys.isEmpty()) {
+                    qApp->removeEventFilter(this);
+                }
+            }
+            return true;
+        }
+    }
+
     if (event->type() == QEvent::KeyPress || event->type() == QEvent::KeyRelease) {
         QKeyEvent *ke = static_cast<QKeyEvent *>(event);
         QWaylandSurface *m_surface = surface();
@@ -240,6 +611,20 @@ void LipstickCompositorWindow::itemChange(ItemChange change, const ItemChangeDat
     QWaylandQuickItem::itemChange(change, data);
 }
 
+void LipstickCompositorWindow::geometryChanged(const QRectF &newGeometry, const QRectF &oldGeometry)
+{
+    QWaylandQuickItem::geometryChanged(newGeometry, oldGeometry);
+
+    if (!m_explicitMouseRegion) {
+        QRect rect(0, 0, width(), height());
+
+        if (m_mouseRegion != rect) {
+            m_mouseRegion = rect;
+            emit mouseRegionBoundsChanged();
+        }
+    }
+}
+
 bool LipstickCompositorWindow::event(QEvent *e)
 {
     bool rv = QWaylandQuickItem::event(e);
@@ -253,16 +638,17 @@ bool LipstickCompositorWindow::event(QEvent *e)
 void LipstickCompositorWindow::mousePressEvent(QMouseEvent *event)
 {
     QWaylandSurface *m_surface = surface();
-    if (m_surface && m_surface->inputRegionContains(event->pos()) && event->source() != Qt::MouseEventSynthesizedByQt) {
+    if (m_surface
+            && (!m_explicitMouseRegion || m_mouseRegion.contains(event->pos()))
+            && m_surface->inputRegionContains(event->pos())
+            && event->source() != Qt::MouseEventSynthesizedByQt) {
         QWaylandSeat *inputDevice = m_surface->compositor()->seatFor(event);
-        QWaylandView *v = view();
-        if (inputDevice->mouseFocus() != v) {
-            inputDevice->setMouseFocus(v);
-            if (m_focusOnTouch && inputDevice->keyboardFocus() != m_surface) {
-                takeFocus();
-            }
-        }
+
         inputDevice->sendMousePressEvent(event->button());
+
+        if (m_focusOnTouch) {
+            takeFocus(inputDevice);
+        }
     } else {
         event->ignore();
     }
@@ -332,7 +718,8 @@ void LipstickCompositorWindow::handleTouchEvent(QTouchEvent *event)
 
     if (event->touchPointStates() & Qt::TouchPointPressed) {
         foreach (const QTouchEvent::TouchPoint &p, points) {
-            if (!m_surface->inputRegionContains(p.pos().toPoint())) {
+            if ((m_explicitMouseRegion && !m_mouseRegion.contains(p.pos().toPoint()))
+                    || !m_surface->inputRegionContains(p.pos().toPoint())) {
                 event->ignore();
                 return;
             }
@@ -342,23 +729,19 @@ void LipstickCompositorWindow::handleTouchEvent(QTouchEvent *event)
     QWaylandSeat *inputDevice = m_surface->compositor()->seatFor(event);
     event->accept();
 
-    QWaylandView *vview = view();
-    if (vview && (!vview->surface() || vview->surface()->isCursorSurface()))
-        vview = Q_NULLPTR;
-    inputDevice->setMouseFocus(vview);
-
     QWaylandView *v = view();
     if (inputDevice->mouseFocus() != v) {
         QPoint pointPos;
         if (!points.isEmpty())
             pointPos = points.at(0).pos().toPoint();
-        inputDevice->setMouseFocus(v);
-
-        if (m_focusOnTouch && inputDevice->keyboardFocus() != m_surface) {
-            takeFocus();
-        }
+        inputDevice->sendMouseMoveEvent(v, pointPos, mapToScene(pointPos));
     }
+
     inputDevice->sendFullTouchEvent(surface(), event);
+
+    if (event->type() == QEvent::TouchBegin && m_focusOnTouch) {
+        takeFocus(inputDevice);
+    }
 }
 
 void LipstickCompositorWindow::handleTouchCancel()
@@ -395,18 +778,6 @@ void LipstickCompositorWindow::killProcess()
     }
 }
 
-void LipstickCompositorWindow::connectSurfaceSignals()
-{
-    foreach (const QMetaObject::Connection &connection, m_surfaceConnections) {
-        disconnect(connection);
-    }
-
-    m_surfaceConnections.clear();
-    if (surface()) {
-        m_surfaceConnections << connect(surface(), &QWaylandSurface::configure, this, &LipstickCompositorWindow::committed);
-    }
-}
-
 static bool hwc_windowsurface_is_enabled();
 
 typedef EGLBoolean (EGLAPIENTRYP Ptr_eglHybrisAcquireNativeBufferWL)(EGLDisplay dpy, struct wl_resource *wlBuffer, EGLClientBuffer *buffer);
@@ -419,15 +790,39 @@ static Ptr_eglHybrisReleaseNativeBuffer eglHybrisReleaseNativeBuffer;
 class LipstickCompositorWindowHwcNode : public HwcNode
 {
 public:
-    LipstickCompositorWindowHwcNode(QQuickWindow *window) : HwcNode(window), eglBuffer(0) { }
+    LipstickCompositorWindowHwcNode(QQuickWindow *window) : HwcNode(window) { }
     ~LipstickCompositorWindowHwcNode();
 
-    void update(QWaylandSurfacePrivate *s, EGLClientBuffer newBuffer, void *newHandle, QSGNode *contentNode);
+    void update(EGLClientBuffer newBuffer, void *newHandle, QSGNode *contentNode);
 
-    EGLClientBuffer eglBuffer;
+    EGLClientBuffer eglBuffer = nullptr;
     QWaylandBufferRef waylandBuffer;
 };
 
+class LipstickCompositorWindowNode : public QSGNode
+{
+public:
+    ~LipstickCompositorWindowNode()
+    {
+        delete hwcNode;
+        delete contentNode;
+    }
+
+    void destroyHwcNode()
+    {
+        contentNode->setFlag(QSGNode::OwnedByParent, false);
+        delete hwcNode;
+        hwcNode = nullptr;
+
+        if (!contentNode->parent()) {
+            appendChildNode(contentNode);
+        }
+    }
+
+    QSGNode *contentNode = nullptr;
+    LipstickCompositorWindowHwcNode *hwcNode = nullptr;
+};
+
 static bool lcw_checkForVisibleReferences(const QVector<QQuickItem *> &refs)
 {
     foreach (QQuickItem *i, refs)
@@ -449,8 +844,25 @@ void LipstickCompositorWindow::onSync()
 
 QSGNode *LipstickCompositorWindow::updatePaintNode(QSGNode *old, UpdatePaintNodeData *data)
 {
-    if (!hwc_windowsurface_is_enabled() || m_noHardwareComposition)
+    if (!hwc_windowsurface_is_enabled()) {
         return QWaylandQuickItem::updatePaintNode(old, data);
+    }
+
+    LipstickCompositorWindowNode *node = static_cast<LipstickCompositorWindowNode *>(old);
+    QSGNode * const contentNode = QWaylandQuickItem::updatePaintNode(node ? node->contentNode : nullptr, data);
+
+    if (contentNode && !node) {
+       node = new LipstickCompositorWindowNode;
+    }
+
+    if (node) {
+        node->contentNode = contentNode;
+    }
+
+    if (!contentNode) {
+        delete node;
+        return nullptr;
+    }
 
     // qCDebug(LIPSTICK_LOG_HWC, "LipstickCompositorWindow(%p)::updatePaintNode(), old=%p", this, old);
 
@@ -463,41 +875,25 @@ QSGNode *LipstickCompositorWindow::updatePaintNode(QSGNode *old, UpdatePaintNode
     // Added to this logic, we have the case of a window surface suddenly
     // appearing with a shm buffer. We then need to switch to normal
     // composition.
-
-                               // TODO: a327ca8d8a1f6e0a44a3aa6bd4dac716911c434e
-    bool hwBuffer = surface(); // TODO && surface()->type() == QWaylandSurface::Texture;
-    int wantedNodeType = m_hasVisibleReferences || !hwBuffer ? QSGNode::GeometryNodeType : QSG_HWC_NODE_TYPE;
-    if (old && old->type() != wantedNodeType) {
-        delete old;
-        old = 0;
+    QWaylandBufferRef buffer = view()->currentBuffer();
+    const bool hwBuffer = !m_noHardwareComposition
+            && (buffer.bufferFormatEgl() == QWaylandBufferRef::BufferFormatEgl_RGB
+             || buffer.bufferFormatEgl() == QWaylandBufferRef::BufferFormatEgl_RGBA);
+
+    // If there is no source node or we don't want a composer node return the node from
+    // QWaylandQuickItem now.
+    if (!m_hasVisibleReferences || !hwBuffer) {
+        node->destroyHwcNode();
+        return node;
     }
-    if (m_hasVisibleReferences || !hwBuffer)
-        return QWaylandQuickItem::updatePaintNode(old, data);
 
-    // No surface, abort..
-    if (!surface() || !QWaylandSurfacePrivate::get(surface()) || !surface()->hasContent() || !textureProvider()->texture()) {
-        delete old;
-        return 0;
-    }
-
-    // Follow the unmaplock logic inside QtWayland. If a surface is still
-    // visible but has a null buffer attached, we retain the copy we have
-    // until further notice...
-    QWaylandSurfacePrivate *s = QWaylandSurfacePrivate::get(surface());
-    wl_resource *surfaceBufferHandle = s->bufferRef.hasBuffer() ? s->bufferRef.wl_buffer() : 0;
-    if (!surfaceBufferHandle && surface()->hasContent()) {
+    // QWaylandQuickItem will return a valid source node after the surface has been destroyed
+    // if isBufferLocked() is true. If that happens don't update the compositor node and instead
+    // return the last appropriate node.
+    wl_resource *surfaceBufferHandle = buffer.hasContent() ? buffer.wl_buffer() : nullptr;
+    if (!surfaceBufferHandle) {
         qCDebug(LIPSTICK_LOG_HWC, " - visible with attached 'null' buffer, reusing previous buffer");
-        return old;
-    }
-
-    // Find the old node if applicable and call updatePaintNode on the wayland
-    // surface item. If this results in a null node, we abort.
-    LipstickCompositorWindowHwcNode *hwcNode = old ? static_cast<LipstickCompositorWindowHwcNode *>(old) : 0;
-    QSGNode *oldContentNode = hwcNode ? hwcNode->firstChild() : 0;
-    QSGNode *newContentNode = QWaylandQuickItem::updatePaintNode(oldContentNode, data);
-    if (!newContentNode) {
-        delete old;
-        return 0;
+        return node;
     }
 
     // Check if we can extract the HWC handles from the wayland buffer. If
@@ -508,25 +904,35 @@ QSGNode *LipstickCompositorWindow::updatePaintNode(QSGNode *old, UpdatePaintNode
     if (!eglHybrisAcquireNativeBufferWL(display, surfaceBufferHandle, &eglBuffer)) {
         qCDebug(LIPSTICK_LOG_HWC, " - failed to acquire native buffer (buffers are probably not allocated server-side)");
         m_noHardwareComposition = true;
-        delete old;
-        return QWaylandQuickItem::updatePaintNode(0, data);
+        node->destroyHwcNode();
+        return node;
     }
     eglHybrisNativeBufferHandle(eglGetCurrentDisplay(), eglBuffer, &hwcHandle);
     Q_ASSERT(hwcHandle);
 
     // At this point we know we are visible and we have access to hwc buffers,
     // make sure we have  an HwcNode instance.
-    if (!hwcNode)
-        hwcNode = new LipstickCompositorWindowHwcNode(window());
+    if (!node->hwcNode) {
+        node->hwcNode = new LipstickCompositorWindowHwcNode(window());
+    }
+
+    node->hwcNode->waylandBuffer = buffer;
+
+    if (node->contentNode->parent() == node) {
+        node->removeChildNode(node->contentNode);
+    }
+
+    if (!node->contentNode->parent()) {
+        node->hwcNode->appendChildNode(node->contentNode);
+    }
+
+    if (!node->hwcNode->parent()) {
+        node->appendChildNode(node->hwcNode);
+    }
 
-    // Add the new content node. The old one, if present would already have
-    // been removed because it was deleted in the
-    // QWaylandQuickItem::updatePaintNode() call above.
-    if (newContentNode != hwcNode->firstChild())
-        hwcNode->appendChildNode(newContentNode);
+    node->hwcNode->update(eglBuffer, hwcHandle, node->contentNode);
 
-    hwcNode->update(s, eglBuffer, hwcHandle, newContentNode);
-    return hwcNode;
+    return node;
 }
 
 bool LipstickCompositorWindow::focusOnTouch() const
@@ -612,7 +1018,7 @@ void hwc_windowsurface_release_native_buffer(void *, void *callbackData)
     QCoreApplication::postEvent(e->eventTarget, e);
 }
 
-void LipstickCompositorWindowHwcNode::update(QWaylandSurfacePrivate *s, EGLClientBuffer newBuffer, void *newHandle, QSGNode *contentNode)
+void LipstickCompositorWindowHwcNode::update(EGLClientBuffer newBuffer, void *newHandle, QSGNode *contentNode)
 {
     // If we're taking a new buffer into use when there already was
     // one, set up the old to be removed.
@@ -624,7 +1030,6 @@ void LipstickCompositorWindowHwcNode::update(QWaylandSurfacePrivate *s, EGLClien
     }
     // qCDebug(LIPSTICK_LOG_HWC, " - setting buffers on HwcNode, EGLClientBuffer=%p, gralloc=%p", newBuffer, newHandle);
     eglBuffer = newBuffer;
-    waylandBuffer = QWaylandBufferRef(s->bufferRef);
 
     Q_ASSERT(contentNode->type() == QSGNode::GeometryNodeType);
     HwcNode::update(static_cast<QSGGeometryNode *>(contentNode), newHandle);
diff --git a/src/compositor/lipstickcompositorwindow.h b/src/compositor/lipstickcompositorwindow.h
index add20c90..775d6d3a 100644
--- a/src/compositor/lipstickcompositorwindow.h
+++ b/src/compositor/lipstickcompositorwindow.h
@@ -18,14 +18,26 @@
 
 #include <QWaylandQuickItem>
 #include <QWaylandBufferRef>
-#include <QPointer>
+
 #include <QWaylandWlShellSurface>
 #include "lipstickglobal.h"
 
+#include <QPointer>
+
+QT_BEGIN_NAMESPACE
+
 namespace QtWayland {
     class ExtendedSurface;
 }
+
+class QWaylandXdgSurfaceV5;
+
+QT_END_NAMESPACE
+
+class AlienSurface;
+class LipstickCompositor;
 class LipstickCompositorWindowHwcNode;
+class WindowPropertyMap;
 
 class LIPSTICK_EXPORT LipstickCompositorWindow : public QWaylandQuickItem
 {
@@ -42,11 +54,25 @@ class LIPSTICK_EXPORT LipstickCompositorWindow : public QWaylandQuickItem
     Q_PROPERTY(QString title READ title NOTIFY titleChanged)
     Q_PROPERTY(qint64 processId READ processId CONSTANT)
     Q_PROPERTY(qint16 windowFlags READ windowFlags NOTIFY windowFlagsChanged)
+    Q_PROPERTY(QString className READ className NOTIFY classNameChanged)
+
+    Q_PROPERTY(QRect mouseRegionBounds READ mouseRegionBounds NOTIFY mouseRegionBoundsChanged)
 
     Q_PROPERTY(bool focusOnTouch READ focusOnTouch WRITE setFocusOnTouch NOTIFY focusOnTouchChanged)
 
+    Q_PROPERTY(bool exposed READ isExposed WRITE setExposed NOTIFY exposedChanged)
+    Q_PROPERTY(bool exposedAsCover READ isExposedAsCover WRITE setExposedAsCover NOTIFY exposedAsCoverChanged)
+
+    Q_PROPERTY(WindowPropertyMap *properties READ windowProperties CONSTANT)
+
+    Q_PROPERTY(LipstickCompositorWindow *transientParent READ transientParent NOTIFY transientParentChanged)
+    Q_PROPERTY(QPoint transientPosition READ transientPosition NOTIFY transientPositionChanged)
+
 public:
-    LipstickCompositorWindow(int windowId, const QString &, QWaylandSurface *surface, QQuickItem *parent = 0);
+    LipstickCompositorWindow(int windowId, const QString &, QWaylandSurface *surface = nullptr);
+    LipstickCompositorWindow(int windowId, const QString &, QWaylandWlShellSurface *wlSurface);
+    LipstickCompositorWindow(int windowId, const QString &, QWaylandXdgSurfaceV5 *xdgSurface);
+    LipstickCompositorWindow(int windowId, AlienSurface *alienSurface);
     ~LipstickCompositorWindow();
 
     QVariant userData() const;
@@ -58,12 +84,18 @@ public:
     bool delayRemove() const;
     void setDelayRemove(bool);
 
+    bool isTransient() const;
+
     QString category() const;
     virtual QString title() const;
     virtual bool isInProcess() const;
 
+    QString className() const;
+
     qint16 windowFlags();
 
+    QRect mouseRegionBounds() const;
+
     bool eventFilter(QObject *object, QEvent *event);
 
     Q_INVOKABLE void terminateProcess(int killTimeout);
@@ -73,35 +105,65 @@ public:
     bool focusOnTouch() const;
     void setFocusOnTouch(bool focusOnTouch);
 
-    QVariantMap windowProperties();
+    bool isAlien() const;
+
+    WindowPropertyMap *windowProperties();
+    QVariant windowProperty(const QString &key);
+
+    bool isExposed() const;
+    void setExposed(bool exposed);
+
+    bool isExposedAsCover() const;
+    void setExposedAsCover(bool exposed);
+
+    LipstickCompositorWindow *transientParent() const;
+    QPoint transientPosition() const;
+
+    void sendOomScore(int score);
+
+    QtWayland::ExtendedSurface *extendedSurface();
+
+    Q_INVOKABLE void resize(const QSize &size);
+    Q_INVOKABLE void ping();
+    Q_INVOKABLE void close();
+    Q_INVOKABLE void closePopup();
 
 protected:
-    void itemChange(ItemChange change, const ItemChangeData &data);
+    void setTitle(const QString &title);
+
+    void itemChange(ItemChange change, const ItemChangeData &data) override;
+    void geometryChanged(const QRectF &newGeometry, const QRectF &oldGeometry) override;
 
-    virtual bool event(QEvent *);
-    virtual void mousePressEvent(QMouseEvent *event);
-    virtual void mouseMoveEvent(QMouseEvent *event);
-    virtual void mouseReleaseEvent(QMouseEvent *event);
-    virtual void wheelEvent(QWheelEvent *event);
-    virtual void touchEvent(QTouchEvent *event);
+    virtual bool event(QEvent *) override;
+    virtual void mousePressEvent(QMouseEvent *event) override;
+    virtual void mouseMoveEvent(QMouseEvent *event) override;
+    virtual void mouseReleaseEvent(QMouseEvent *event) override;
+    virtual void wheelEvent(QWheelEvent *event) override;
+    virtual void touchEvent(QTouchEvent *event) override;
 
 signals:
     void userDataChanged();
     void titleChanged();
+    void classNameChanged();
     void delayRemoveChanged();
-    void committed();
     void focusOnTouchChanged();
     void windowFlagsChanged();
+    void mouseRegionBoundsChanged();
+    void pong();
+    void exposedChanged();
+    void exposedAsCoverChanged();
+    void transientParentChanged();
+    void transientPositionChanged();
 
 private slots:
     void handleTouchCancel();
     void killProcess();
-    void connectSurfaceSignals();
 
 private:
     friend class LipstickCompositor;
     friend class WindowModel;
     friend class WindowPixmapItem;
+
     void imageAddref(QQuickItem *item);
     void imageRelease(QQuickItem *item);
     void onSync();
@@ -111,26 +173,41 @@ private:
     void handleTouchEvent(QTouchEvent *e);
 
     void setExtendedSurface(QtWayland::ExtendedSurface *extSurface);
-    QtWayland::ExtendedSurface *extendedSurface();
-    void setTitle(QString title);
-    QString m_title;
 
-    int m_windowId;
-    bool m_isAlien;
+    inline void updateMouseRegion(const QVariant &value);
+    inline void updateGrabbedKeys(const QVariant &value);
+
+    QString m_title;
     QString m_category;
-    bool m_delayRemove:1;
-    bool m_windowClosed:1;
-    bool m_removePosted:1;
-    bool m_interceptingTouch:1;
+    QVariant m_data;
+
+    QVector<QQuickItem *> m_refs;
+    QPointer<QtWayland::ExtendedSurface> m_extSurface;
+    QPointer<QWaylandWlShellSurface> m_wlShellSurface;
+    QPointer<QWaylandXdgSurfaceV5> m_xdgSurface;
+    QPointer<AlienSurface> m_alienSurface;
+    QPointer<LipstickCompositorWindow> m_transientParent;
+    QScopedPointer<WindowPropertyMap> m_windowProperties;
+    QList<int> m_grabbedKeys;
+    QList<int> m_pressedGrabbedKeys;
+
+    QRect m_mouseRegion;
+    QPoint m_transientPosition;
+    LipstickCompositor * const m_compositor;
+    const int m_windowId;
+    uint m_pingSerial = 0;
+    bool m_isAlien : 1;
+    bool m_delayRemove : 1;
+    bool m_windowClosed : 1;
+    bool m_removePosted : 1;
+    bool m_interceptingTouch : 1;
     bool m_mapped : 1;
     bool m_noHardwareComposition: 1;
     bool m_focusOnTouch : 1;
     bool m_hasVisibleReferences : 1;
-    QVariant m_data;
-    QList<QMetaObject::Connection> m_surfaceConnections;
-    QVector<QQuickItem *> m_refs;
-    QtWayland::ExtendedSurface *m_extSurface;
-    QWaylandWlShellSurface *m_wlShellSurface;
+    bool m_exposed : 1;
+    bool m_exposedAsCover : 1;
+    bool m_explicitMouseRegion : 1;
 };
 
 #endif // LIPSTICKCOMPOSITORWINDOW_H
diff --git a/src/compositor/windowmodel.h b/src/compositor/windowmodel.h
index 24c351fb..ee878191 100644
--- a/src/compositor/windowmodel.h
+++ b/src/compositor/windowmodel.h
@@ -57,6 +57,8 @@ public slots:
 
 private:
     friend class LipstickCompositor;
+    friend class LipstickCompositorWindow;
+
     void setCompositor(LipstickCompositor *);
 
     void addItem(int);
diff --git a/src/compositor/windowpixmapitem.cpp b/src/compositor/windowpixmapitem.cpp
index 36dc2420..445f252c 100644
--- a/src/compositor/windowpixmapitem.cpp
+++ b/src/compositor/windowpixmapitem.cpp
@@ -13,20 +13,364 @@
 **
 ****************************************************************************/
 
-#include "windowpixmapitem.h"
-#include "lipstickcompositor.h"
+#include <QtCore/qmath.h>
+#include <QSGGeometryNode>
+#include <QSGSimpleMaterial>
+#include <QOpenGLFramebufferObject>
+#include <QWaylandQuickItem>
 #include "lipstickcompositorwindow.h"
-#include <QDebug>
+#include "lipstickcompositor.h"
+#include "windowpixmapitem.h"
+
+namespace {
+
+class SurfaceTextureState {
+public:
+    SurfaceTextureState() : m_texture(0), m_xScale(1), m_yScale(1) {}
+    void setTexture(QSGTexture *texture) { m_texture = texture; }
+    QSGTexture *texture() const { return m_texture; }
+    void setXOffset(float xOffset) { m_xOffset = xOffset; }
+    float xOffset() const { return m_xOffset; }
+    void setYOffset(float yOffset) { m_yOffset = yOffset; }
+    float yOffset() const { return m_yOffset; }
+    void setXScale(float xScale) { m_xScale = xScale; }
+    float xScale() const { return m_xScale; }
+    void setYScale(float yScale) { m_yScale = yScale; }
+    float yScale() const { return m_yScale; }
+
+private:
+    QSGTexture *m_texture;
+    float m_xOffset;
+    float m_yOffset;
+    float m_xScale;
+    float m_yScale;
+};
+
+class SurfaceTextureMaterial : public QSGSimpleMaterialShader<SurfaceTextureState>
+{
+    QSG_DECLARE_SIMPLE_SHADER(SurfaceTextureMaterial, SurfaceTextureState)
+public:
+    QList<QByteArray> attributes() const;
+    void updateState(const SurfaceTextureState *newState, const SurfaceTextureState *oldState);
+protected:
+    void initialize();
+    const char *vertexShader() const;
+    const char *fragmentShader() const;
+private:
+    int m_id_texOffset;
+    int m_id_texScale;
+};
+
+class SurfaceNode : public QObject, public QSGGeometryNode
+{
+    Q_OBJECT
+public:
+    QSGNode *sourceNode = nullptr;
+
+    SurfaceNode();
+    ~SurfaceNode();
+    void setRect(const QRectF &);
+    void setTextureProvider(QSGTextureProvider *, bool owned);
+    void setBlending(bool);
+    void setRadius(qreal radius);
+    void setXOffset(qreal xOffset);
+    void setYOffset(qreal yOffset);
+    void setXScale(qreal xScale);
+    void setYScale(qreal yScale);
+    void setUpdateTexture(bool upd);
+
+private:
+    void providerDestroyed();
+    void textureChanged();
+
+    void setTexture(QSGTexture *texture);
+    void updateGeometry();
+
+    QSGSimpleMaterial<SurfaceTextureState> *m_material;
+    QRectF m_rect;
+    qreal m_radius;
+
+    QPointer<QSGTextureProvider> m_provider;
+    QPointer<QSGTexture> m_texture;
+    QSGGeometry m_geometry;
+    QRectF m_textureRect;
+    bool m_providerOwned;
+};
+
+QList<QByteArray> SurfaceTextureMaterial::attributes() const
+{
+    QList<QByteArray> attributeList;
+    attributeList << "qt_VertexPosition";
+    attributeList << "qt_VertexTexCoord";
+    return attributeList;
+}
+
+void SurfaceTextureMaterial::updateState(const SurfaceTextureState *newState,
+                                         const SurfaceTextureState *)
+{
+    Q_ASSERT(newState->texture());
+    if (QSGTexture *tex = newState->texture())
+        tex->bind();
+    program()->setUniformValue(m_id_texOffset, newState->xOffset(), newState->yOffset());
+    program()->setUniformValue(m_id_texScale, newState->xScale(), newState->yScale());
+}
+
+void SurfaceTextureMaterial::initialize()
+{
+    QSGSimpleMaterialShader::initialize();
+    m_id_texOffset = program()->uniformLocation("texOffset");
+    m_id_texScale = program()->uniformLocation("texScale");
+}
+
+const char *SurfaceTextureMaterial::vertexShader() const
+{
+    return "uniform highp mat4 qt_Matrix;                      \n"
+           "attribute highp vec4 qt_VertexPosition;            \n"
+           "attribute highp vec2 qt_VertexTexCoord;            \n"
+           "varying highp vec2 qt_TexCoord;                    \n"
+           "uniform highp vec2 texOffset;                      \n"
+           "uniform highp vec2 texScale;                       \n"
+           "void main() {                                      \n"
+           "    qt_TexCoord = qt_VertexTexCoord * texScale + texOffset;\n"
+           "    gl_Position = qt_Matrix * qt_VertexPosition;   \n"
+           "}";
+}
+
+const char *SurfaceTextureMaterial::fragmentShader() const
+{
+    return "varying highp vec2 qt_TexCoord;                    \n"
+           "uniform sampler2D qt_Texture;                      \n"
+           "uniform lowp float qt_Opacity;                     \n"
+           "void main() {                                      \n"
+           "    gl_FragColor = texture2D(qt_Texture, qt_TexCoord) * qt_Opacity; \n"
+           "}";
+}
+
+SurfaceNode::SurfaceNode()
+    : m_material(0)
+    , m_radius(0)
+    , m_provider(0)
+    , m_texture(0)
+    , m_geometry(QSGGeometry::defaultAttributes_TexturedPoint2D(), 0)
+{
+    setGeometry(&m_geometry);
+    m_material = SurfaceTextureMaterial::createMaterial();
+    setMaterial(m_material);
+}
+
+SurfaceNode::~SurfaceNode()
+{
+    if (m_provider && m_providerOwned)
+        delete m_provider.data();
+
+    delete sourceNode;
+}
+
+void SurfaceNode::setRect(const QRectF &r)
+{
+    if (m_rect == r)
+        return;
+
+    m_rect = r;
+
+    updateGeometry();
+}
+
+void SurfaceNode::setTextureProvider(QSGTextureProvider *p, bool owned)
+{
+    if (p == m_provider)
+        return;
+
+    if (m_provider) {
+        disconnect(m_provider.data(), &QObject::destroyed, this, &SurfaceNode::providerDestroyed);
+        disconnect(m_provider.data(), &QSGTextureProvider::textureChanged, this, &SurfaceNode::textureChanged);
+        m_provider = 0;
+    }
+
+    m_provider = p;
+    m_providerOwned = owned;
+
+    if (m_provider) {
+        connect(m_provider.data(), &QObject::destroyed, this, &SurfaceNode::providerDestroyed);
+        connect(m_provider.data(), &QSGTextureProvider::textureChanged, this, &SurfaceNode::textureChanged);
+
+        setTexture(m_provider->texture());
+    }
+}
+
+void SurfaceNode::updateGeometry()
+{
+    if (m_texture) {
+        QSize ts = m_texture->textureSize();
+        QRectF sourceRect(0, 0, ts.width(), ts.height());
+        QRectF textureRect = m_texture->convertToNormalizedSourceRect(sourceRect);
+
+        if (m_radius) {
+            float radius = qMin(float(qMin(m_rect.width(), m_rect.height()) * 0.5f), float(m_radius));
+            int segments = qBound(5, qCeil(radius * (M_PI / 6)), 18);
+            float angle = 0.5f * float(M_PI) / segments;
+
+            m_geometry.allocate((segments + 1) * 2 * 2);
+
+            QSGGeometry::TexturedPoint2D *v = m_geometry.vertexDataAsTexturedPoint2D();
+            QSGGeometry::TexturedPoint2D *vlast = v + (segments + 1) * 2 * 2 - 2;
+
+            float textureXRadius = radius * textureRect.width() / m_rect.width();
+            float textureYRadius = radius * textureRect.height() / m_rect.height();
+
+            float c = 1; float cosStep = qFastCos(angle);
+            float s = 0; float sinStep = qFastSin(angle);
+
+            for (int ii = 0; ii <= segments; ++ii) {
+                float px = m_rect.left() + radius - radius * c;
+                float tx = textureRect.left() + textureXRadius - textureXRadius * c;
 
-WindowPixmapItem::WindowPixmapItem() : m_id(0)
+                float px2 = m_rect.right() - radius + radius * c;
+                float tx2 = textureRect.right() - textureXRadius + textureXRadius * c;
+
+                float py = m_rect.top() + radius - radius * s;
+                float ty = textureRect.top() + textureYRadius - textureYRadius * s;
+
+                float py2 = m_rect.bottom() - radius + radius * s;
+                float ty2 = textureRect.bottom() - textureYRadius + textureYRadius * s;
+
+                v[0].x = px; v[0].y = py;
+                v[0].tx = tx; v[0].ty = ty;
+
+                v[1].x = px; v[1].y = py2;
+                v[1].tx = tx; v[1].ty = ty2;
+
+                vlast[0].x = px2; vlast[0].y = py;
+                vlast[0].tx = tx2; vlast[0].ty = ty;
+
+                vlast[1].x = px2; vlast[1].y = py2;
+                vlast[1].tx = tx2; vlast[1].ty = ty2;
+
+                v += 2;
+                vlast -= 2;
+
+                float t = c;
+                c = c * cosStep - s * sinStep;
+                s = s * cosStep + t * sinStep;
+            }
+        } else {
+            m_geometry.allocate(4);
+            QSGGeometry::updateTexturedRectGeometry(&m_geometry, m_rect, textureRect);
+        }
+
+        markDirty(DirtyGeometry);
+    }
+}
+
+void SurfaceNode::setBlending(bool b)
+{
+    m_material->setFlag(QSGMaterial::Blending, b);
+}
+
+void SurfaceNode::setRadius(qreal radius)
+{
+    if (m_radius == radius)
+        return;
+
+    m_radius = radius;
+
+    updateGeometry();
+}
+
+void SurfaceNode::setTexture(QSGTexture *texture)
+{
+    m_material->state()->setTexture(texture);
+
+    QRectF tr;
+    if (texture) tr = texture->convertToNormalizedSourceRect(QRect(QPoint(0,0), texture->textureSize()));
+
+    bool ug = !m_texture || tr != m_textureRect;
+
+    m_texture = texture;
+    m_textureRect = tr;
+
+    if (ug) updateGeometry();
+
+    markDirty(DirtyMaterial);
+}
+
+void SurfaceNode::setXOffset(qreal offset)
+{
+    m_material->state()->setXOffset(offset);
+
+    markDirty(DirtyMaterial);
+}
+
+void SurfaceNode::setYOffset(qreal offset)
+{
+    m_material->state()->setYOffset(offset);
+
+    markDirty(DirtyMaterial);
+}
+
+void SurfaceNode::setXScale(qreal xScale)
+{
+    m_material->state()->setXScale(xScale);
+
+    markDirty(DirtyMaterial);
+}
+
+void SurfaceNode::setYScale(qreal yScale)
+{
+    m_material->state()->setYScale(yScale);
+
+    markDirty(DirtyMaterial);
+}
+
+void SurfaceNode::textureChanged()
+{
+    setTexture(m_provider->texture());
+}
+
+void SurfaceNode::providerDestroyed()
+{
+    m_provider = 0;
+    setTexture(0);
+}
+
+}
+
+SnapshotProgram *WindowPixmapItem::s_snapshotProgram = 0;
+
+struct SnapshotProgram
+{
+    QOpenGLShaderProgram program;
+    int vertexLocation;
+    int textureLocation;
+};
+
+class SnapshotTextureProvider : public QSGTextureProvider
+{
+public:
+    SnapshotTextureProvider() : t(0), fbo(0) {}
+    ~SnapshotTextureProvider()
+    {
+        delete fbo;
+        delete t;
+    }
+    QSGTexture *texture() const Q_DECL_OVERRIDE
+    {
+        return t;
+    }
+    QSGTexture *t;
+    QOpenGLFramebufferObject *fbo;
+};
+
+
+WindowPixmapItem::WindowPixmapItem()
 {
     setSizeFollowsSurface(false);
-    setEnabled(false);
+    setInputEventsEnabled(false);
+    setTouchEventsEnabled(false);
 }
 
 WindowPixmapItem::~WindowPixmapItem()
 {
-    setWindowId(0);
 }
 
 int WindowPixmapItem::windowId() const
@@ -38,14 +382,325 @@ void WindowPixmapItem::setWindowId(int id)
 {
     if (m_id == id)
         return;
+
+    const QSize oldSize = m_windowSize;
+    const bool hadPixmap = m_hasPixmap;
+
     m_id = id;
-    LipstickCompositor *c = LipstickCompositor::instance();
-    if (c && m_id) {
-        LipstickCompositorWindow *w = static_cast<LipstickCompositorWindow *>(c->windowForId(m_id));
 
-        if (w)
-            setSurface(w->surface());
+    LipstickCompositorWindow *window = m_id != 0
+                ? LipstickCompositor::instance()->windowForId(m_id)
+                : nullptr;
+    if (QWaylandSurface *surface = window ? window->surface() : nullptr) {
+        QWaylandSurface *oldSurface = QWaylandQuickItem::surface();
+
+        if(oldSurface) {
+            disconnect(oldSurface, &QWaylandSurface::sizeChanged, this, &WindowPixmapItem::handleWindowSizeChanged);
+            disconnect(oldSurface, &QWaylandSurface::hasContentChanged, this, &WindowPixmapItem::handleHasContentChanged);
+            disconnect(oldSurface, &QWaylandSurface::surfaceDestroyed, this, &WindowPixmapItem::surfaceDestroyed);
+        }
+
+        connect(surface, &QWaylandSurface::sizeChanged, this, &WindowPixmapItem::handleWindowSizeChanged);
+        connect(surface, &QWaylandSurface::hasContentChanged, this, &WindowPixmapItem::handleHasContentChanged);
+        connect(surface, &QWaylandSurface::surfaceDestroyed, this, &WindowPixmapItem::surfaceDestroyed);
+
+        m_windowSize = surface->size();
+        m_hasPixmap = surface->hasContent();
+        m_surfaceDestroyed = false;
+
+        setSurface(surface);
     }
+
     emit windowIdChanged();
+
+    if (m_windowSize != oldSize) {
+        emit windowSizeChanged();
+    }
+
+    if (m_hasPixmap != hadPixmap) {
+        emit hasPixmapChanged();
+    }
+}
+
+void WindowPixmapItem::surfaceDestroyed()
+{
+    m_surfaceDestroyed = true;
+
+    update();
+}
+
+bool WindowPixmapItem::hasPixmap() const
+{
+    return m_hasPixmap;
+}
+
+bool WindowPixmapItem::opaque() const
+{
+    return m_opaque;
+}
+
+void WindowPixmapItem::setOpaque(bool o)
+{
+    if (m_opaque == o)
+        return;
+
+    m_opaque = o;
+    update();
+
+    emit opaqueChanged();
+}
+
+qreal WindowPixmapItem::radius() const
+{
+    return m_radius;
+}
+
+void WindowPixmapItem::setRadius(qreal r)
+{
+    if (m_radius == r)
+        return;
+
+    m_radius = r;
+    update();
+
+    emit radiusChanged();
+}
+
+qreal WindowPixmapItem::xOffset() const
+{
+    return m_xOffset;
+}
+
+void WindowPixmapItem::setXOffset(qreal xOffset)
+{
+    if (m_xOffset == xOffset)
+        return;
+
+    m_xOffset = xOffset;
+    update();
+
+    emit xOffsetChanged();
+}
+
+qreal WindowPixmapItem::yOffset() const
+{
+    return m_yOffset;
+}
+
+void WindowPixmapItem::setYOffset(qreal yOffset)
+{
+    if (m_yOffset == yOffset)
+        return;
+
+    m_yOffset = yOffset;
+    update();
+
+    emit yOffsetChanged();
+}
+
+qreal WindowPixmapItem::xScale() const
+{
+    return m_xScale;
+}
+
+void WindowPixmapItem::setXScale(qreal xScale)
+{
+    if (m_xScale == xScale)
+        return;
+
+    m_xScale = xScale;
+    if (m_haveSnapshot) update();
+
+    emit xScaleChanged();
+}
+
+qreal WindowPixmapItem::yScale() const
+{
+    return m_yScale;
+}
+
+void WindowPixmapItem::setYScale(qreal yScale)
+{
+    if (m_yScale == yScale)
+        return;
+
+    m_yScale = yScale;
+    if (m_haveSnapshot) update();
+
+    emit yScaleChanged();
+}
+
+QSize WindowPixmapItem::windowSize() const
+{
+    return m_windowSize;
+}
+
+void WindowPixmapItem::handleWindowSizeChanged()
+{
+    if (QWaylandSurface *surface = QWaylandQuickItem::surface()) {
+        const QSize size = surface->size();
+        if (size.isValid() && size != m_windowSize) {
+            // Window size is retained even when surface is destroyed. This allows snapshots to continue
+            // rendering correctly.
+            m_windowSize = size;
+            emit windowSizeChanged();
+        }
+    }
+}
+
+bool WindowPixmapItem::isTextureProvider() const
+{
+    return m_haveSnapshot || QWaylandQuickItem::isTextureProvider();
+}
+
+QSGTextureProvider *WindowPixmapItem::textureProvider() const
+{
+    return m_haveSnapshot ? m_textureProvider : QWaylandQuickItem::textureProvider();
+}
+
+QSGNode *WindowPixmapItem::updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *data)
+{
+    QSGTextureProvider *provider = textureProvider();
+
+    if (QSGTexture *texture = m_surfaceDestroyed && !m_haveSnapshot && provider
+            ? provider->texture()
+            : nullptr) {
+        // If the surface has been destroyed capture a screenshot of its last buffer to display
+        // from now on. We need to do this before updating the QWaylandQuickItem's paint node
+        // has that will release texture after the surface has been destroyed.
+        if (!m_textureProvider) {
+            m_textureProvider = new SnapshotTextureProvider;
+
+            if (!s_snapshotProgram) {
+                s_snapshotProgram = new SnapshotProgram;
+                s_snapshotProgram->program.addShaderFromSourceCode(QOpenGLShader::Vertex,
+                    "attribute highp vec4 vertex;\n"
+                    "varying highp vec2 texPos;\n"
+                    "void main(void) {\n"
+                    "   texPos = vertex.xy;\n"
+                    "   gl_Position = vec4(vertex.xy * 2.0 - 1.0, 0, 1);\n"
+                    "}");
+                s_snapshotProgram->program.addShaderFromSourceCode(QOpenGLShader::Fragment,
+                    "uniform sampler2D texture;\n"
+                    "varying highp vec2 texPos;\n"
+                    "void main(void) {\n"
+                    "   gl_FragColor = texture2D(texture, texPos);\n"
+                    "}");
+                if (!s_snapshotProgram->program.link())
+                    qWarning() << s_snapshotProgram->program.log();
+
+                s_snapshotProgram->vertexLocation = s_snapshotProgram->program.attributeLocation("vertex");
+                s_snapshotProgram->textureLocation = s_snapshotProgram->program.uniformLocation("texture");
+
+                connect(window(), &QQuickWindow::sceneGraphInvalidated, this, &WindowPixmapItem::cleanupOpenGL);
+            }
+        }
+
+        const QSize size(qRound(width()), qRound(height()));
+
+        if (!m_textureProvider->fbo || m_textureProvider->fbo->size() != size) {
+            delete m_textureProvider->fbo;
+            delete m_textureProvider->t;
+            m_textureProvider->t = 0;
+            m_textureProvider->fbo = new QOpenGLFramebufferObject(size);
+        }
+
+        m_textureProvider->fbo->bind();
+        s_snapshotProgram->program.bind();
+
+        texture->bind();
+
+        static GLfloat const triangleVertices[] = {
+            1.f, 0.f,
+            1.f, 1.f,
+            0.f, 0.f,
+            0.f, 1.f,
+        };
+        s_snapshotProgram->program.enableAttributeArray(s_snapshotProgram->vertexLocation);
+        s_snapshotProgram->program.setAttributeArray(s_snapshotProgram->vertexLocation, triangleVertices, 2);
+
+        glViewport(0, 0, size.width(), size.height());
+        glDisable(GL_BLEND);
+        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+
+        s_snapshotProgram->program.release();
+
+        if (!m_textureProvider->t) {
+            m_textureProvider->t = window()->createTextureFromId(m_textureProvider->fbo->texture(), size, 0);
+            emit m_textureProvider->textureChanged();
+        }
+        m_textureProvider->fbo->release();
+
+        s_snapshotProgram->program.disableAttributeArray(s_snapshotProgram->vertexLocation);
+
+        provider = m_textureProvider;
+        m_haveSnapshot = true;
+        m_surfaceDestroyed = false;
+
+        if(QWaylandSurface *oldSurface = QWaylandQuickItem::surface()) {
+            // Odds on the surface will be destroyed when setSurface releases its held reference
+            // but if its not we don't want any of these signals to come back to haunt us.
+            disconnect(oldSurface, &QWaylandSurface::sizeChanged, this, &WindowPixmapItem::handleWindowSizeChanged);
+            disconnect(oldSurface, &QWaylandSurface::hasContentChanged, this, &WindowPixmapItem::handleHasContentChanged);
+            disconnect(oldSurface, &QWaylandSurface::surfaceDestroyed, this, &WindowPixmapItem::surfaceDestroyed);
+            setSurface(nullptr);
+        }
+    }
+
+    SurfaceNode *node = static_cast<SurfaceNode *>(oldNode);
+
+    // Update QWaylandQuickItem's paint node as that will construct the texture provider.
+    QSGNode *sourceNode = QWaylandQuickItem::updatePaintNode(node ? node->sourceNode : nullptr, data);
+
+    if (!m_haveSnapshot && !sourceNode) {
+        if (node) {
+            node->sourceNode = nullptr;
+            delete node;
+        }
+        return nullptr;
+    }
+
+    if (sourceNode) {
+        m_haveSnapshot = false;
+    }
+
+    if (!node) {
+        node = new SurfaceNode;
+    }
+
+    node->sourceNode = sourceNode;
+    node->setTextureProvider(
+                m_haveSnapshot ? m_textureProvider : QWaylandQuickItem::textureProvider(),
+                m_haveSnapshot);
+    node->setRect(QRectF(0, 0, width(), height()));
+    node->setBlending(!m_opaque);
+    node->setRadius(m_radius);
+    node->setXOffset(m_xOffset);
+    node->setYOffset(m_yOffset);
+    node->setXScale(m_xScale);
+    node->setYScale(m_yScale);
+
+    return node;
+}
+
+void WindowPixmapItem::handleHasContentChanged()
+{
+    const bool hadPixmap = m_hasPixmap;
+
+    if (QWaylandSurface *surface = QWaylandQuickItem::surface()) {
+        m_hasPixmap = surface->hasContent();
+    }
+
+    if (m_hasPixmap != hadPixmap) {
+        emit hasPixmapChanged();
+    }
+}
+
+void WindowPixmapItem::cleanupOpenGL()
+{
+    disconnect(window(), &QQuickWindow::sceneGraphInvalidated, this, &WindowPixmapItem::cleanupOpenGL);
+    delete s_snapshotProgram;
+    s_snapshotProgram = 0;
 }
 
+#include "windowpixmapitem.moc"
diff --git a/src/compositor/windowpixmapitem.h b/src/compositor/windowpixmapitem.h
index 8df7d29e..a55d2eb6 100644
--- a/src/compositor/windowpixmapitem.h
+++ b/src/compositor/windowpixmapitem.h
@@ -16,13 +16,27 @@
 #ifndef WINDOWPIXMAPITEM_H
 #define WINDOWPIXMAPITEM_H
 
+#include "lipstickglobal.h"
+
 #include <QWaylandQuickItem>
-#include "lipstickapi.h"
 
+class QWaylandUnmapLock;
+
+class LipstickCompositor;
+class LipstickCompositorWindow;
+class SnapshotTextureProvider;
 class LIPSTICK_EXPORT WindowPixmapItem : public QWaylandQuickItem
 {
     Q_OBJECT
     Q_PROPERTY(int windowId READ windowId WRITE setWindowId NOTIFY windowIdChanged)
+    Q_PROPERTY(bool hasPixmap READ hasPixmap NOTIFY hasPixmapChanged)
+    Q_PROPERTY(bool opaque READ opaque WRITE setOpaque NOTIFY opaqueChanged)
+    Q_PROPERTY(qreal radius READ radius WRITE setRadius NOTIFY radiusChanged)
+    Q_PROPERTY(QSize windowSize READ windowSize NOTIFY windowSizeChanged)
+    Q_PROPERTY(qreal xOffset READ xOffset WRITE setXOffset NOTIFY xOffsetChanged)
+    Q_PROPERTY(qreal yOffset READ yOffset WRITE setYOffset NOTIFY yOffsetChanged)
+    Q_PROPERTY(qreal xScale READ xScale WRITE setXScale NOTIFY xScaleChanged)
+    Q_PROPERTY(qreal yScale READ yScale WRITE setYScale NOTIFY yScaleChanged)
 
 public:
     WindowPixmapItem();
@@ -31,12 +45,67 @@ public:
     int windowId() const;
     void setWindowId(int);
 
+    bool hasPixmap() const;
+
+    bool opaque() const;
+    void setOpaque(bool);
+
+    qreal radius() const;
+    void setRadius(qreal);
+
+    QSize windowSize() const;
+
+    qreal xOffset() const;
+    void setXOffset(qreal);
+
+    qreal yOffset() const;
+    void setYOffset(qreal);
+
+    qreal xScale() const;
+    void setXScale(qreal);
+
+    qreal yScale() const;
+    void setYScale(qreal);
+
+    bool isTextureProvider() const;
+    QSGTextureProvider *textureProvider() const;
+
+protected:
+    QSGNode *updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *) override;
+
 signals:
     void windowIdChanged();
+    void hasPixmapChanged();
+    void opaqueChanged();
+    void radiusChanged();
+    void windowSizeChanged();
+    void xOffsetChanged();
+    void yOffsetChanged();
+    void xScaleChanged();
+    void yScaleChanged();
+
 
 private:
-    void updateItem();
-    int m_id;
+    inline void handleWindowSizeChanged();
+    inline void handleHasContentChanged();
+    inline void updateItem();
+    inline void surfaceDestroyed();
+    inline void cleanupOpenGL();
+
+    qreal m_radius = 0;
+    qreal m_xOffset = 0;
+    qreal m_yOffset = 0;
+    qreal m_xScale = 1;
+    qreal m_yScale = 1;
+    QSize m_windowSize;
+    SnapshotTextureProvider *m_textureProvider = nullptr;
+    int m_id = 0;
+    bool m_opaque = false;
+    bool m_hasPixmap = false;
+    bool m_surfaceDestroyed = false;
+    bool m_haveSnapshot = false;
+
+    static struct SnapshotProgram *s_snapshotProgram;
 };
 
 #endif // WINDOWPIXMAPITEM_H
diff --git a/src/compositor/windowpropertymap.cpp b/src/compositor/windowpropertymap.cpp
new file mode 100644
index 00000000..86b68162
--- /dev/null
+++ b/src/compositor/windowpropertymap.cpp
@@ -0,0 +1,73 @@
+/***************************************************************************
+**
+** Copyright (C) 2013 Jolla Ltd.
+** Contact: Aaron Kennedy <aaron.kennedy@jollamobile.com>
+**
+** This file is part of lipstick.
+**
+** This library is free software; you can redistribute it and/or
+** modify it under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation
+** and appearing in the file LICENSE.LGPL included in the packaging
+** of this file.
+**
+****************************************************************************/
+
+#include "windowpropertymap.h"
+
+#include "lipstickcompositorwindow.h"
+#include "lipstickcompositor.h"
+
+#include <private/qwlextendedsurface_p.h>
+
+WindowPropertyMap::WindowPropertyMap(
+        QtWayland::ExtendedSurface *surface, QWaylandSurface *waylandSurface, QObject *parent)
+    : QQmlPropertyMap(parent)
+    , m_surface(surface)
+    , m_waylandSurface(waylandSurface)
+{
+    if (m_surface) {
+        // this must use a queued connection in order to avoid QTBUG-32859
+        connect(m_surface.data(), &QtWayland::ExtendedSurface::windowPropertyChanged,
+                this, &WindowPropertyMap::insertWindowProperty, Qt::QueuedConnection);
+
+        const auto windowProperties = m_surface->windowProperties();
+        for (auto it = windowProperties.begin(); it != windowProperties.end(); ++it) {
+            insertWindowProperty(it.key(), it.value());
+        }
+    }
+}
+
+WindowPropertyMap::~WindowPropertyMap()
+{
+}
+
+QVariant WindowPropertyMap::fixupWindowProperty(
+        LipstickCompositor *compositor, QWaylandSurface *surface, const QVariant &value)
+{
+    if (value.type() == QVariant::String) {
+        const QString string = value.toString();
+        if (string.startsWith(QLatin1String("__winref:"))) {
+            const uint id = string.midRef(9).toUInt();
+            if (id != 0) {
+                return compositor->windowIdForLink(surface, id);
+            } else {
+                return 0;
+            }
+        }
+    }
+    return value;
+}
+
+QVariant WindowPropertyMap::updateValue(const QString &key, const QVariant &input)
+{
+    if (m_surface) {
+        m_surface->setWindowProperty(key, input);
+    }
+    return QQmlPropertyMap::updateValue(key, input);
+}
+
+void WindowPropertyMap::insertWindowProperty(const QString &key, const QVariant &value)
+{
+    insert(key, fixupWindowProperty(LipstickCompositor::instance(), m_waylandSurface.data(), value));
+}
diff --git a/src/compositor/windowpropertymap.h b/src/compositor/windowpropertymap.h
new file mode 100644
index 00000000..48f7c92c
--- /dev/null
+++ b/src/compositor/windowpropertymap.h
@@ -0,0 +1,48 @@
+/***************************************************************************
+**
+** Copyright (C) 2013 Jolla Ltd.
+** Contact: Aaron Kennedy <aaron.kennedy@jollamobile.com>
+**
+** This file is part of lipstick.
+**
+** This library is free software; you can redistribute it and/or
+** modify it under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation
+** and appearing in the file LICENSE.LGPL included in the packaging
+** of this file.
+**
+****************************************************************************/
+
+#ifndef WINDOWPROPERTY_H
+#define WINDOWPROPERTY_H
+
+#include <QObject>
+#include <QPointer>
+#include <QVariant>
+#include "lipstickcompositorwindow.h"
+#include <QQmlPropertyMap>
+
+class QWaylandSurface;
+
+
+class LIPSTICK_EXPORT WindowPropertyMap : public QQmlPropertyMap
+{
+    Q_OBJECT
+public:
+    WindowPropertyMap(QtWayland::ExtendedSurface *surface, QWaylandSurface *waylandSurface, QObject *parent = nullptr);
+    ~WindowPropertyMap();
+
+    static QVariant fixupWindowProperty(
+            LipstickCompositor *compositor, QWaylandSurface *surface, const QVariant &value);
+
+protected:
+    QVariant updateValue(const QString &key, const QVariant &input) override;
+
+private:
+    inline void insertWindowProperty(const QString &key, const QVariant &value);
+
+    QPointer<QtWayland::ExtendedSurface> m_surface;
+    QPointer<QWaylandSurface> m_waylandSurface;
+};
+
+#endif // WINDOWPROPERTY_H
diff --git a/src/homeapplication.cpp b/src/homeapplication.cpp
index a9711917..230fb274 100644
--- a/src/homeapplication.cpp
+++ b/src/homeapplication.cpp
@@ -257,9 +257,9 @@ void HomeApplication::restoreSignalHandlers()
 
 void HomeApplication::sendHomeReadySignalIfNotAlreadySent()
 {
+
     if (!m_homeReadySent) {
         m_homeReadySent = true;
-
         disconnect(LipstickCompositor::instance()->quickWindow(), SIGNAL(frameSwapped()), this, SLOT(sendHomeReadySignalIfNotAlreadySent()));
 
         emit homeReady();
@@ -360,27 +360,52 @@ void HomeApplication::setCompositorPath(const QString &path)
         return;
     } 
 
-    QQuickItem *compositor = qobject_cast<QQuickItem*>(component.beginCreate(qmlEngine->rootContext()));
-    if (compositor) {
+    QScopedPointer<QObject> object(component.beginCreate(m_qmlEngine->rootContext()));
+
+    QQuickWindow *window = nullptr;
+    LipstickCompositor *compositor = nullptr;
+
+    if (!object) {
+        qWarning() << "HomeApplication: Error constructing compositor from" << path;
+        qWarning() << component.errors();
+        return;
+    } else if ((compositor = qobject_cast<LipstickCompositor*>(object.data()))) {
         compositor->setParent(this);
 
-        if (LipstickCompositor::instance()) {
-            LipstickCompositor::instance()->quickWindow()->setGeometry(QRect(QPoint(0, 0), QGuiApplication::primaryScreen()->size()));
-            connect(usbModeSelector, SIGNAL(showUnlockScreen()),
-                    LipstickCompositor::instance(), SIGNAL(showUnlockScreen()));
-            compositor->setParentItem(LipstickCompositor::instance()->quickWindow()->contentItem());
-        }
+        window = new QQuickWindow;
+        window->QObject::setParent(this);
+        window->setColor(Qt::black);
+        window->setGeometry(QRect(QPoint(0, 0), QGuiApplication::primaryScreen()->size()));
+        window->setVisible(true);
 
-        component.completeCreate();
+        object.take();
+    } else if ((window = qobject_cast<QQuickWindow *>(object.data()))) {
+        window->QObject::setParent(this);
+        window->setGeometry(QRect(QPoint(0, 0), QGuiApplication::primaryScreen()->size()));
 
-        if (!m_qmlEngine->incubationController() && LipstickCompositor::instance()) {
-            // install default incubation controller
-            m_qmlEngine->setIncubationController(LipstickCompositor::instance()->quickWindow()->incubationController());
-        }
+        compositor = LipstickCompositor::instance();
+
+        object.take();
     } else {
-        qWarning() << "HomeApplication: Error creating compositor from" << path;
-        qWarning() << component.errors();
+        component.completeCreate();
+        return;
+
+        qWarning() << "HomeApplication:" << path << "is not a a compositor" << object.data();
     }
+
+    if (compositor) {
+        compositor->setQuickWindow(window);
+
+        connect(m_usbModeSelector, &USBModeSelector::showUnlockScreen,
+                compositor, &LipstickCompositor::showUnlockScreen);
+    }
+
+    if (!m_qmlEngine->incubationController()) {
+        // install default incubation controller
+        m_qmlEngine->setIncubationController(window->incubationController());
+    }
+
+    component.completeCreate();
 }
 
 HomeWindow *HomeApplication::mainWindowInstance()
diff --git a/src/notifications/notificationfeedbackplayer.cpp b/src/notifications/notificationfeedbackplayer.cpp
index dffcc2a0..532f60b1 100644
--- a/src/notifications/notificationfeedbackplayer.cpp
+++ b/src/notifications/notificationfeedbackplayer.cpp
@@ -20,6 +20,7 @@
 #include "notificationmanager.h"
 #include "lipsticknotification.h"
 #include "notificationfeedbackplayer.h"
+#include "windowpropertymap.h"
 
 namespace {
 
@@ -112,7 +113,8 @@ bool NotificationFeedbackPlayer::isEnabled(LipstickNotification *notification)
     uint mode = AllNotificationsEnabled;
     LipstickCompositorWindow *win = LipstickCompositor::instance()->m_windows.value(LipstickCompositor::instance()->topmostWindowId());
     if (win != 0) {
-        mode = win->windowProperties().value("NOTIFICATION_PREVIEWS_DISABLED", uint(AllNotificationsEnabled)).toUInt();
+        const QVariant value = win->windowProperties()->value(QStringLiteral("NOTIFICATION_PREVIEWS_DISABLED"));
+        mode = value.isValid()? value.toUInt() : uint(AllNotificationsEnabled);
     }
 
     int urgency = notification->urgency();
diff --git a/src/notifications/notificationmanager.cpp b/src/notifications/notificationmanager.cpp
index ab4dd022..fbff66da 100644
--- a/src/notifications/notificationmanager.cpp
+++ b/src/notifications/notificationmanager.cpp
@@ -656,7 +656,7 @@ void NotificationManager::restoreNotifications(bool update)
 
 bool NotificationManager::connectToDatabase()
 {
-    QString databasePath = "/home/ceres" + QString(PRIVILEGED_DATA_PATH) + QDir::separator() + "Notifications";
+    QString databasePath = "/home/nemo" + QString(PRIVILEGED_DATA_PATH) + QDir::separator() + "Notifications";
     if (!QDir::root().exists(databasePath)) {
         QDir::root().mkpath(databasePath);
     }
diff --git a/src/notifications/notificationpreviewpresenter.cpp b/src/notifications/notificationpreviewpresenter.cpp
index 9274917e..478c7ab1 100644
--- a/src/notifications/notificationpreviewpresenter.cpp
+++ b/src/notifications/notificationpreviewpresenter.cpp
@@ -24,6 +24,7 @@
 #include "compositor/lipstickcompositorwindow.h"
 #include "notificationpreviewpresenter.h"
 #include "lipstickqmlpath.h"
+#include "windowpropertymap.h"
 
 #include "screenlock/screenlock.h"
 
@@ -216,7 +217,8 @@ bool NotificationPreviewPresenter::notificationShouldBeShown(LipstickNotificatio
     uint mode = AllNotificationsEnabled;
     LipstickCompositorWindow *win = LipstickCompositor::instance()->m_windows.value(LipstickCompositor::instance()->topmostWindowId(), 0);
     if (win != 0) {
-        mode = win->windowProperties().value("NOTIFICATION_PREVIEWS_DISABLED", uint(AllNotificationsEnabled)).toUInt();
+        const QVariant value = win->windowProperties()->value(QStringLiteral("NOTIFICATION_PREVIEWS_DISABLED"));
+        mode = value.isValid()? value.toUInt() : uint(AllNotificationsEnabled);
     }
 
     return ((!screenLocked && !deviceLocked) || notificationIsCritical) &&
diff --git a/src/src.pro b/src/src.pro
index 45355833..56105b00 100644
--- a/src/src.pro
+++ b/src/src.pro
@@ -13,7 +13,13 @@ DEFINES += LIPSTICK_BUILD_LIBRARY
 DEFINES += VERSION=\\\"$${VERSION}\\\"
 DEFINES += MESA_EGL_NO_X11_HEADERS
 
-CONFIG += qt wayland-scanner c++11
+CONFIG += \
+    hide_symbols \
+    warning_clean \
+    warnings_are_errors \
+    wayland-scanner
+
+
 INSTALLS = target ts_install engineering_english_install
 target.path = $$[QT_INSTALL_LIBS]
 
@@ -152,6 +158,7 @@ PKGCONFIG += \
     nemodevicelock \
     ngf-qt5 \
     Qt5SystemInfo \
+    ssu-sysinfo \
     systemsettings \
     thermalmanager_dbus_if \
     usb-moded-qt5
@@ -176,12 +183,8 @@ packagesExist(contextkit-statefs) {
 QT += dbus xml qml quick sql gui gui-private sensors
 
 QMAKE_CXXFLAGS += \
-    -Werror \
-    -Wfatal-errors \
     -g \
-    -fPIC \
-    -fvisibility=hidden \
-    -fvisibility-inlines-hidden
+    -fPIC
 
 QMAKE_LFLAGS += \
     -pie \
diff --git a/tests/stubs/lipstickcompositor_stub.h b/tests/stubs/lipstickcompositor_stub.h
index b6ab0312..4664888d 100644
--- a/tests/stubs/lipstickcompositor_stub.h
+++ b/tests/stubs/lipstickcompositor_stub.h
@@ -3,8 +3,23 @@
 
 #include "lipstickcompositor.h"
 #include "touchscreen/touchscreen.h"
+#include "windowpropertymap.h"
 #include <stubbase.h>
 
+#include <QWaylandSurface>
+#include <QWaylandXdgShellV5>
+
+QT_BEGIN_NAMESPACE
+namespace QtWayland {
+class ExtendedSurface : public QObject {};
+class SurfaceExtensionGlobal {};
+class QtKeyExtensionGlobal {};
+}
+QT_END_NAMESPACE
+
+
+class AlienManager {};
+
 // 1. DECLARE STUB
 // FIXME - stubgen is not yet finished
 class LipstickCompositorStub : public StubBase
@@ -15,8 +30,7 @@ public:
     virtual LipstickCompositor *instance();
     virtual void classBegin();
     virtual void componentComplete();
-    virtual void surfaceCreated(QWaylandSurface *surface);
-    virtual bool openUrl(WaylandClient *, const QUrl &);
+    virtual bool openUrl(QWaylandClient *, const QUrl &);
     virtual bool openUrl(const QUrl &);
     virtual void retainedSelectionReceived(QMimeData *mimeData);
     virtual int windowCount() const;
@@ -28,34 +42,25 @@ public:
     virtual void setTopmostWindowOrientation(Qt::ScreenOrientation topmostWindowOrientation);
     virtual void setScreenOrientation(Qt::ScreenOrientation screenOrientation);
     virtual bool displayDimmed() const;
-    virtual LipstickKeymap *keymap() const;
-    virtual void setKeymap(LipstickKeymap *keymap);
-    virtual void updateKeymap();
     virtual QObject *clipboard() const;
     virtual bool debug() const;
-    virtual QObject *windowForId(int) const;
+    virtual LipstickCompositorWindow *windowForId(int) const;
     virtual void closeClientForWindowId(int);
     virtual void clearKeyboardFocus();
     virtual void setDisplayOff();
     virtual LipstickCompositorProcWindow *mapProcWindow(const QString &title, const QString &category, const QRect &);
     virtual QWaylandSurface *surfaceForId(int) const;
-    virtual void surfaceMapped();
-    virtual void surfaceUnmapped();
     virtual void surfaceSizeChanged();
     virtual void surfaceTitleChanged();
     virtual void surfaceRaised();
     virtual void surfaceLowered();
     virtual void surfaceDamaged(const QRegion &);
     virtual void windowSwapped();
-    virtual void windowDestroyed();
     virtual void windowPropertyChanged(const QString &);
     virtual void reactOnDisplayStateChanges(TouchScreen::DisplayState oldState, TouchScreen::DisplayState newState);
     virtual void setScreenOrientationFromSensor();
     virtual void clipboardDataChanged();
     virtual void onVisibleChanged(bool visible);
-    virtual void keymapChanged();
-    virtual QWaylandSurfaceView *createView(QWaylandSurface *surf);
-    virtual void onSurfaceDying();
     virtual void readContent();
     virtual void initialize();
     virtual bool completed();
@@ -87,17 +92,10 @@ void LipstickCompositorStub::componentComplete()
     stubMethodEntered("componentComplete");
 }
 
-void LipstickCompositorStub::surfaceCreated(QWaylandSurface *surface)
-{
-    QList<ParameterBase *> params;
-    params.append( new Parameter<QWaylandSurface * >(surface));
-    stubMethodEntered("surfaceCreated", params);
-}
-
-bool LipstickCompositorStub::openUrl(WaylandClient *client, const QUrl &url)
+bool LipstickCompositorStub::openUrl(QWaylandClient *client, const QUrl &url)
 {
     QList<ParameterBase *> params;
-    params.append( new Parameter<WaylandClient * >(client));
+    params.append( new Parameter<QWaylandClient * >(client));
     params.append( new Parameter<const QUrl &>(url));
     stubMethodEntered("openUrl", params);
     return stubReturnValue<bool>("openUrl");
@@ -177,24 +175,6 @@ bool LipstickCompositorStub::displayDimmed() const
     return stubReturnValue<bool>("displayDimmed");
 }
 
-LipstickKeymap *LipstickCompositorStub::keymap() const
-{
-    stubMethodEntered("keymap");
-    return stubReturnValue<LipstickKeymap *>("keymap");
-}
-
-void LipstickCompositorStub::setKeymap(LipstickKeymap *keymap)
-{
-    QList<ParameterBase *> params;
-    params.append( new Parameter<LipstickKeymap *>(keymap));
-    stubMethodEntered("setKeymap", params);
-}
-
-void LipstickCompositorStub::updateKeymap()
-{
-    stubMethodEntered("updateKeymap");
-}
-
 QObject *LipstickCompositorStub::clipboard() const
 {
     stubMethodEntered("clipboard");
@@ -207,12 +187,12 @@ bool LipstickCompositorStub::debug() const
     return stubReturnValue<bool>("debug");
 }
 
-QObject *LipstickCompositorStub::windowForId(int id) const
+LipstickCompositorWindow *LipstickCompositorStub::windowForId(int id) const
 {
     QList<ParameterBase *> params;
     params.append( new Parameter<int >(id));
     stubMethodEntered("windowForId", params);
-    return stubReturnValue<QObject *>("windowForId");
+    return stubReturnValue<LipstickCompositorWindow *>("windowForId");
 }
 
 void LipstickCompositorStub::closeClientForWindowId(int id)
@@ -250,16 +230,6 @@ QWaylandSurface *LipstickCompositorStub::surfaceForId(int id) const
     return stubReturnValue<QWaylandSurface *>("surfaceForId");
 }
 
-void LipstickCompositorStub::surfaceMapped()
-{
-    stubMethodEntered("surfaceMapped");
-}
-
-void LipstickCompositorStub::surfaceUnmapped()
-{
-    stubMethodEntered("surfaceUnmapped");
-}
-
 void LipstickCompositorStub::surfaceSizeChanged()
 {
     stubMethodEntered("surfaceSizeChanged");
@@ -280,11 +250,6 @@ void LipstickCompositorStub::surfaceLowered()
     stubMethodEntered("surfaceLowered");
 }
 
-void LipstickCompositorStub::onSurfaceDying()
-{
-    stubMethodEntered("onSurfaceDying");
-}
-
 void LipstickCompositorStub::readContent()
 {
     stubMethodEntered("readContent");
@@ -320,11 +285,6 @@ void LipstickCompositorStub::windowSwapped()
     stubMethodEntered("windowSwapped");
 }
 
-void LipstickCompositorStub::windowDestroyed()
-{
-    stubMethodEntered("windowDestroyed");
-}
-
 void LipstickCompositorStub::windowPropertyChanged(const QString &property)
 {
     QList<ParameterBase *> params;
@@ -357,19 +317,6 @@ void LipstickCompositorStub::onVisibleChanged(bool v)
     stubMethodEntered("onVisibleChanged", params);
 }
 
-void LipstickCompositorStub::keymapChanged()
-{
-    stubMethodEntered("keymapChanged");
-}
-
-QWaylandSurfaceView *LipstickCompositorStub::createView(QWaylandSurface *surf)
-{
-    QList<ParameterBase *> params;
-    params.append( new Parameter<QWaylandSurface *>(surf));
-    stubMethodEntered("createView", params);
-    return stubReturnValue<QWaylandSurfaceView *>("createView");
-}
-
 // 3. CREATE A STUB INSTANCE
 LipstickCompositorStub gDefaultLipstickCompositorStub;
 LipstickCompositorStub *gLipstickCompositorStub = &gDefaultLipstickCompositorStub;
@@ -386,27 +333,17 @@ LipstickCompositor::~LipstickCompositor()
     gLipstickCompositorStub->LipstickCompositorDestructor();
 }
 
-LipstickCompositor *LipstickCompositor::instance()
-{
-    return gLipstickCompositorStub->instance();
-}
-
-void LipstickCompositor::classBegin()
-{
-    gLipstickCompositorStub->classBegin();
-}
-
 void LipstickCompositor::componentComplete()
 {
-    gLipstickCompositorStub->componentComplete();
+    QWaylandQuickCompositor::componentComplete();
 }
 
-void LipstickCompositor::surfaceCreated(QWaylandSurface *surface)
+LipstickCompositor *LipstickCompositor::instance()
 {
-    gLipstickCompositorStub->surfaceCreated(surface);
+    return gLipstickCompositorStub->instance();
 }
 
-bool LipstickCompositor::openUrl(WaylandClient *client, const QUrl &url)
+bool LipstickCompositor::openUrl(QWaylandClient *client, const QUrl &url)
 {
     return gLipstickCompositorStub->openUrl(client, url);
 }
@@ -466,21 +403,6 @@ bool LipstickCompositor::displayDimmed() const
     return gLipstickCompositorStub->displayDimmed();
 }
 
-LipstickKeymap *LipstickCompositor::keymap() const
-{
-    return gLipstickCompositorStub->keymap();
-}
-
-void LipstickCompositor::setKeymap(LipstickKeymap *keymap)
-{
-    gLipstickCompositorStub->setKeymap(keymap);
-}
-
-void LipstickCompositor::updateKeymap()
-{
-    gLipstickCompositorStub->updateKeymap();
-}
-
 QObject *LipstickCompositor::clipboard() const
 {
     return gLipstickCompositorStub->clipboard();
@@ -491,7 +413,7 @@ bool LipstickCompositor::debug() const
     return gLipstickCompositorStub->debug();
 }
 
-QObject *LipstickCompositor::windowForId(int id) const
+LipstickCompositorWindow *LipstickCompositor::windowForId(int id) const
 {
     return gLipstickCompositorStub->windowForId(id);
 }
@@ -521,16 +443,6 @@ QWaylandSurface *LipstickCompositor::surfaceForId(int id) const
     return gLipstickCompositorStub->surfaceForId(id);
 }
 
-void LipstickCompositor::surfaceMapped()
-{
-    gLipstickCompositorStub->surfaceMapped();
-}
-
-void LipstickCompositor::surfaceUnmapped()
-{
-    gLipstickCompositorStub->surfaceUnmapped();
-}
-
 void LipstickCompositor::surfaceSizeChanged()
 {
     gLipstickCompositorStub->surfaceSizeChanged();
@@ -541,16 +453,6 @@ void LipstickCompositor::surfaceTitleChanged()
     gLipstickCompositorStub->surfaceTitleChanged();
 }
 
-void LipstickCompositor::surfaceRaised()
-{
-    gLipstickCompositorStub->surfaceRaised();
-}
-
-void LipstickCompositor::surfaceLowered()
-{
-    gLipstickCompositorStub->surfaceLowered();
-}
-
 void LipstickCompositor::surfaceDamaged(const QRegion &rect)
 {
     gLipstickCompositorStub->surfaceDamaged(rect);
@@ -561,16 +463,6 @@ void LipstickCompositor::windowSwapped()
     gLipstickCompositorStub->windowSwapped();
 }
 
-void LipstickCompositor::windowDestroyed()
-{
-    gLipstickCompositorStub->windowDestroyed();
-}
-
-void LipstickCompositor::windowPropertyChanged(const QString &property)
-{
-    gLipstickCompositorStub->windowPropertyChanged(property);
-}
-
 void LipstickCompositor::reactOnDisplayStateChanges(TouchScreen::DisplayState oldState, TouchScreen::DisplayState newState)
 {
     gLipstickCompositorStub->reactOnDisplayStateChanges(oldState, newState);
@@ -595,42 +487,54 @@ void LipstickCompositor::onVisibleChanged(bool v)
     gLipstickCompositorStub->onVisibleChanged(v);
 }
 
-QWaylandSurfaceView *LipstickCompositor::createView(QWaylandSurface *surf)
+void LipstickCompositor::initialize()
 {
-    return gLipstickCompositorStub->createView(surf);
+    gLipstickCompositorStub->initialize();
 }
 
-void LipstickCompositor::onSurfaceDying()
+bool LipstickCompositor::completed()
 {
-    gLipstickCompositorStub->onSurfaceDying();
+    return gLipstickCompositorStub->completed();
 }
 
-void LipstickCompositor::readContent()
+void LipstickCompositor::timerEvent(QTimerEvent *e)
 {
-    gLipstickCompositorStub->readContent();
+    gLipstickCompositorStub->timerEvent(e);
 }
 
-void LipstickCompositor::initialize()
+QQmlListProperty<QObject> LipstickCompositor::data()
 {
-    gLipstickCompositorStub->initialize();
+    return QQmlListProperty<QObject>();
 }
 
-bool LipstickCompositor::completed()
+QWaylandKeymap *LipstickCompositor::keymap()
 {
-    return gLipstickCompositorStub->completed();
+    return nullptr;
 }
 
-void LipstickCompositor::timerEvent(QTimerEvent *e)
+QWaylandCompositor::QWaylandCompositor(QObject *)
+{
+}
+
+QWaylandQuickCompositor::QWaylandQuickCompositor(QObject *)
+{
+}
+
+WindowPropertyMap::WindowPropertyMap(
+        QtWayland::ExtendedSurface *surface, QWaylandSurface *waylandSurface,  QObject *parent)
+    : QQmlPropertyMap(parent)
+    , m_surface(surface)
+    , m_waylandSurface(waylandSurface)
 {
-    gLipstickCompositorStub->timerEvent(e);
 }
 
-QWaylandCompositor::QWaylandCompositor(QWindow *, const char *, QWaylandCompositor::ExtensionFlags)
+WindowPropertyMap::~WindowPropertyMap()
 {
 }
 
-QWaylandQuickCompositor::QWaylandQuickCompositor(QQuickWindow *, const char *, QWaylandCompositor::ExtensionFlags)
+QVariant WindowPropertyMap::updateValue(const QString &key, const QVariant &value)
 {
+    return QQmlPropertyMap::updateValue(key, value);
 }
 
 #endif
diff --git a/tests/ut_notificationfeedbackplayer/ut_notificationfeedbackplayer.cpp b/tests/ut_notificationfeedbackplayer/ut_notificationfeedbackplayer.cpp
index 92321c17..d7ec5c07 100644
--- a/tests/ut_notificationfeedbackplayer/ut_notificationfeedbackplayer.cpp
+++ b/tests/ut_notificationfeedbackplayer/ut_notificationfeedbackplayer.cpp
@@ -17,9 +17,11 @@
 #include "notificationmanager.h"
 #include "notificationfeedbackplayer.h"
 #include "lipstickcompositor_stub.h"
+#include "lipstickcompositorwindow.h"
 #include "lipsticknotification.h"
 #include "ngfclient_stub.h"
 #include "ut_notificationfeedbackplayer.h"
+#include "windowpropertymap.h"
 
 NotificationManager::NotificationManager(QObject *parent, bool owner) : QObject(parent)
 {
@@ -95,12 +97,6 @@ LipstickNotification *createNotification(uint id, int urgency = 0, QVariant prio
     return notification;
 }
 
-QVariantMap qWaylandSurfaceWindowProperties;
-QVariantMap QWaylandSurface::windowProperties() const
-{
-    return qWaylandSurfaceWindowProperties;
-}
-
 void QTimer::singleShot(int, const QObject *receiver, const char *member)
 {
     // The "member" string is of form "1member()", so remove the trailing 1 and the ()
@@ -111,6 +107,13 @@ void QTimer::singleShot(int, const QObject *receiver, const char *member)
     QMetaObject::invokeMethod(const_cast<QObject *>(receiver), modifiedMember, Qt::DirectConnection);
 }
 
+WindowPropertyMap qWaylandSurfaceWindowProperties(nullptr, nullptr);
+
+WindowPropertyMap *LipstickCompositorWindow::windowProperties()
+{
+    return &qWaylandSurfaceWindowProperties;
+}
+
 void Ut_NotificationFeedbackPlayer::initTestCase()
 {
     gLipstickCompositorStub->stubSetReturnValue("instance", new LipstickCompositor());
@@ -342,7 +345,9 @@ void Ut_NotificationFeedbackPlayer::testNotificationPreviewsDisabled()
     QFETCH(int, playCount);
 
     gLipstickCompositorStub->stubSetReturnValue("surfaceForId", surface);
-    qWaylandSurfaceWindowProperties = windowProperties;
+    for (auto it = windowProperties.begin(); it != windowProperties.end(); ++it) {
+        qWaylandSurfaceWindowProperties.insert(it.key(), it.value());
+    }
 
     createNotification(1, urgency);
     player->addNotification(1);
diff --git a/tests/ut_notificationfeedbackplayer/ut_notificationfeedbackplayer.pro b/tests/ut_notificationfeedbackplayer/ut_notificationfeedbackplayer.pro
index 05529bdb..1fb76a4b 100644
--- a/tests/ut_notificationfeedbackplayer/ut_notificationfeedbackplayer.pro
+++ b/tests/ut_notificationfeedbackplayer/ut_notificationfeedbackplayer.pro
@@ -11,6 +11,7 @@ HEADERS += \
     $$NOTIFICATIONSRCDIR/notificationmanager.h \
     $$NOTIFICATIONSRCDIR/lipsticknotification.h \
     $$COMPOSITORSRCDIR/lipstickcompositor.h \
+    $$COMPOSITORSRCDIR/windowpropertymap.h \
     /usr/include/ngf-qt5/ngfclient.h
 
 SOURCES += \
diff --git a/tests/ut_notificationpreviewpresenter/ut_notificationpreviewpresenter.cpp b/tests/ut_notificationpreviewpresenter/ut_notificationpreviewpresenter.cpp
index be32a7bf..a0b12334 100644
--- a/tests/ut_notificationpreviewpresenter/ut_notificationpreviewpresenter.cpp
+++ b/tests/ut_notificationpreviewpresenter/ut_notificationpreviewpresenter.cpp
@@ -23,12 +23,14 @@
 #include "notificationpreviewpresenter.h"
 #include "notificationfeedbackplayer_stub.h"
 #include "lipstickcompositor_stub.h"
+#include "lipstickcompositorwindow.h"
 #include "closeeventeater_stub.h"
 #include "qmdisplaystate_stub.h"
 #include "lipstickqmlpath_stub.h"
 #include "lipsticksettings.h"
 #include "screenlock/screenlock.h"
 #include <nemo-devicelock/devicelock.h>
+#include "windowpropertymap.h"
 
 Q_DECLARE_METATYPE(NotificationPreviewPresenter*)
 Q_DECLARE_METATYPE(LipstickNotification*)
@@ -189,10 +191,10 @@ LipstickNotification *createNotification(uint id, Urgency urgency = Normal)
     return notification;
 }
 
-QVariantMap qWaylandSurfaceWindowProperties;
-QVariantMap QWaylandSurface::windowProperties() const
+WindowPropertyMap qWaylandSurfaceWindowProperties(nullptr, nullptr);
+WindowPropertyMap *LipstickCompositorWindow::windowProperties()
 {
-    return qWaylandSurfaceWindowProperties;
+    return &qWaylandSurfaceWindowProperties;
 }
 
 void Ut_NotificationPreviewPresenter::initTestCase()
@@ -612,7 +614,9 @@ void Ut_NotificationPreviewPresenter::testNotificationPreviewsDisabled()
     QFETCH(int, showCount);
 
     gLipstickCompositorStub->stubSetReturnValue("surfaceForId", surface);
-    qWaylandSurfaceWindowProperties = windowProperties;
+    for (auto it = windowProperties.begin(); it != windowProperties.end(); ++it) {
+        qWaylandSurfaceWindowProperties.insert(it.key(), it.value());
+    }
 
     NotificationPreviewPresenter presenter(screenLock, deviceLock);
     createNotification(1, static_cast<Urgency>(urgency));
diff --git a/tests/ut_notificationpreviewpresenter/ut_notificationpreviewpresenter.pro b/tests/ut_notificationpreviewpresenter/ut_notificationpreviewpresenter.pro
index 5d206109..7dbf7221 100644
--- a/tests/ut_notificationpreviewpresenter/ut_notificationpreviewpresenter.pro
+++ b/tests/ut_notificationpreviewpresenter/ut_notificationpreviewpresenter.pro
@@ -1,5 +1,7 @@
 include(../common.pri)
 TARGET = ut_notificationpreviewpresenter
+
+QT += qml quick dbus waylandcompositor
 INCLUDEPATH += \
     $$SRCDIR \
     $$NOTIFICATIONSRCDIR \
@@ -9,12 +11,6 @@ INCLUDEPATH += \
     $$QMSYSTEM2 \
     $$SCREENLOCKSRCDIR
 
-QT += \
-    dbus \
-    qml \
-    quick \
-    waylandcompositor
-
 # unit test and unit
 SOURCES += \
     ut_notificationpreviewpresenter.cpp \
@@ -35,6 +31,7 @@ HEADERS += \
     $$TOUCHSCREENSRCDIR/touchscreen.h \
     $$UTILITYSRCDIR/closeeventeater.h \
     $$COMPOSITORSRCDIR/lipstickcompositor.h \
+    $$COMPOSITORSRCDIR/windowpropertymap.h \
     $$QMSYSTEM2/qmdisplaystate.h \
     $$SRCDIR/homewindow.h \
     $$STUBSDIR/nemo-devicelock/devicelock.h
diff --git a/tools/tools.pro b/tools/tools.pro
index 82f61f42..7b7f1cbe 100644
--- a/tools/tools.pro
+++ b/tools/tools.pro
@@ -1,4 +1,2 @@
 TEMPLATE = subdirs
-
-SUBDIRS += \
-    notificationtool
+SUBDIRS += notificationtool
-- 
2.23.0

